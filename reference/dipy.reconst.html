<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Dipy &mdash; dipy 0.10.0dev documentation</title>
    
    <link rel="stylesheet" href="../_static/dipy.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.10.0dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="dipy 0.10.0dev documentation" href="../index.html" />
    <link rel="up" title="API Reference" href="index.html" />
  <meta name="keywords" content="dipy, dMRI, DTI, DSI, diffusion MRI, Tensor,
  neuroimaging, python, neuroscience, Eleftherios, Garyfallidis, tractography,
  streamlines, fiber tracking">

  </head>
  <body>
<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
 <a href="../index.html">
  <img src="../_static/dipy-banner.png" alt="dipy logo"  border="0" />
</div>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
  <li><a href="../index.html">Home</a> |&nbsp;</li>
  <li><a href="../stateoftheart.html">Overview</a> |&nbsp;</li>
  <li><a href="../examples_index.html">Gallery</a> |&nbsp;</li>
  <li><a href="../installation.html">Download</a> |&nbsp;</li>
  <li><a href="../subscribe.html">Subscribe</a> |&nbsp;</li>
  <li><a href="../developers.html">Developers</a> |&nbsp;</li>
  <li><a href="../cite.html">Cite</a> &nbsp;</li>

          <li><a href="../documentation.html" >Documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">API Reference</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">

  
<h4> Site Navigation </h4>
  <ul>
    <li><a href="../documentation.html">Documentation</a></li>
    <li><a href="../devel/index.html">Development</a></li>
  </ul>

<h4> NIPY Community </h4>
  <ul class="simple">
    <li><a class="reference external"
	href="http://nipy.org/">Community Home</a></li>
    <li><a class="reference external"
	href="http://nipy.org/software/projects/">NIPY Projects</a></li>
    <li><a class="reference external"
	href="http://mail.scipy.org/mailman/listinfo/nipy-devel">Mailing List</a></li>
    <li><a class="reference external"
	href="http://nipy.org/software/license/index.html">License</a></li>
  </ul>


  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><tt class="docutils literal"><span class="pre">reconst</span></tt></a><ul>
<li><a class="reference internal" href="#module-dipy.reconst.base">Module: <tt class="docutils literal"><span class="pre">reconst.base</span></tt></a></li>
<li><a class="reference internal" href="#module-dipy.reconst.benchmarks">Module: <tt class="docutils literal"><span class="pre">reconst.benchmarks</span></tt></a></li>
<li><a class="reference internal" href="#module-dipy.reconst.benchmarks.bench_bounding_box">Module: <tt class="docutils literal"><span class="pre">reconst.benchmarks.bench_bounding_box</span></tt></a></li>
<li><a class="reference internal" href="#module-dipy.reconst.benchmarks.bench_csd">Module: <tt class="docutils literal"><span class="pre">reconst.benchmarks.bench_csd</span></tt></a></li>
<li><a class="reference internal" href="#module-dipy.reconst.benchmarks.bench_peaks">Module: <tt class="docutils literal"><span class="pre">reconst.benchmarks.bench_peaks</span></tt></a></li>
<li><a class="reference internal" href="#module-dipy.reconst.benchmarks.bench_squash">Module: <tt class="docutils literal"><span class="pre">reconst.benchmarks.bench_squash</span></tt></a></li>
<li><a class="reference internal" href="#module-dipy.reconst.benchmarks.bench_vec_val_sum">Module: <tt class="docutils literal"><span class="pre">reconst.benchmarks.bench_vec_val_sum</span></tt></a></li>
<li><a class="reference internal" href="#module-dipy.reconst.cache">Module: <tt class="docutils literal"><span class="pre">reconst.cache</span></tt></a></li>
<li><a class="reference internal" href="#module-dipy.reconst.cross_validation">Module: <tt class="docutils literal"><span class="pre">reconst.cross_validation</span></tt></a></li>
<li><a class="reference internal" href="#module-dipy.reconst.csdeconv">Module: <tt class="docutils literal"><span class="pre">reconst.csdeconv</span></tt></a></li>
<li><a class="reference internal" href="#module-dipy.reconst.dsi">Module: <tt class="docutils literal"><span class="pre">reconst.dsi</span></tt></a></li>
<li><a class="reference internal" href="#module-dipy.reconst.dti">Module: <tt class="docutils literal"><span class="pre">reconst.dti</span></tt></a></li>
<li><a class="reference internal" href="#module-dipy.reconst.gqi">Module: <tt class="docutils literal"><span class="pre">reconst.gqi</span></tt></a></li>
<li><a class="reference internal" href="#module-dipy.reconst.interpolate">Module: <tt class="docutils literal"><span class="pre">reconst.interpolate</span></tt></a></li>
<li><a class="reference internal" href="#module-dipy.reconst.multi_voxel">Module: <tt class="docutils literal"><span class="pre">reconst.multi_voxel</span></tt></a></li>
<li><a class="reference internal" href="#module-dipy.reconst.odf">Module: <tt class="docutils literal"><span class="pre">reconst.odf</span></tt></a></li>
<li><a class="reference internal" href="#module-dipy.reconst.peaks">Module: <tt class="docutils literal"><span class="pre">reconst.peaks</span></tt></a></li>
<li><a class="reference internal" href="#module-dipy.reconst.sfm">Module: <tt class="docutils literal"><span class="pre">reconst.sfm</span></tt></a></li>
<li><a class="reference internal" href="#module-dipy.reconst.shm">Module: <tt class="docutils literal"><span class="pre">reconst.shm</span></tt></a><ul>
<li><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-dipy.reconst.shore">Module: <tt class="docutils literal"><span class="pre">reconst.shore</span></tt></a><ul>
<li><a class="reference internal" href="#bench">bench</a></li>
<li><a class="reference internal" href="#test">test</a></li>
<li><a class="reference internal" href="#reconstfit"><tt class="docutils literal"><span class="pre">ReconstFit</span></tt></a></li>
<li><a class="reference internal" href="#reconstmodel"><tt class="docutils literal"><span class="pre">ReconstModel</span></tt></a></li>
<li><a class="reference internal" href="#bench-bounding-box">bench_bounding_box</a></li>
<li><a class="reference internal" href="#bounding-box">bounding_box</a></li>
<li><a class="reference internal" href="#measure">measure</a></li>
<li><a class="reference internal" href="#constrainedsphericaldeconvmodel"><tt class="docutils literal"><span class="pre">ConstrainedSphericalDeconvModel</span></tt></a></li>
<li><a class="reference internal" href="#gradienttable"><tt class="docutils literal"><span class="pre">GradientTable</span></tt></a><ul>
</ul>
</li>
<li><a class="reference internal" href="#bench-csdeconv">bench_csdeconv</a></li>
<li><a class="reference internal" href="#num-grad">num_grad</a></li>
<li><a class="reference internal" href="#read-stanford-labels">read_stanford_labels</a></li>
<li><a class="reference internal" href="#bench-local-maxima">bench_local_maxima</a></li>
<li><a class="reference internal" href="#get-sphere">get_sphere</a></li>
<li><a class="reference internal" href="#local-maxima">local_maxima</a></li>
<li><a class="reference internal" href="#id33">measure</a></li>
<li><a class="reference internal" href="#unique-edges">unique_edges</a></li>
<li><a class="reference internal" href="#bench-quick-squash">bench_quick_squash</a></li>
<li><a class="reference internal" href="#id34">measure</a></li>
<li><a class="reference internal" href="#ndindex">ndindex</a></li>
<li><a class="reference internal" href="#old-squash">old_squash</a></li>
<li><a class="reference internal" href="#quick-squash">quick_squash</a></li>
<li><a class="reference internal" href="#reduce">reduce</a></li>
<li><a class="reference internal" href="#bench-vec-val-vect">bench_vec_val_vect</a></li>
<li><a class="reference internal" href="#id35">measure</a></li>
<li><a class="reference internal" href="#randn">randn</a></li>
<li><a class="reference internal" href="#vec-val-vect">vec_val_vect</a></li>
<li><a class="reference internal" href="#with-einsum">with_einsum</a></li>
<li><a class="reference internal" href="#cache"><tt class="docutils literal"><span class="pre">Cache</span></tt></a></li>
<li><a class="reference internal" href="#auto-attr">auto_attr</a></li>
<li><a class="reference internal" href="#range"><tt class="docutils literal"><span class="pre">range</span></tt></a></li>
<li><a class="reference internal" href="#coeff-of-determination">coeff_of_determination</a></li>
<li><a class="reference internal" href="#kfold-xval">kfold_xval</a></li>
<li><a class="reference internal" href="#axsymshresponse"><tt class="docutils literal"><span class="pre">AxSymShResponse</span></tt></a></li>
<li><a class="reference internal" href="#constrainedsdtmodel"><tt class="docutils literal"><span class="pre">ConstrainedSDTModel</span></tt></a></li>
<li><a class="reference internal" href="#id42"><tt class="docutils literal"><span class="pre">ConstrainedSphericalDeconvModel</span></tt></a></li>
<li><a class="reference internal" href="#sphharmfit"><tt class="docutils literal"><span class="pre">SphHarmFit</span></tt></a></li>
<li><a class="reference internal" href="#sphharmmodel"><tt class="docutils literal"><span class="pre">SphHarmModel</span></tt></a></li>
<li><a class="reference internal" href="#tensormodel"><tt class="docutils literal"><span class="pre">TensorModel</span></tt></a></li>
<li><a class="reference internal" href="#id64"><tt class="docutils literal"><span class="pre">range</span></tt></a></li>
<li><a class="reference internal" href="#auto-response">auto_response</a></li>
<li><a class="reference internal" href="#cart2sphere">cart2sphere</a></li>
<li><a class="reference internal" href="#csdeconv">csdeconv</a></li>
<li><a class="reference internal" href="#estimate-response">estimate_response</a></li>
<li><a class="reference internal" href="#fa-trace-to-lambdas">fa_trace_to_lambdas</a></li>
<li><a class="reference internal" href="#forward-sdeconv-mat">forward_sdeconv_mat</a></li>
<li><a class="reference internal" href="#forward-sdt-deconv-mat">forward_sdt_deconv_mat</a></li>
<li><a class="reference internal" href="#fractional-anisotropy">fractional_anisotropy</a></li>
<li><a class="reference internal" href="#id72">get_sphere</a></li>
<li><a class="reference internal" href="#lazy-index">lazy_index</a></li>
<li><a class="reference internal" href="#lpn">lpn</a></li>
<li><a class="reference internal" href="#multi-voxel-fit">multi_voxel_fit</a></li>
<li><a class="reference internal" href="#id73">ndindex</a></li>
<li><a class="reference internal" href="#odf-deconv">odf_deconv</a></li>
<li><a class="reference internal" href="#odf-sh-to-sharp">odf_sh_to_sharp</a></li>
<li><a class="reference internal" href="#peaks-from-model">peaks_from_model</a></li>
<li><a class="reference internal" href="#quad">quad</a></li>
<li><a class="reference internal" href="#real-sph-harm">real_sph_harm</a></li>
<li><a class="reference internal" href="#real-sym-sh-basis">real_sym_sh_basis</a></li>
<li><a class="reference internal" href="#recursive-response">recursive_response</a></li>
<li><a class="reference internal" href="#sh-to-rh">sh_to_rh</a></li>
<li><a class="reference internal" href="#single-tensor">single_tensor</a></li>
<li><a class="reference internal" href="#sph-harm-ind-list">sph_harm_ind_list</a></li>
<li><a class="reference internal" href="#vec2vec-rotmat">vec2vec_rotmat</a></li>
<li><a class="reference internal" href="#id97"><tt class="docutils literal"><span class="pre">Cache</span></tt></a></li>
<li><a class="reference internal" href="#diffusionspectrumdeconvfit"><tt class="docutils literal"><span class="pre">DiffusionSpectrumDeconvFit</span></tt></a></li>
<li><a class="reference internal" href="#diffusionspectrumdeconvmodel"><tt class="docutils literal"><span class="pre">DiffusionSpectrumDeconvModel</span></tt></a></li>
<li><a class="reference internal" href="#diffusionspectrumfit"><tt class="docutils literal"><span class="pre">DiffusionSpectrumFit</span></tt></a></li>
<li><a class="reference internal" href="#diffusionspectrummodel"><tt class="docutils literal"><span class="pre">DiffusionSpectrumModel</span></tt></a></li>
<li><a class="reference internal" href="#odffit"><tt class="docutils literal"><span class="pre">OdfFit</span></tt></a></li>
<li><a class="reference internal" href="#odfmodel"><tt class="docutils literal"><span class="pre">OdfModel</span></tt></a></li>
<li><a class="reference internal" href="#lr-deconv">LR_deconv</a></li>
<li><a class="reference internal" href="#create-qspace">create_qspace</a></li>
<li><a class="reference internal" href="#create-qtable">create_qtable</a></li>
<li><a class="reference internal" href="#fftn">fftn</a></li>
<li><a class="reference internal" href="#fftshift">fftshift</a></li>
<li><a class="reference internal" href="#gen-psf">gen_PSF</a></li>
<li><a class="reference internal" href="#gfa">gfa</a></li>
<li><a class="reference internal" href="#half-to-full-qspace">half_to_full_qspace</a></li>
<li><a class="reference internal" href="#hanning-filter">hanning_filter</a></li>
<li><a class="reference internal" href="#ifftshift">ifftshift</a></li>
<li><a class="reference internal" href="#id116">local_maxima</a></li>
<li><a class="reference internal" href="#map-coordinates">map_coordinates</a></li>
<li><a class="reference internal" href="#id117">multi_voxel_fit</a></li>
<li><a class="reference internal" href="#pdf-interp-coords">pdf_interp_coords</a></li>
<li><a class="reference internal" href="#pdf-odf">pdf_odf</a></li>
<li><a class="reference internal" href="#project-hemisph-bvecs">project_hemisph_bvecs</a></li>
<li><a class="reference internal" href="#remove-similar-vertices">remove_similar_vertices</a></li>
<li><a class="reference internal" href="#threshold-propagator">threshold_propagator</a></li>
<li><a class="reference internal" href="#id118"><tt class="docutils literal"><span class="pre">ReconstFit</span></tt></a></li>
<li><a class="reference internal" href="#id119"><tt class="docutils literal"><span class="pre">ReconstModel</span></tt></a></li>
<li><a class="reference internal" href="#sphere"><tt class="docutils literal"><span class="pre">Sphere</span></tt></a></li>
<li><a class="reference internal" href="#tensorfit"><tt class="docutils literal"><span class="pre">TensorFit</span></tt></a></li>
<li><a class="reference internal" href="#id125"><tt class="docutils literal"><span class="pre">TensorModel</span></tt></a></li>
<li><a class="reference internal" href="#id136"><tt class="docutils literal"><span class="pre">range</span></tt></a></li>
<li><a class="reference internal" href="#apparent-diffusion-coef">apparent_diffusion_coef</a></li>
<li><a class="reference internal" href="#id137">auto_attr</a></li>
<li><a class="reference internal" href="#axial-diffusivity">axial_diffusivity</a></li>
<li><a class="reference internal" href="#color-fa">color_fa</a></li>
<li><a class="reference internal" href="#decompose-tensor">decompose_tensor</a></li>
<li><a class="reference internal" href="#design-matrix">design_matrix</a></li>
<li><a class="reference internal" href="#determinant">determinant</a></li>
<li><a class="reference internal" href="#deviatoric">deviatoric</a></li>
<li><a class="reference internal" href="#eig-from-lo-tri">eig_from_lo_tri</a></li>
<li><a class="reference internal" href="#id140">fractional_anisotropy</a></li>
<li><a class="reference internal" href="#from-lower-triangular">from_lower_triangular</a></li>
<li><a class="reference internal" href="#geodesic-anisotropy">geodesic_anisotropy</a></li>
<li><a class="reference internal" href="#id153">get_sphere</a></li>
<li><a class="reference internal" href="#gradient-table">gradient_table</a></li>
<li><a class="reference internal" href="#isotropic">isotropic</a></li>
<li><a class="reference internal" href="#linearity">linearity</a></li>
<li><a class="reference internal" href="#lower-triangular">lower_triangular</a></li>
<li><a class="reference internal" href="#mean-diffusivity">mean_diffusivity</a></li>
<li><a class="reference internal" href="#mode">mode</a></li>
<li><a class="reference internal" href="#nlls-fit-tensor">nlls_fit_tensor</a></li>
<li><a class="reference internal" href="#norm">norm</a></li>
<li><a class="reference internal" href="#ols-fit-tensor">ols_fit_tensor</a></li>
<li><a class="reference internal" href="#planarity">planarity</a></li>
<li><a class="reference internal" href="#quantize-evecs">quantize_evecs</a></li>
<li><a class="reference internal" href="#radial-diffusivity">radial_diffusivity</a></li>
<li><a class="reference internal" href="#restore-fit-tensor">restore_fit_tensor</a></li>
<li><a class="reference internal" href="#sphericity">sphericity</a></li>
<li><a class="reference internal" href="#tensor-prediction">tensor_prediction</a></li>
<li><a class="reference internal" href="#trace">trace</a></li>
<li><a class="reference internal" href="#id167">vec_val_vect</a></li>
<li><a class="reference internal" href="#vector-norm">vector_norm</a></li>
<li><a class="reference internal" href="#wls-fit-tensor">wls_fit_tensor</a></li>
<li><a class="reference internal" href="#id170"><tt class="docutils literal"><span class="pre">Cache</span></tt></a></li>
<li><a class="reference internal" href="#generalizedqsamplingfit"><tt class="docutils literal"><span class="pre">GeneralizedQSamplingFit</span></tt></a></li>
<li><a class="reference internal" href="#generalizedqsamplingmodel"><tt class="docutils literal"><span class="pre">GeneralizedQSamplingModel</span></tt></a></li>
<li><a class="reference internal" href="#id178"><tt class="docutils literal"><span class="pre">OdfFit</span></tt></a></li>
<li><a class="reference internal" href="#id179"><tt class="docutils literal"><span class="pre">OdfModel</span></tt></a></li>
<li><a class="reference internal" href="#equatorial-maximum">equatorial_maximum</a></li>
<li><a class="reference internal" href="#equatorial-zone-vertices">equatorial_zone_vertices</a></li>
<li><a class="reference internal" href="#id180">gfa</a></li>
<li><a class="reference internal" href="#id181">local_maxima</a></li>
<li><a class="reference internal" href="#id182">multi_voxel_fit</a></li>
<li><a class="reference internal" href="#normalize-qa">normalize_qa</a></li>
<li><a class="reference internal" href="#npa">npa</a></li>
<li><a class="reference internal" href="#odf-sum">odf_sum</a></li>
<li><a class="reference internal" href="#patch-maximum">patch_maximum</a></li>
<li><a class="reference internal" href="#patch-sum">patch_sum</a></li>
<li><a class="reference internal" href="#patch-vertices">patch_vertices</a></li>
<li><a class="reference internal" href="#polar-zone-vertices">polar_zone_vertices</a></li>
<li><a class="reference internal" href="#id183">remove_similar_vertices</a></li>
<li><a class="reference internal" href="#squared-radial-component">squared_radial_component</a></li>
<li><a class="reference internal" href="#triple-odf-maxima">triple_odf_maxima</a></li>
<li><a class="reference internal" href="#upper-hemi-map">upper_hemi_map</a></li>
<li><a class="reference internal" href="#interpolator"><tt class="docutils literal"><span class="pre">Interpolator</span></tt></a></li>
<li><a class="reference internal" href="#nearestneighborinterpolator"><tt class="docutils literal"><span class="pre">NearestNeighborInterpolator</span></tt></a></li>
<li><a class="reference internal" href="#outsideimage"><tt class="docutils literal"><span class="pre">OutsideImage</span></tt></a></li>
<li><a class="reference internal" href="#trilinearinterpolator"><tt class="docutils literal"><span class="pre">TriLinearInterpolator</span></tt></a></li>
<li><a class="reference internal" href="#array">array</a></li>
<li><a class="reference internal" href="#trilinear-interp">trilinear_interp</a></li>
<li><a class="reference internal" href="#callablearray"><tt class="docutils literal"><span class="pre">CallableArray</span></tt></a></li>
<li><a class="reference internal" href="#multivoxelfit"><tt class="docutils literal"><span class="pre">MultiVoxelFit</span></tt></a></li>
<li><a class="reference internal" href="#id184"><tt class="docutils literal"><span class="pre">ReconstFit</span></tt></a></li>
<li><a class="reference internal" href="#id185"><tt class="docutils literal"><span class="pre">ReconstModel</span></tt></a></li>
<li><a class="reference internal" href="#as-strided">as_strided</a></li>
<li><a class="reference internal" href="#id186">multi_voxel_fit</a></li>
<li><a class="reference internal" href="#id187">ndindex</a></li>
<li><a class="reference internal" href="#id188"><tt class="docutils literal"><span class="pre">OdfFit</span></tt></a></li>
<li><a class="reference internal" href="#id189"><tt class="docutils literal"><span class="pre">OdfModel</span></tt></a></li>
<li><a class="reference internal" href="#id190"><tt class="docutils literal"><span class="pre">ReconstFit</span></tt></a></li>
<li><a class="reference internal" href="#id191"><tt class="docutils literal"><span class="pre">ReconstModel</span></tt></a></li>
<li><a class="reference internal" href="#id192">gfa</a></li>
<li><a class="reference internal" href="#minmax-normalize">minmax_normalize</a></li>
<li><a class="reference internal" href="#hemisphere"><tt class="docutils literal"><span class="pre">HemiSphere</span></tt></a></li>
<li><a class="reference internal" href="#intemporarydirectory"><tt class="docutils literal"><span class="pre">InTemporaryDirectory</span></tt></a></li>
<li><a class="reference internal" href="#peaksandmetrics"><tt class="docutils literal"><span class="pre">PeaksAndMetrics</span></tt></a></li>
<li><a class="reference internal" href="#peaksandmetricsdirectiongetter"><tt class="docutils literal"><span class="pre">PeaksAndMetricsDirectionGetter</span></tt></a></li>
<li><a class="reference internal" href="#id193"><tt class="docutils literal"><span class="pre">Sphere</span></tt></a></li>
<li><a class="reference internal" href="#repeat"><tt class="docutils literal"><span class="pre">repeat</span></tt></a></li>
<li><a class="reference internal" href="#xrange"><tt class="docutils literal"><span class="pre">xrange</span></tt></a></li>
<li><a class="reference internal" href="#pool">Pool</a></li>
<li><a class="reference internal" href="#cpu-count">cpu_count</a></li>
<li><a class="reference internal" href="#id194">gfa</a></li>
<li><a class="reference internal" href="#id195">local_maxima</a></li>
<li><a class="reference internal" href="#id196">ndindex</a></li>
<li><a class="reference internal" href="#peak-directions">peak_directions</a></li>
<li><a class="reference internal" href="#peak-directions-nl">peak_directions_nl</a></li>
<li><a class="reference internal" href="#id197">peaks_from_model</a></li>
<li><a class="reference internal" href="#id198">remove_similar_vertices</a></li>
<li><a class="reference internal" href="#reshape-peaks-for-visualization">reshape_peaks_for_visualization</a></li>
<li><a class="reference internal" href="#search-descending">search_descending</a></li>
<li><a class="reference internal" href="#sh-to-sf-matrix">sh_to_sf_matrix</a></li>
<li><a class="reference internal" href="#warn">warn</a></li>
<li><a class="reference internal" href="#id199"><tt class="docutils literal"><span class="pre">Cache</span></tt></a></li>
<li><a class="reference internal" href="#exponentialisotropicfit"><tt class="docutils literal"><span class="pre">ExponentialIsotropicFit</span></tt></a></li>
<li><a class="reference internal" href="#exponentialisotropicmodel"><tt class="docutils literal"><span class="pre">ExponentialIsotropicModel</span></tt></a></li>
<li><a class="reference internal" href="#isotropicfit"><tt class="docutils literal"><span class="pre">IsotropicFit</span></tt></a></li>
<li><a class="reference internal" href="#isotropicmodel"><tt class="docutils literal"><span class="pre">IsotropicModel</span></tt></a></li>
<li><a class="reference internal" href="#id200"><tt class="docutils literal"><span class="pre">ReconstFit</span></tt></a></li>
<li><a class="reference internal" href="#id201"><tt class="docutils literal"><span class="pre">ReconstModel</span></tt></a></li>
<li><a class="reference internal" href="#sparsefasciclefit"><tt class="docutils literal"><span class="pre">SparseFascicleFit</span></tt></a></li>
<li><a class="reference internal" href="#sparsefasciclemodel"><tt class="docutils literal"><span class="pre">SparseFascicleModel</span></tt></a></li>
<li><a class="reference internal" href="#id205">auto_attr</a></li>
<li><a class="reference internal" href="#nanmean">nanmean</a></li>
<li><a class="reference internal" href="#optional-package">optional_package</a></li>
<li><a class="reference internal" href="#sfm-design-matrix">sfm_design_matrix</a></li>
<li><a class="reference internal" href="#id210"><tt class="docutils literal"><span class="pre">Cache</span></tt></a></li>
<li><a class="reference internal" href="#csaodfmodel"><tt class="docutils literal"><span class="pre">CsaOdfModel</span></tt></a></li>
<li><a class="reference internal" href="#looseversion"><tt class="docutils literal"><span class="pre">LooseVersion</span></tt></a></li>
<li><a class="reference internal" href="#id212"><tt class="docutils literal"><span class="pre">OdfFit</span></tt></a></li>
<li><a class="reference internal" href="#id213"><tt class="docutils literal"><span class="pre">OdfModel</span></tt></a></li>
<li><a class="reference internal" href="#opdtmodel"><tt class="docutils literal"><span class="pre">OpdtModel</span></tt></a></li>
<li><a class="reference internal" href="#qballbasemodel"><tt class="docutils literal"><span class="pre">QballBaseModel</span></tt></a></li>
<li><a class="reference internal" href="#qballmodel"><tt class="docutils literal"><span class="pre">QballModel</span></tt></a></li>
<li><a class="reference internal" href="#residualbootstrapwrapper"><tt class="docutils literal"><span class="pre">ResidualBootstrapWrapper</span></tt></a></li>
<li><a class="reference internal" href="#id217"><tt class="docutils literal"><span class="pre">SphHarmFit</span></tt></a></li>
<li><a class="reference internal" href="#id218"><tt class="docutils literal"><span class="pre">SphHarmModel</span></tt></a></li>
<li><a class="reference internal" href="#id219"><tt class="docutils literal"><span class="pre">Sphere</span></tt></a></li>
<li><a class="reference internal" href="#all-tensor-evecs">all_tensor_evecs</a></li>
<li><a class="reference internal" href="#id220">auto_attr</a></li>
<li><a class="reference internal" href="#bootstrap-data-array">bootstrap_data_array</a></li>
<li><a class="reference internal" href="#bootstrap-data-voxel">bootstrap_data_voxel</a></li>
<li><a class="reference internal" href="#id224">cart2sphere</a></li>
<li><a class="reference internal" href="#concatenate">concatenate</a></li>
<li><a class="reference internal" href="#diag">diag</a></li>
<li><a class="reference internal" href="#diff">diff</a></li>
<li><a class="reference internal" href="#dot">dot</a></li>
<li><a class="reference internal" href="#empty">empty</a></li>
<li><a class="reference internal" href="#eye">eye</a></li>
<li><a class="reference internal" href="#id225">forward_sdeconv_mat</a></li>
<li><a class="reference internal" href="#gen-dirac">gen_dirac</a></li>
<li><a class="reference internal" href="#hat">hat</a></li>
<li><a class="reference internal" href="#id226">lazy_index</a></li>
<li><a class="reference internal" href="#lcr-matrix">lcr_matrix</a></li>
<li><a class="reference internal" href="#id227">lpn</a></li>
<li><a class="reference internal" href="#normalize-data">normalize_data</a></li>
<li><a class="reference internal" href="#order-from-ncoef">order_from_ncoef</a></li>
<li><a class="reference internal" href="#pinv">pinv</a></li>
<li><a class="reference internal" href="#randint">randint</a></li>
<li><a class="reference internal" href="#id230">real_sph_harm</a></li>
<li><a class="reference internal" href="#id231">real_sym_sh_basis</a></li>
<li><a class="reference internal" href="#real-sym-sh-mrtrix">real_sym_sh_mrtrix</a></li>
<li><a class="reference internal" href="#sf-to-sh">sf_to_sh</a></li>
<li><a class="reference internal" href="#id234">sh_to_rh</a></li>
<li><a class="reference internal" href="#sh-to-sf">sh_to_sf</a></li>
<li><a class="reference internal" href="#id236">sh_to_sf_matrix</a></li>
<li><a class="reference internal" href="#id237">single_tensor</a></li>
<li><a class="reference internal" href="#smooth-pinv">smooth_pinv</a></li>
<li><a class="reference internal" href="#id240">sph_harm_ind_list</a></li>
<li><a class="reference internal" href="#spherical-harmonics">spherical_harmonics</a></li>
<li><a class="reference internal" href="#svd">svd</a></li>
<li><a class="reference internal" href="#unique">unique</a></li>
<li><a class="reference internal" href="#id241"><tt class="docutils literal"><span class="pre">Cache</span></tt></a></li>
<li><a class="reference internal" href="#shorefit"><tt class="docutils literal"><span class="pre">ShoreFit</span></tt></a></li>
<li><a class="reference internal" href="#shoremodel"><tt class="docutils literal"><span class="pre">ShoreModel</span></tt></a></li>
<li><a class="reference internal" href="#id263">cart2sphere</a></li>
<li><a class="reference internal" href="#create-rspace">create_rspace</a></li>
<li><a class="reference internal" href="#factorial">factorial</a></li>
<li><a class="reference internal" href="#genlaguerre">genlaguerre</a></li>
<li><a class="reference internal" href="#l-shore">l_shore</a></li>
<li><a class="reference internal" href="#id264">multi_voxel_fit</a></li>
<li><a class="reference internal" href="#n-shore">n_shore</a></li>
<li><a class="reference internal" href="#id265">optional_package</a></li>
<li><a class="reference internal" href="#id266">real_sph_harm</a></li>
<li><a class="reference internal" href="#shore-indices">shore_indices</a></li>
<li><a class="reference internal" href="#shore-matrix">shore_matrix</a></li>
<li><a class="reference internal" href="#shore-matrix-odf">shore_matrix_odf</a></li>
<li><a class="reference internal" href="#shore-matrix-pdf">shore_matrix_pdf</a></li>
<li><a class="reference internal" href="#shore-order">shore_order</a></li>
<li><a class="reference internal" href="#id273">warn</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/reference/dipy.reconst.txt"
           rel="nofollow">Show Source</a></li>
  </ul>

<div id="searchbox-ml" style="display: none">
  <h3>Search mailing list archive</h3>
  <script type="text/javascript">
    function mlsearch(curobj)
    {
    curobj.q.value="site:mail.scipy.org/pipermail/nipy-devel/ "+curobj.userquery.value
    }
  </script>
  <form action="http://www.google.com/search" method="get" onSubmit="mlsearch(this)">
    <input name="userquery" size="13" type="text" /> <input type="submit" value="Go" />
    <input name="q" type="hidden" />
  </form>
</div>
  
<div id="searchbox-site" style="display: none">
  <h3>Search this site</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" size="13" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    </p>
</div>
<script type="text/javascript">$('#searchbox-ml').show(0);</script>
<script type="text/javascript">$('#searchbox-site').show(0);</script>


        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-dipy.reconst">
<span id="reconst"></span><h1><tt class="xref py py-mod docutils literal"><span class="pre">reconst</span></tt><a class="headerlink" href="#module-dipy.reconst" title="Permalink to this headline">¶</a></h1>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.bench" title="dipy.reconst.bench"><tt class="xref py py-obj docutils literal"><span class="pre">bench</span></tt></a></td>
<td>Run benchmarks for module using nose.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.test" title="dipy.reconst.test"><tt class="xref py py-obj docutils literal"><span class="pre">test</span></tt></a></td>
<td>Run tests for module using nose.</td>
</tr>
</tbody>
</table>
<div class="section" id="module-dipy.reconst.base">
<span id="module-reconst-base"></span><h2>Module: <tt class="xref py py-mod docutils literal"><span class="pre">reconst.base</span></tt><a class="headerlink" href="#module-dipy.reconst.base" title="Permalink to this headline">¶</a></h2>
<p>Base-classes for reconstruction models and reconstruction fits.</p>
<p>All the models in the reconst module follow the same template: a Model object
is used to represent the abstract properties of the model, that are independent
of the specifics of the data . These properties are reused whenver fitting a
particular set of data (different voxels, for example).</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.base.ReconstFit" title="dipy.reconst.base.ReconstFit"><tt class="xref py py-obj docutils literal"><span class="pre">ReconstFit</span></tt></a>(model,&nbsp;data)</td>
<td>Abstract class which holds the fit result of ReconstModel</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><tt class="xref py py-obj docutils literal"><span class="pre">ReconstModel</span></tt></a>(gtab)</td>
<td>Abstract class for signal reconstruction models</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.reconst.benchmarks">
<span id="module-reconst-benchmarks"></span><h2>Module: <tt class="xref py py-mod docutils literal"><span class="pre">reconst.benchmarks</span></tt><a class="headerlink" href="#module-dipy.reconst.benchmarks" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
</div>
<div class="section" id="module-dipy.reconst.benchmarks.bench_bounding_box">
<span id="module-reconst-benchmarks-bench-bounding-box"></span><h2>Module: <tt class="xref py py-mod docutils literal"><span class="pre">reconst.benchmarks.bench_bounding_box</span></tt><a class="headerlink" href="#module-dipy.reconst.benchmarks.bench_bounding_box" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_bounding_box.bench_bounding_box" title="dipy.reconst.benchmarks.bench_bounding_box.bench_bounding_box"><tt class="xref py py-obj docutils literal"><span class="pre">bench_bounding_box</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_bounding_box.bounding_box" title="dipy.reconst.benchmarks.bench_bounding_box.bounding_box"><tt class="xref py py-obj docutils literal"><span class="pre">bounding_box</span></tt></a>(vol)</td>
<td>Compute the bounding box of nonzero intensity voxels in the volume.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_bounding_box.measure" title="dipy.reconst.benchmarks.bench_bounding_box.measure"><tt class="xref py py-obj docutils literal"><span class="pre">measure</span></tt></a>(code_str[,&nbsp;times,&nbsp;label])</td>
<td>Return elapsed time for executing code in the namespace of the caller.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.reconst.benchmarks.bench_csd">
<span id="module-reconst-benchmarks-bench-csd"></span><h2>Module: <tt class="xref py py-mod docutils literal"><span class="pre">reconst.benchmarks.bench_csd</span></tt><a class="headerlink" href="#module-dipy.reconst.benchmarks.bench_csd" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_csd.ConstrainedSphericalDeconvModel" title="dipy.reconst.benchmarks.bench_csd.ConstrainedSphericalDeconvModel"><tt class="xref py py-obj docutils literal"><span class="pre">ConstrainedSphericalDeconvModel</span></tt></a>(gtab,&nbsp;response)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_csd.GradientTable" title="dipy.reconst.benchmarks.bench_csd.GradientTable"><tt class="xref py py-obj docutils literal"><span class="pre">GradientTable</span></tt></a>(gradients[,&nbsp;big_delta,&nbsp;...])</td>
<td>Diffusion gradient information</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_csd.bench_csdeconv" title="dipy.reconst.benchmarks.bench_csd.bench_csdeconv"><tt class="xref py py-obj docutils literal"><span class="pre">bench_csdeconv</span></tt></a>([center,&nbsp;width])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_csd.num_grad" title="dipy.reconst.benchmarks.bench_csd.num_grad"><tt class="xref py py-obj docutils literal"><span class="pre">num_grad</span></tt></a>(gtab)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_csd.read_stanford_labels" title="dipy.reconst.benchmarks.bench_csd.read_stanford_labels"><tt class="xref py py-obj docutils literal"><span class="pre">read_stanford_labels</span></tt></a>()</td>
<td>Read stanford hardi data and label map</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.reconst.benchmarks.bench_peaks">
<span id="module-reconst-benchmarks-bench-peaks"></span><h2>Module: <tt class="xref py py-mod docutils literal"><span class="pre">reconst.benchmarks.bench_peaks</span></tt><a class="headerlink" href="#module-dipy.reconst.benchmarks.bench_peaks" title="Permalink to this headline">¶</a></h2>
<p>Benchmarks for peak finding</p>
<p>Run all benchmarks with:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">dipy.reconst</span> <span class="kn">as</span> <span class="nn">dire</span>
<span class="n">dire</span><span class="o">.</span><span class="n">bench</span><span class="p">()</span>
</pre></div>
</div>
<p>If you have doctests enabled by default in nose (with a noserc file or
environment variable), and you have a numpy version &lt;= 1.6.1, this will also run
the doctests, let&#8217;s hope they pass.</p>
<p>Run this benchmark with:</p>
<blockquote>
<div>nosetests -s &#8211;match &#8216;(?:^|[b_.//-])[Bb]ench&#8217; /path/to/bench_peaks.py</div></blockquote>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_peaks.bench_local_maxima" title="dipy.reconst.benchmarks.bench_peaks.bench_local_maxima"><tt class="xref py py-obj docutils literal"><span class="pre">bench_local_maxima</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_peaks.get_sphere" title="dipy.reconst.benchmarks.bench_peaks.get_sphere"><tt class="xref py py-obj docutils literal"><span class="pre">get_sphere</span></tt></a>([name])</td>
<td>provide triangulated spheres</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_peaks.local_maxima" title="dipy.reconst.benchmarks.bench_peaks.local_maxima"><tt class="xref py py-obj docutils literal"><span class="pre">local_maxima</span></tt></a>(odf,&nbsp;edges)</td>
<td>Finds the local maxima of a function evaluated on a discrete set of points.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_peaks.measure" title="dipy.reconst.benchmarks.bench_peaks.measure"><tt class="xref py py-obj docutils literal"><span class="pre">measure</span></tt></a>(code_str[,&nbsp;times,&nbsp;label])</td>
<td>Return elapsed time for executing code in the namespace of the caller.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_peaks.unique_edges" title="dipy.reconst.benchmarks.bench_peaks.unique_edges"><tt class="xref py py-obj docutils literal"><span class="pre">unique_edges</span></tt></a>(faces[,&nbsp;return_mapping])</td>
<td>Extract all unique edges from given triangular faces.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.reconst.benchmarks.bench_squash">
<span id="module-reconst-benchmarks-bench-squash"></span><h2>Module: <tt class="xref py py-mod docutils literal"><span class="pre">reconst.benchmarks.bench_squash</span></tt><a class="headerlink" href="#module-dipy.reconst.benchmarks.bench_squash" title="Permalink to this headline">¶</a></h2>
<p>Benchmarks for fast squashing</p>
<p>Run all benchmarks with:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">dipy.reconst</span> <span class="kn">as</span> <span class="nn">dire</span>
<span class="n">dire</span><span class="o">.</span><span class="n">bench</span><span class="p">()</span>
</pre></div>
</div>
<p>If you have doctests enabled by default in nose (with a noserc file or
environment variable), and you have a numpy version &lt;= 1.6.1, this will also run
the doctests, let&#8217;s hope they pass.</p>
<p>Run this benchmark with:</p>
<blockquote>
<div>nosetests -s &#8211;match &#8216;(?:^|[b_.//-])[Bb]ench&#8217; /path/to/bench_squash.py</div></blockquote>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_squash.bench_quick_squash" title="dipy.reconst.benchmarks.bench_squash.bench_quick_squash"><tt class="xref py py-obj docutils literal"><span class="pre">bench_quick_squash</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_squash.measure" title="dipy.reconst.benchmarks.bench_squash.measure"><tt class="xref py py-obj docutils literal"><span class="pre">measure</span></tt></a>(code_str[,&nbsp;times,&nbsp;label])</td>
<td>Return elapsed time for executing code in the namespace of the caller.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_squash.ndindex" title="dipy.reconst.benchmarks.bench_squash.ndindex"><tt class="xref py py-obj docutils literal"><span class="pre">ndindex</span></tt></a>(shape)</td>
<td>An N-dimensional iterator object to index arrays.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_squash.old_squash" title="dipy.reconst.benchmarks.bench_squash.old_squash"><tt class="xref py py-obj docutils literal"><span class="pre">old_squash</span></tt></a>(arr[,&nbsp;mask,&nbsp;fill])</td>
<td>Try and make a standard array from an object array</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_squash.quick_squash" title="dipy.reconst.benchmarks.bench_squash.quick_squash"><tt class="xref py py-obj docutils literal"><span class="pre">quick_squash</span></tt></a></td>
<td>Try and make a standard array from an object array</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_squash.reduce" title="dipy.reconst.benchmarks.bench_squash.reduce"><tt class="xref py py-obj docutils literal"><span class="pre">reduce</span></tt></a>((function,&nbsp;sequence[,&nbsp;initial])&nbsp;-&gt;&nbsp;value)</td>
<td>Apply a function of two arguments cumulatively to the items of a sequence, from left to right, so as to reduce the sequence to a single value.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.reconst.benchmarks.bench_vec_val_sum">
<span id="module-reconst-benchmarks-bench-vec-val-sum"></span><h2>Module: <tt class="xref py py-mod docutils literal"><span class="pre">reconst.benchmarks.bench_vec_val_sum</span></tt><a class="headerlink" href="#module-dipy.reconst.benchmarks.bench_vec_val_sum" title="Permalink to this headline">¶</a></h2>
<p>Benchmarks for vec / val summation routine</p>
<p>Run benchmarks with:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">dipy.reconst</span> <span class="kn">as</span> <span class="nn">dire</span>
<span class="n">dire</span><span class="o">.</span><span class="n">bench</span><span class="p">()</span>
</pre></div>
</div>
<p>If you have doctests enabled by default in nose (with a noserc file or
environment variable), and you have a numpy version &lt;= 1.6.1, this will also run
the doctests, let&#8217;s hope they pass.</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_vec_val_sum.bench_vec_val_vect" title="dipy.reconst.benchmarks.bench_vec_val_sum.bench_vec_val_vect"><tt class="xref py py-obj docutils literal"><span class="pre">bench_vec_val_vect</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_vec_val_sum.measure" title="dipy.reconst.benchmarks.bench_vec_val_sum.measure"><tt class="xref py py-obj docutils literal"><span class="pre">measure</span></tt></a>(code_str[,&nbsp;times,&nbsp;label])</td>
<td>Return elapsed time for executing code in the namespace of the caller.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_vec_val_sum.randn" title="dipy.reconst.benchmarks.bench_vec_val_sum.randn"><tt class="xref py py-obj docutils literal"><span class="pre">randn</span></tt></a>(d0,&nbsp;d1,&nbsp;...,&nbsp;dn)</td>
<td>Return a sample (or samples) from the &#8220;standard normal&#8221; distribution.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_vec_val_sum.vec_val_vect" title="dipy.reconst.benchmarks.bench_vec_val_sum.vec_val_vect"><tt class="xref py py-obj docutils literal"><span class="pre">vec_val_vect</span></tt></a></td>
<td>Vectorize <cite>vecs</cite>.diag(<cite>vals</cite>).`vecs`.T for last 2 dimensions of <cite>vecs</cite></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_vec_val_sum.with_einsum" title="dipy.reconst.benchmarks.bench_vec_val_sum.with_einsum"><tt class="xref py py-obj docutils literal"><span class="pre">with_einsum</span></tt></a>(f)</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.reconst.cache">
<span id="module-reconst-cache"></span><h2>Module: <tt class="xref py py-mod docutils literal"><span class="pre">reconst.cache</span></tt><a class="headerlink" href="#module-dipy.reconst.cache" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.cache.Cache" title="dipy.reconst.cache.Cache"><tt class="xref py py-obj docutils literal"><span class="pre">Cache</span></tt></a></td>
<td>Cache values based on a key object (such as a sphere or gradient table).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.cache.auto_attr" title="dipy.reconst.cache.auto_attr"><tt class="xref py py-obj docutils literal"><span class="pre">auto_attr</span></tt></a>(func)</td>
<td>Decorator to create OneTimeProperty attributes.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.reconst.cross_validation">
<span id="module-reconst-cross-validation"></span><h2>Module: <tt class="xref py py-mod docutils literal"><span class="pre">reconst.cross_validation</span></tt><a class="headerlink" href="#module-dipy.reconst.cross_validation" title="Permalink to this headline">¶</a></h2>
<p>Cross-validation analysis of diffusion models</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.cross_validation.range" title="dipy.reconst.cross_validation.range"><tt class="xref py py-obj docutils literal"><span class="pre">range</span></tt></a></td>
<td>xrange(stop) -&gt; xrange object</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.cross_validation.coeff_of_determination" title="dipy.reconst.cross_validation.coeff_of_determination"><tt class="xref py py-obj docutils literal"><span class="pre">coeff_of_determination</span></tt></a>(data,&nbsp;model[,&nbsp;axis])</td>
<td>Calculate the coefficient of determination for a model prediction, relative     to data.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.cross_validation.kfold_xval" title="dipy.reconst.cross_validation.kfold_xval"><tt class="xref py py-obj docutils literal"><span class="pre">kfold_xval</span></tt></a>(model,&nbsp;data,&nbsp;folds,&nbsp;*model_args,&nbsp;...)</td>
<td>Perform k-fold cross-validation to generate out-of-sample predictions for each measurement.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.reconst.csdeconv">
<span id="module-reconst-csdeconv"></span><h2>Module: <tt class="xref py py-mod docutils literal"><span class="pre">reconst.csdeconv</span></tt><a class="headerlink" href="#module-dipy.reconst.csdeconv" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.csdeconv.AxSymShResponse" title="dipy.reconst.csdeconv.AxSymShResponse"><tt class="xref py py-obj docutils literal"><span class="pre">AxSymShResponse</span></tt></a>(S0,&nbsp;dwi_response[,&nbsp;bvalue])</td>
<td>A simple wrapper for response functions represented using only axially symmetric, even spherical harmonic functions (ie, m == 0 and n even).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.csdeconv.ConstrainedSDTModel" title="dipy.reconst.csdeconv.ConstrainedSDTModel"><tt class="xref py py-obj docutils literal"><span class="pre">ConstrainedSDTModel</span></tt></a>(gtab,&nbsp;ratio[,&nbsp;...])</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel" title="dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel"><tt class="xref py py-obj docutils literal"><span class="pre">ConstrainedSphericalDeconvModel</span></tt></a>(gtab,&nbsp;response)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.csdeconv.SphHarmFit" title="dipy.reconst.csdeconv.SphHarmFit"><tt class="xref py py-obj docutils literal"><span class="pre">SphHarmFit</span></tt></a>(model,&nbsp;shm_coef,&nbsp;mask)</td>
<td>Diffusion data fit to a spherical harmonic model</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.csdeconv.SphHarmModel" title="dipy.reconst.csdeconv.SphHarmModel"><tt class="xref py py-obj docutils literal"><span class="pre">SphHarmModel</span></tt></a>(gtab)</td>
<td>To be subclassed by all models that return a SphHarmFit when fit.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.csdeconv.TensorModel" title="dipy.reconst.csdeconv.TensorModel"><tt class="xref py py-obj docutils literal"><span class="pre">TensorModel</span></tt></a>(gtab[,&nbsp;fit_method])</td>
<td>Diffusion Tensor</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.csdeconv.range" title="dipy.reconst.csdeconv.range"><tt class="xref py py-obj docutils literal"><span class="pre">range</span></tt></a></td>
<td>xrange(stop) -&gt; xrange object</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.csdeconv.auto_response" title="dipy.reconst.csdeconv.auto_response"><tt class="xref py py-obj docutils literal"><span class="pre">auto_response</span></tt></a>(gtab,&nbsp;data[,&nbsp;roi_center,&nbsp;...])</td>
<td>Automatic estimation of response function using FA.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.csdeconv.cart2sphere" title="dipy.reconst.csdeconv.cart2sphere"><tt class="xref py py-obj docutils literal"><span class="pre">cart2sphere</span></tt></a>(x,&nbsp;y,&nbsp;z)</td>
<td>Return angles for Cartesian 3D coordinates <cite>x</cite>, <cite>y</cite>, and <cite>z</cite></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.csdeconv.csdeconv" title="dipy.reconst.csdeconv.csdeconv"><tt class="xref py py-obj docutils literal"><span class="pre">csdeconv</span></tt></a>(dwsignal,&nbsp;X,&nbsp;B_reg[,&nbsp;tau,&nbsp;...])</td>
<td>Constrained-regularized spherical deconvolution (CSD) [R32]</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.csdeconv.estimate_response" title="dipy.reconst.csdeconv.estimate_response"><tt class="xref py py-obj docutils literal"><span class="pre">estimate_response</span></tt></a>(gtab,&nbsp;evals,&nbsp;S0)</td>
<td>Estimate single fiber response function</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.csdeconv.fa_trace_to_lambdas" title="dipy.reconst.csdeconv.fa_trace_to_lambdas"><tt class="xref py py-obj docutils literal"><span class="pre">fa_trace_to_lambdas</span></tt></a>([fa,&nbsp;trace])</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.csdeconv.forward_sdeconv_mat" title="dipy.reconst.csdeconv.forward_sdeconv_mat"><tt class="xref py py-obj docutils literal"><span class="pre">forward_sdeconv_mat</span></tt></a>(r_rh,&nbsp;n)</td>
<td>Build forward spherical deconvolution matrix</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.csdeconv.forward_sdt_deconv_mat" title="dipy.reconst.csdeconv.forward_sdt_deconv_mat"><tt class="xref py py-obj docutils literal"><span class="pre">forward_sdt_deconv_mat</span></tt></a>(ratio,&nbsp;n[,&nbsp;r2_term])</td>
<td>Build forward sharpening deconvolution transform (SDT) matrix</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.csdeconv.fractional_anisotropy" title="dipy.reconst.csdeconv.fractional_anisotropy"><tt class="xref py py-obj docutils literal"><span class="pre">fractional_anisotropy</span></tt></a>(evals[,&nbsp;axis])</td>
<td>Fractional anisotropy (FA) of a diffusion tensor.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.csdeconv.get_sphere" title="dipy.reconst.csdeconv.get_sphere"><tt class="xref py py-obj docutils literal"><span class="pre">get_sphere</span></tt></a>([name])</td>
<td>provide triangulated spheres</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.csdeconv.lazy_index" title="dipy.reconst.csdeconv.lazy_index"><tt class="xref py py-obj docutils literal"><span class="pre">lazy_index</span></tt></a>(index)</td>
<td>Produces a lazy index</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.csdeconv.lpn" title="dipy.reconst.csdeconv.lpn"><tt class="xref py py-obj docutils literal"><span class="pre">lpn</span></tt></a>(n,&nbsp;z)</td>
<td>Compute sequence of Legendre functions of the first kind (polynomials), Pn(z) and derivatives for all degrees from 0 to n (inclusive).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.csdeconv.multi_voxel_fit" title="dipy.reconst.csdeconv.multi_voxel_fit"><tt class="xref py py-obj docutils literal"><span class="pre">multi_voxel_fit</span></tt></a>(single_voxel_fit)</td>
<td>Method decorator to turn a single voxel model fit</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.csdeconv.ndindex" title="dipy.reconst.csdeconv.ndindex"><tt class="xref py py-obj docutils literal"><span class="pre">ndindex</span></tt></a>(shape)</td>
<td>An N-dimensional iterator object to index arrays.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.csdeconv.odf_deconv" title="dipy.reconst.csdeconv.odf_deconv"><tt class="xref py py-obj docutils literal"><span class="pre">odf_deconv</span></tt></a>(odf_sh,&nbsp;R,&nbsp;B_reg[,&nbsp;<a href="#id274"><span class="problematic" id="id275">lambda_</span></a>,&nbsp;tau,&nbsp;...])</td>
<td>ODF constrained-regularized spherical deconvolution using the Sharpening Deconvolution Transform (SDT) [R34], [R35].</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.csdeconv.odf_sh_to_sharp" title="dipy.reconst.csdeconv.odf_sh_to_sharp"><tt class="xref py py-obj docutils literal"><span class="pre">odf_sh_to_sharp</span></tt></a>(odfs_sh,&nbsp;sphere[,&nbsp;basis,&nbsp;...])</td>
<td>Sharpen odfs using the spherical deconvolution transform [R37]</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.csdeconv.peaks_from_model" title="dipy.reconst.csdeconv.peaks_from_model"><tt class="xref py py-obj docutils literal"><span class="pre">peaks_from_model</span></tt></a>(model,&nbsp;data,&nbsp;sphere,&nbsp;...[,&nbsp;...])</td>
<td>Fits the model to data and computes peaks and metrics</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.csdeconv.quad" title="dipy.reconst.csdeconv.quad"><tt class="xref py py-obj docutils literal"><span class="pre">quad</span></tt></a>(func,&nbsp;a,&nbsp;b[,&nbsp;args,&nbsp;full_output,&nbsp;...])</td>
<td>Compute a definite integral.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.csdeconv.real_sph_harm" title="dipy.reconst.csdeconv.real_sph_harm"><tt class="xref py py-obj docutils literal"><span class="pre">real_sph_harm</span></tt></a>(m,&nbsp;n,&nbsp;theta,&nbsp;phi)</td>
<td>Compute real spherical harmonics.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.csdeconv.real_sym_sh_basis" title="dipy.reconst.csdeconv.real_sym_sh_basis"><tt class="xref py py-obj docutils literal"><span class="pre">real_sym_sh_basis</span></tt></a>(sh_order,&nbsp;theta,&nbsp;phi)</td>
<td>Samples a real symmetric spherical harmonic basis at point on the sphere</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.csdeconv.recursive_response" title="dipy.reconst.csdeconv.recursive_response"><tt class="xref py py-obj docutils literal"><span class="pre">recursive_response</span></tt></a>(gtab,&nbsp;data[,&nbsp;mask,&nbsp;...])</td>
<td>Recursive calibration of response function using peak threshold</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.csdeconv.sh_to_rh" title="dipy.reconst.csdeconv.sh_to_rh"><tt class="xref py py-obj docutils literal"><span class="pre">sh_to_rh</span></tt></a>(r_sh,&nbsp;m,&nbsp;n)</td>
<td>Spherical harmonics (SH) to rotational harmonics (RH)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.csdeconv.single_tensor" title="dipy.reconst.csdeconv.single_tensor"><tt class="xref py py-obj docutils literal"><span class="pre">single_tensor</span></tt></a>(gtab[,&nbsp;S0,&nbsp;evals,&nbsp;evecs,&nbsp;snr])</td>
<td>Simulated Q-space signal with a single tensor.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.csdeconv.sph_harm_ind_list" title="dipy.reconst.csdeconv.sph_harm_ind_list"><tt class="xref py py-obj docutils literal"><span class="pre">sph_harm_ind_list</span></tt></a>(sh_order)</td>
<td>Returns the degree (n) and order (m) of all the symmetric spherical harmonics of degree less then or equal to <cite>sh_order</cite>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.csdeconv.vec2vec_rotmat" title="dipy.reconst.csdeconv.vec2vec_rotmat"><tt class="xref py py-obj docutils literal"><span class="pre">vec2vec_rotmat</span></tt></a>(u,&nbsp;v)</td>
<td>rotation matrix from 2 unit vectors</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.reconst.dsi">
<span id="module-reconst-dsi"></span><h2>Module: <tt class="xref py py-mod docutils literal"><span class="pre">reconst.dsi</span></tt><a class="headerlink" href="#module-dipy.reconst.dsi" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dsi.Cache" title="dipy.reconst.dsi.Cache"><tt class="xref py py-obj docutils literal"><span class="pre">Cache</span></tt></a></td>
<td>Cache values based on a key object (such as a sphere or gradient table).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvFit" title="dipy.reconst.dsi.DiffusionSpectrumDeconvFit"><tt class="xref py py-obj docutils literal"><span class="pre">DiffusionSpectrumDeconvFit</span></tt></a>(model,&nbsp;data)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvModel" title="dipy.reconst.dsi.DiffusionSpectrumDeconvModel"><tt class="xref py py-obj docutils literal"><span class="pre">DiffusionSpectrumDeconvModel</span></tt></a>(gtab[,&nbsp;...])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumFit" title="dipy.reconst.dsi.DiffusionSpectrumFit"><tt class="xref py py-obj docutils literal"><span class="pre">DiffusionSpectrumFit</span></tt></a>(model,&nbsp;data)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumModel" title="dipy.reconst.dsi.DiffusionSpectrumModel"><tt class="xref py py-obj docutils literal"><span class="pre">DiffusionSpectrumModel</span></tt></a>(gtab[,&nbsp;qgrid_size,&nbsp;...])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dsi.OdfFit" title="dipy.reconst.dsi.OdfFit"><tt class="xref py py-obj docutils literal"><span class="pre">OdfFit</span></tt></a>(model,&nbsp;data)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dsi.OdfModel" title="dipy.reconst.dsi.OdfModel"><tt class="xref py py-obj docutils literal"><span class="pre">OdfModel</span></tt></a>(gtab)</td>
<td>An abstract class to be sub-classed by specific odf models</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dsi.LR_deconv" title="dipy.reconst.dsi.LR_deconv"><tt class="xref py py-obj docutils literal"><span class="pre">LR_deconv</span></tt></a>(prop,&nbsp;psf[,&nbsp;numit,&nbsp;acc_factor])</td>
<td>Perform Lucy-Richardson deconvolution algorithm on a 3D array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dsi.create_qspace" title="dipy.reconst.dsi.create_qspace"><tt class="xref py py-obj docutils literal"><span class="pre">create_qspace</span></tt></a>(gtab,&nbsp;origin)</td>
<td>create the 3D grid which holds the signal values (q-space)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dsi.create_qtable" title="dipy.reconst.dsi.create_qtable"><tt class="xref py py-obj docutils literal"><span class="pre">create_qtable</span></tt></a>(gtab)</td>
<td>create a normalized version of gradients</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dsi.fftn" title="dipy.reconst.dsi.fftn"><tt class="xref py py-obj docutils literal"><span class="pre">fftn</span></tt></a>(x[,&nbsp;shape,&nbsp;axes,&nbsp;overwrite_x])</td>
<td>Return multidimensional discrete Fourier transform.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dsi.fftshift" title="dipy.reconst.dsi.fftshift"><tt class="xref py py-obj docutils literal"><span class="pre">fftshift</span></tt></a>(x[,&nbsp;axes])</td>
<td>Shift the zero-frequency component to the center of the spectrum.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dsi.gen_PSF" title="dipy.reconst.dsi.gen_PSF"><tt class="xref py py-obj docutils literal"><span class="pre">gen_PSF</span></tt></a>(qgrid_sampling,&nbsp;siz_x,&nbsp;siz_y,&nbsp;siz_z)</td>
<td>Generate a PSF for DSI Deconvolution by taking the ifft of the binary q-space sampling mask and truncating it to keep only the center.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dsi.gfa" title="dipy.reconst.dsi.gfa"><tt class="xref py py-obj docutils literal"><span class="pre">gfa</span></tt></a>(samples)</td>
<td>The general fractional anisotropy of a function evaluated</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dsi.half_to_full_qspace" title="dipy.reconst.dsi.half_to_full_qspace"><tt class="xref py py-obj docutils literal"><span class="pre">half_to_full_qspace</span></tt></a>(data,&nbsp;gtab)</td>
<td>Half to full Cartesian grid mapping</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dsi.hanning_filter" title="dipy.reconst.dsi.hanning_filter"><tt class="xref py py-obj docutils literal"><span class="pre">hanning_filter</span></tt></a>(gtab,&nbsp;filter_width)</td>
<td>create a hanning window</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dsi.ifftshift" title="dipy.reconst.dsi.ifftshift"><tt class="xref py py-obj docutils literal"><span class="pre">ifftshift</span></tt></a>(x[,&nbsp;axes])</td>
<td>The inverse of fftshift.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dsi.local_maxima" title="dipy.reconst.dsi.local_maxima"><tt class="xref py py-obj docutils literal"><span class="pre">local_maxima</span></tt></a>(odf,&nbsp;edges)</td>
<td>Finds the local maxima of a function evaluated on a discrete set of points.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dsi.map_coordinates" title="dipy.reconst.dsi.map_coordinates"><tt class="xref py py-obj docutils literal"><span class="pre">map_coordinates</span></tt></a>(input,&nbsp;coordinates[,&nbsp;...])</td>
<td>Map the input array to new coordinates by interpolation.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dsi.multi_voxel_fit" title="dipy.reconst.dsi.multi_voxel_fit"><tt class="xref py py-obj docutils literal"><span class="pre">multi_voxel_fit</span></tt></a>(single_voxel_fit)</td>
<td>Method decorator to turn a single voxel model fit</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dsi.pdf_interp_coords" title="dipy.reconst.dsi.pdf_interp_coords"><tt class="xref py py-obj docutils literal"><span class="pre">pdf_interp_coords</span></tt></a>(sphere,&nbsp;rradius,&nbsp;origin)</td>
<td>Precompute coordinates for ODF calculation from the PDF</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dsi.pdf_odf" title="dipy.reconst.dsi.pdf_odf"><tt class="xref py py-obj docutils literal"><span class="pre">pdf_odf</span></tt></a>(Pr,&nbsp;rradius,&nbsp;interp_coords)</td>
<td>Calculates the real ODF from the diffusion propagator(PDF) Pr</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dsi.project_hemisph_bvecs" title="dipy.reconst.dsi.project_hemisph_bvecs"><tt class="xref py py-obj docutils literal"><span class="pre">project_hemisph_bvecs</span></tt></a>(gtab)</td>
<td>Project any near identical bvecs to the other hemisphere</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dsi.remove_similar_vertices" title="dipy.reconst.dsi.remove_similar_vertices"><tt class="xref py py-obj docutils literal"><span class="pre">remove_similar_vertices</span></tt></a>(vertices,&nbsp;theta)</td>
<td>Returns vertices that are separated by at least theta degrees from all other vertices.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dsi.threshold_propagator" title="dipy.reconst.dsi.threshold_propagator"><tt class="xref py py-obj docutils literal"><span class="pre">threshold_propagator</span></tt></a>(P[,&nbsp;estimated_snr])</td>
<td>Applies hard threshold on the propagator to remove background noise for the deconvolution.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.reconst.dti">
<span id="module-reconst-dti"></span><h2>Module: <tt class="xref py py-mod docutils literal"><span class="pre">reconst.dti</span></tt><a class="headerlink" href="#module-dipy.reconst.dti" title="Permalink to this headline">¶</a></h2>
<p>Classes and functions for fitting tensors</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.ReconstFit" title="dipy.reconst.dti.ReconstFit"><tt class="xref py py-obj docutils literal"><span class="pre">ReconstFit</span></tt></a>(model,&nbsp;data)</td>
<td>Abstract class which holds the fit result of ReconstModel</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.ReconstModel" title="dipy.reconst.dti.ReconstModel"><tt class="xref py py-obj docutils literal"><span class="pre">ReconstModel</span></tt></a>(gtab)</td>
<td>Abstract class for signal reconstruction models</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.Sphere" title="dipy.reconst.dti.Sphere"><tt class="xref py py-obj docutils literal"><span class="pre">Sphere</span></tt></a>([x,&nbsp;y,&nbsp;z,&nbsp;theta,&nbsp;phi,&nbsp;xyz,&nbsp;faces,&nbsp;edges])</td>
<td>Points on the unit sphere.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.TensorFit" title="dipy.reconst.dti.TensorFit"><tt class="xref py py-obj docutils literal"><span class="pre">TensorFit</span></tt></a>(model,&nbsp;model_params)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.TensorModel" title="dipy.reconst.dti.TensorModel"><tt class="xref py py-obj docutils literal"><span class="pre">TensorModel</span></tt></a>(gtab[,&nbsp;fit_method])</td>
<td>Diffusion Tensor</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.range" title="dipy.reconst.dti.range"><tt class="xref py py-obj docutils literal"><span class="pre">range</span></tt></a></td>
<td>xrange(stop) -&gt; xrange object</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.apparent_diffusion_coef" title="dipy.reconst.dti.apparent_diffusion_coef"><tt class="xref py py-obj docutils literal"><span class="pre">apparent_diffusion_coef</span></tt></a>(q_form,&nbsp;sphere)</td>
<td>Calculate the apparent diffusion coefficient (ADC) in each direction of a sphere.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.auto_attr" title="dipy.reconst.dti.auto_attr"><tt class="xref py py-obj docutils literal"><span class="pre">auto_attr</span></tt></a>(func)</td>
<td>Decorator to create OneTimeProperty attributes.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.axial_diffusivity" title="dipy.reconst.dti.axial_diffusivity"><tt class="xref py py-obj docutils literal"><span class="pre">axial_diffusivity</span></tt></a>(evals[,&nbsp;axis])</td>
<td>Axial Diffusivity (AD) of a diffusion tensor.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.color_fa" title="dipy.reconst.dti.color_fa"><tt class="xref py py-obj docutils literal"><span class="pre">color_fa</span></tt></a>(fa,&nbsp;evecs)</td>
<td>Color fractional anisotropy of diffusion tensor</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.decompose_tensor" title="dipy.reconst.dti.decompose_tensor"><tt class="xref py py-obj docutils literal"><span class="pre">decompose_tensor</span></tt></a>(tensor[,&nbsp;min_diffusivity])</td>
<td>Returns eigenvalues and eigenvectors given a diffusion tensor</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.design_matrix" title="dipy.reconst.dti.design_matrix"><tt class="xref py py-obj docutils literal"><span class="pre">design_matrix</span></tt></a>(gtab[,&nbsp;dtype])</td>
<td>Constructs design matrix for DTI weighted least squares or least squares fitting.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.determinant" title="dipy.reconst.dti.determinant"><tt class="xref py py-obj docutils literal"><span class="pre">determinant</span></tt></a>(q_form)</td>
<td>The determinant of a tensor, given in quadratic form</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.deviatoric" title="dipy.reconst.dti.deviatoric"><tt class="xref py py-obj docutils literal"><span class="pre">deviatoric</span></tt></a>(q_form)</td>
<td>Calculate the deviatoric (anisotropic) part of the tensor [R46].</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.eig_from_lo_tri" title="dipy.reconst.dti.eig_from_lo_tri"><tt class="xref py py-obj docutils literal"><span class="pre">eig_from_lo_tri</span></tt></a>(data)</td>
<td>Calculates tensor eigenvalues/eigenvectors from an array containing the lower diagonal form of the six unique tensor elements.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.fractional_anisotropy" title="dipy.reconst.dti.fractional_anisotropy"><tt class="xref py py-obj docutils literal"><span class="pre">fractional_anisotropy</span></tt></a>(evals[,&nbsp;axis])</td>
<td>Fractional anisotropy (FA) of a diffusion tensor.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.from_lower_triangular" title="dipy.reconst.dti.from_lower_triangular"><tt class="xref py py-obj docutils literal"><span class="pre">from_lower_triangular</span></tt></a>(D)</td>
<td>Returns a tensor given the six unique tensor elements</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.geodesic_anisotropy" title="dipy.reconst.dti.geodesic_anisotropy"><tt class="xref py py-obj docutils literal"><span class="pre">geodesic_anisotropy</span></tt></a>(evals[,&nbsp;axis])</td>
<td>Geodesic anisotropy (GA) of a diffusion tensor.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.get_sphere" title="dipy.reconst.dti.get_sphere"><tt class="xref py py-obj docutils literal"><span class="pre">get_sphere</span></tt></a>([name])</td>
<td>provide triangulated spheres</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.gradient_table" title="dipy.reconst.dti.gradient_table"><tt class="xref py py-obj docutils literal"><span class="pre">gradient_table</span></tt></a>(bvals[,&nbsp;bvecs,&nbsp;big_delta,&nbsp;...])</td>
<td>A general function for creating diffusion MR gradients.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.isotropic" title="dipy.reconst.dti.isotropic"><tt class="xref py py-obj docutils literal"><span class="pre">isotropic</span></tt></a>(q_form)</td>
<td>Calculate the isotropic part of the tensor [R51].</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.linearity" title="dipy.reconst.dti.linearity"><tt class="xref py py-obj docutils literal"><span class="pre">linearity</span></tt></a>(evals[,&nbsp;axis])</td>
<td>The linearity of the tensor <a class="footnote-reference" href="#id162" id="id7">[1]</a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.lower_triangular" title="dipy.reconst.dti.lower_triangular"><tt class="xref py py-obj docutils literal"><span class="pre">lower_triangular</span></tt></a>(tensor[,&nbsp;b0])</td>
<td>Returns the six lower triangular values of the tensor and a dummy variable</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.mean_diffusivity" title="dipy.reconst.dti.mean_diffusivity"><tt class="xref py py-obj docutils literal"><span class="pre">mean_diffusivity</span></tt></a>(evals[,&nbsp;axis])</td>
<td>Mean Diffusivity (MD) of a diffusion tensor.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.mode" title="dipy.reconst.dti.mode"><tt class="xref py py-obj docutils literal"><span class="pre">mode</span></tt></a>(q_form)</td>
<td>Mode (MO) of a diffusion tensor [R52].</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.nlls_fit_tensor" title="dipy.reconst.dti.nlls_fit_tensor"><tt class="xref py py-obj docutils literal"><span class="pre">nlls_fit_tensor</span></tt></a>(design_matrix,&nbsp;data[,&nbsp;...])</td>
<td>Fit the tensor params using non-linear least-squares.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.norm" title="dipy.reconst.dti.norm"><tt class="xref py py-obj docutils literal"><span class="pre">norm</span></tt></a>(q_form)</td>
<td>Calculate the Frobenius norm of a tensor quadratic form</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.ols_fit_tensor" title="dipy.reconst.dti.ols_fit_tensor"><tt class="xref py py-obj docutils literal"><span class="pre">ols_fit_tensor</span></tt></a>(design_matrix,&nbsp;data)</td>
<td>Computes ordinary least squares (OLS) fit to calculate self-diffusion tensor using a linear regression model <a class="footnote-reference" href="#id162" id="id9">[1]</a>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.planarity" title="dipy.reconst.dti.planarity"><tt class="xref py py-obj docutils literal"><span class="pre">planarity</span></tt></a>(evals[,&nbsp;axis])</td>
<td>The planarity of the tensor <a class="footnote-reference" href="#id162" id="id10">[1]</a></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.quantize_evecs" title="dipy.reconst.dti.quantize_evecs"><tt class="xref py py-obj docutils literal"><span class="pre">quantize_evecs</span></tt></a>(evecs[,&nbsp;odf_vertices])</td>
<td>Find the closest orientation of an evenly distributed sphere</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.radial_diffusivity" title="dipy.reconst.dti.radial_diffusivity"><tt class="xref py py-obj docutils literal"><span class="pre">radial_diffusivity</span></tt></a>(evals[,&nbsp;axis])</td>
<td>Radial Diffusivity (RD) of a diffusion tensor.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.restore_fit_tensor" title="dipy.reconst.dti.restore_fit_tensor"><tt class="xref py py-obj docutils literal"><span class="pre">restore_fit_tensor</span></tt></a>(design_matrix,&nbsp;data[,&nbsp;...])</td>
<td>Use the RESTORE algorithm [Chang2005] to calculate a robust tensor fit</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.sphericity" title="dipy.reconst.dti.sphericity"><tt class="xref py py-obj docutils literal"><span class="pre">sphericity</span></tt></a>(evals[,&nbsp;axis])</td>
<td>The sphericity of the tensor <a class="footnote-reference" href="#id162" id="id12">[1]</a></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.tensor_prediction" title="dipy.reconst.dti.tensor_prediction"><tt class="xref py py-obj docutils literal"><span class="pre">tensor_prediction</span></tt></a>(dti_params,&nbsp;gtab,&nbsp;S0)</td>
<td>Predict a signal given tensor parameters.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.trace" title="dipy.reconst.dti.trace"><tt class="xref py py-obj docutils literal"><span class="pre">trace</span></tt></a>(evals[,&nbsp;axis])</td>
<td>Trace of a diffusion tensor.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.vec_val_vect" title="dipy.reconst.dti.vec_val_vect"><tt class="xref py py-obj docutils literal"><span class="pre">vec_val_vect</span></tt></a></td>
<td>Vectorize <cite>vecs</cite>.diag(<cite>vals</cite>).`vecs`.T for last 2 dimensions of <cite>vecs</cite></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.vector_norm" title="dipy.reconst.dti.vector_norm"><tt class="xref py py-obj docutils literal"><span class="pre">vector_norm</span></tt></a>(vec[,&nbsp;axis,&nbsp;keepdims])</td>
<td>Return vector Euclidean (L2) norm</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.wls_fit_tensor" title="dipy.reconst.dti.wls_fit_tensor"><tt class="xref py py-obj docutils literal"><span class="pre">wls_fit_tensor</span></tt></a>(design_matrix,&nbsp;data)</td>
<td>Computes weighted least squares (WLS) fit to calculate self-diffusion tensor using a linear regression model [R53].</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.reconst.gqi">
<span id="module-reconst-gqi"></span><h2>Module: <tt class="xref py py-mod docutils literal"><span class="pre">reconst.gqi</span></tt><a class="headerlink" href="#module-dipy.reconst.gqi" title="Permalink to this headline">¶</a></h2>
<p>Classes and functions for generalized q-sampling</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.gqi.Cache" title="dipy.reconst.gqi.Cache"><tt class="xref py py-obj docutils literal"><span class="pre">Cache</span></tt></a></td>
<td>Cache values based on a key object (such as a sphere or gradient table).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.gqi.GeneralizedQSamplingFit" title="dipy.reconst.gqi.GeneralizedQSamplingFit"><tt class="xref py py-obj docutils literal"><span class="pre">GeneralizedQSamplingFit</span></tt></a>(model,&nbsp;data)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.gqi.GeneralizedQSamplingModel" title="dipy.reconst.gqi.GeneralizedQSamplingModel"><tt class="xref py py-obj docutils literal"><span class="pre">GeneralizedQSamplingModel</span></tt></a>(gtab[,&nbsp;method,&nbsp;...])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.gqi.OdfFit" title="dipy.reconst.gqi.OdfFit"><tt class="xref py py-obj docutils literal"><span class="pre">OdfFit</span></tt></a>(model,&nbsp;data)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.gqi.OdfModel" title="dipy.reconst.gqi.OdfModel"><tt class="xref py py-obj docutils literal"><span class="pre">OdfModel</span></tt></a>(gtab)</td>
<td>An abstract class to be sub-classed by specific odf models</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.gqi.equatorial_maximum" title="dipy.reconst.gqi.equatorial_maximum"><tt class="xref py py-obj docutils literal"><span class="pre">equatorial_maximum</span></tt></a>(vertices,&nbsp;odf,&nbsp;pole,&nbsp;width)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.gqi.equatorial_zone_vertices" title="dipy.reconst.gqi.equatorial_zone_vertices"><tt class="xref py py-obj docutils literal"><span class="pre">equatorial_zone_vertices</span></tt></a>(vertices,&nbsp;pole[,&nbsp;width])</td>
<td>finds the &#8216;vertices&#8217; in the equatorial zone conjugate</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.gqi.gfa" title="dipy.reconst.gqi.gfa"><tt class="xref py py-obj docutils literal"><span class="pre">gfa</span></tt></a>(samples)</td>
<td>The general fractional anisotropy of a function evaluated</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.gqi.local_maxima" title="dipy.reconst.gqi.local_maxima"><tt class="xref py py-obj docutils literal"><span class="pre">local_maxima</span></tt></a>(odf,&nbsp;edges)</td>
<td>Finds the local maxima of a function evaluated on a discrete set of points.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.gqi.multi_voxel_fit" title="dipy.reconst.gqi.multi_voxel_fit"><tt class="xref py py-obj docutils literal"><span class="pre">multi_voxel_fit</span></tt></a>(single_voxel_fit)</td>
<td>Method decorator to turn a single voxel model fit</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.gqi.normalize_qa" title="dipy.reconst.gqi.normalize_qa"><tt class="xref py py-obj docutils literal"><span class="pre">normalize_qa</span></tt></a>(qa[,&nbsp;max_qa])</td>
<td>Normalize quantitative anisotropy.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.gqi.npa" title="dipy.reconst.gqi.npa"><tt class="xref py py-obj docutils literal"><span class="pre">npa</span></tt></a>(self,&nbsp;odf[,&nbsp;width])</td>
<td>non-parametric anisotropy</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.gqi.odf_sum" title="dipy.reconst.gqi.odf_sum"><tt class="xref py py-obj docutils literal"><span class="pre">odf_sum</span></tt></a>(odf)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.gqi.patch_maximum" title="dipy.reconst.gqi.patch_maximum"><tt class="xref py py-obj docutils literal"><span class="pre">patch_maximum</span></tt></a>(vertices,&nbsp;odf,&nbsp;pole,&nbsp;width)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.gqi.patch_sum" title="dipy.reconst.gqi.patch_sum"><tt class="xref py py-obj docutils literal"><span class="pre">patch_sum</span></tt></a>(vertices,&nbsp;odf,&nbsp;pole,&nbsp;width)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.gqi.patch_vertices" title="dipy.reconst.gqi.patch_vertices"><tt class="xref py py-obj docutils literal"><span class="pre">patch_vertices</span></tt></a>(vertices,&nbsp;pole,&nbsp;width)</td>
<td>find &#8216;vertices&#8217; within the cone of &#8216;width&#8217; degrees around &#8216;pole&#8217;</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.gqi.polar_zone_vertices" title="dipy.reconst.gqi.polar_zone_vertices"><tt class="xref py py-obj docutils literal"><span class="pre">polar_zone_vertices</span></tt></a>(vertices,&nbsp;pole[,&nbsp;width])</td>
<td>finds the &#8216;vertices&#8217; in the equatorial band around</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.gqi.remove_similar_vertices" title="dipy.reconst.gqi.remove_similar_vertices"><tt class="xref py py-obj docutils literal"><span class="pre">remove_similar_vertices</span></tt></a>(vertices,&nbsp;theta)</td>
<td>Returns vertices that are separated by at least theta degrees from all other vertices.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.gqi.squared_radial_component" title="dipy.reconst.gqi.squared_radial_component"><tt class="xref py py-obj docutils literal"><span class="pre">squared_radial_component</span></tt></a>(x[,&nbsp;tol])</td>
<td>Part of the GQI2 integral</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.gqi.triple_odf_maxima" title="dipy.reconst.gqi.triple_odf_maxima"><tt class="xref py py-obj docutils literal"><span class="pre">triple_odf_maxima</span></tt></a>(vertices,&nbsp;odf,&nbsp;width)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.gqi.upper_hemi_map" title="dipy.reconst.gqi.upper_hemi_map"><tt class="xref py py-obj docutils literal"><span class="pre">upper_hemi_map</span></tt></a>(v)</td>
<td>maps a 3-vector into the z-upper hemisphere</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.reconst.interpolate">
<span id="module-reconst-interpolate"></span><h2>Module: <tt class="xref py py-mod docutils literal"><span class="pre">reconst.interpolate</span></tt><a class="headerlink" href="#module-dipy.reconst.interpolate" title="Permalink to this headline">¶</a></h2>
<p>Interpolators wrap arrays to allow the array to be indexed in continuous coordinates</p>
<p>This module uses the trackvis coordinate system, for more information about
this coordinate system please see dipy.tracking.utils
The following modules also use this coordinate system:
dipy.tracking.utils
dipy.tracking.integration
dipy.reconst.interpolate</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.interpolate.Interpolator" title="dipy.reconst.interpolate.Interpolator"><tt class="xref py py-obj docutils literal"><span class="pre">Interpolator</span></tt></a>(data,&nbsp;voxel_size)</td>
<td>Class to be subclassed by different interpolator types</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.interpolate.NearestNeighborInterpolator" title="dipy.reconst.interpolate.NearestNeighborInterpolator"><tt class="xref py py-obj docutils literal"><span class="pre">NearestNeighborInterpolator</span></tt></a>(data,&nbsp;voxel_size)</td>
<td>Interpolates data using nearest neighbor interpolation</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.interpolate.OutsideImage" title="dipy.reconst.interpolate.OutsideImage"><tt class="xref py py-obj docutils literal"><span class="pre">OutsideImage</span></tt></a></td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.interpolate.TriLinearInterpolator" title="dipy.reconst.interpolate.TriLinearInterpolator"><tt class="xref py py-obj docutils literal"><span class="pre">TriLinearInterpolator</span></tt></a>(data,&nbsp;voxel_size)</td>
<td>Interpolates data using trilinear interpolation</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.interpolate.array" title="dipy.reconst.interpolate.array"><tt class="xref py py-obj docutils literal"><span class="pre">array</span></tt></a>(object[,&nbsp;dtype,&nbsp;copy,&nbsp;order,&nbsp;subok,&nbsp;ndmin])</td>
<td>Create an array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.interpolate.trilinear_interp" title="dipy.reconst.interpolate.trilinear_interp"><tt class="xref py py-obj docutils literal"><span class="pre">trilinear_interp</span></tt></a></td>
<td>Interpolates data at index</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.reconst.multi_voxel">
<span id="module-reconst-multi-voxel"></span><h2>Module: <tt class="xref py py-mod docutils literal"><span class="pre">reconst.multi_voxel</span></tt><a class="headerlink" href="#module-dipy.reconst.multi_voxel" title="Permalink to this headline">¶</a></h2>
<p>Tools to easily make multi voxel models</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.multi_voxel.CallableArray" title="dipy.reconst.multi_voxel.CallableArray"><tt class="xref py py-obj docutils literal"><span class="pre">CallableArray</span></tt></a></td>
<td>An array which can be called like a function</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.multi_voxel.MultiVoxelFit" title="dipy.reconst.multi_voxel.MultiVoxelFit"><tt class="xref py py-obj docutils literal"><span class="pre">MultiVoxelFit</span></tt></a>(model,&nbsp;fit_array,&nbsp;mask)</td>
<td>Holds an array of fits and allows access to their attributes and</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.multi_voxel.ReconstFit" title="dipy.reconst.multi_voxel.ReconstFit"><tt class="xref py py-obj docutils literal"><span class="pre">ReconstFit</span></tt></a>(model,&nbsp;data)</td>
<td>Abstract class which holds the fit result of ReconstModel</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.multi_voxel.ReconstModel" title="dipy.reconst.multi_voxel.ReconstModel"><tt class="xref py py-obj docutils literal"><span class="pre">ReconstModel</span></tt></a>(gtab)</td>
<td>Abstract class for signal reconstruction models</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.multi_voxel.as_strided" title="dipy.reconst.multi_voxel.as_strided"><tt class="xref py py-obj docutils literal"><span class="pre">as_strided</span></tt></a>(x[,&nbsp;shape,&nbsp;strides])</td>
<td>Make an ndarray from the given array with the given shape and strides.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.multi_voxel.multi_voxel_fit" title="dipy.reconst.multi_voxel.multi_voxel_fit"><tt class="xref py py-obj docutils literal"><span class="pre">multi_voxel_fit</span></tt></a>(single_voxel_fit)</td>
<td>Method decorator to turn a single voxel model fit</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.multi_voxel.ndindex" title="dipy.reconst.multi_voxel.ndindex"><tt class="xref py py-obj docutils literal"><span class="pre">ndindex</span></tt></a>(shape)</td>
<td>An N-dimensional iterator object to index arrays.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.reconst.odf">
<span id="module-reconst-odf"></span><h2>Module: <tt class="xref py py-mod docutils literal"><span class="pre">reconst.odf</span></tt><a class="headerlink" href="#module-dipy.reconst.odf" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.odf.OdfFit" title="dipy.reconst.odf.OdfFit"><tt class="xref py py-obj docutils literal"><span class="pre">OdfFit</span></tt></a>(model,&nbsp;data)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.odf.OdfModel" title="dipy.reconst.odf.OdfModel"><tt class="xref py py-obj docutils literal"><span class="pre">OdfModel</span></tt></a>(gtab)</td>
<td>An abstract class to be sub-classed by specific odf models</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.odf.ReconstFit" title="dipy.reconst.odf.ReconstFit"><tt class="xref py py-obj docutils literal"><span class="pre">ReconstFit</span></tt></a>(model,&nbsp;data)</td>
<td>Abstract class which holds the fit result of ReconstModel</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.odf.ReconstModel" title="dipy.reconst.odf.ReconstModel"><tt class="xref py py-obj docutils literal"><span class="pre">ReconstModel</span></tt></a>(gtab)</td>
<td>Abstract class for signal reconstruction models</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.odf.gfa" title="dipy.reconst.odf.gfa"><tt class="xref py py-obj docutils literal"><span class="pre">gfa</span></tt></a>(samples)</td>
<td>The general fractional anisotropy of a function evaluated</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.odf.minmax_normalize" title="dipy.reconst.odf.minmax_normalize"><tt class="xref py py-obj docutils literal"><span class="pre">minmax_normalize</span></tt></a>(samples[,&nbsp;out])</td>
<td>Min-max normalization of a function evaluated on the unit sphere</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.reconst.peaks">
<span id="module-reconst-peaks"></span><h2>Module: <tt class="xref py py-mod docutils literal"><span class="pre">reconst.peaks</span></tt><a class="headerlink" href="#module-dipy.reconst.peaks" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.peaks.HemiSphere" title="dipy.reconst.peaks.HemiSphere"><tt class="xref py py-obj docutils literal"><span class="pre">HemiSphere</span></tt></a>([x,&nbsp;y,&nbsp;z,&nbsp;theta,&nbsp;phi,&nbsp;xyz,&nbsp;...])</td>
<td>Points on the unit sphere.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.peaks.InTemporaryDirectory" title="dipy.reconst.peaks.InTemporaryDirectory"><tt class="xref py py-obj docutils literal"><span class="pre">InTemporaryDirectory</span></tt></a>([suffix,&nbsp;prefix,&nbsp;dir,&nbsp;...])</td>
<td>Create, return, and change directory to a temporary directory</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.peaks.PeaksAndMetrics" title="dipy.reconst.peaks.PeaksAndMetrics"><tt class="xref py py-obj docutils literal"><span class="pre">PeaksAndMetrics</span></tt></a></td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.peaks.PeaksAndMetricsDirectionGetter" title="dipy.reconst.peaks.PeaksAndMetricsDirectionGetter"><tt class="xref py py-obj docutils literal"><span class="pre">PeaksAndMetricsDirectionGetter</span></tt></a></td>
<td>Deterministic Direction Getter based on peak directions.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.peaks.Sphere" title="dipy.reconst.peaks.Sphere"><tt class="xref py py-obj docutils literal"><span class="pre">Sphere</span></tt></a>([x,&nbsp;y,&nbsp;z,&nbsp;theta,&nbsp;phi,&nbsp;xyz,&nbsp;faces,&nbsp;edges])</td>
<td>Points on the unit sphere.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.peaks.repeat" title="dipy.reconst.peaks.repeat"><tt class="xref py py-obj docutils literal"><span class="pre">repeat</span></tt></a></td>
<td>repeat(object [,times]) -&gt; create an iterator which returns the object</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.peaks.xrange" title="dipy.reconst.peaks.xrange"><tt class="xref py py-obj docutils literal"><span class="pre">xrange</span></tt></a></td>
<td>xrange(stop) -&gt; xrange object</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.peaks.Pool" title="dipy.reconst.peaks.Pool"><tt class="xref py py-obj docutils literal"><span class="pre">Pool</span></tt></a>([processes,&nbsp;initializer,&nbsp;initargs,&nbsp;...])</td>
<td>Returns a process pool object</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.peaks.cpu_count" title="dipy.reconst.peaks.cpu_count"><tt class="xref py py-obj docutils literal"><span class="pre">cpu_count</span></tt></a>()</td>
<td>Returns the number of CPUs in the system</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.peaks.gfa" title="dipy.reconst.peaks.gfa"><tt class="xref py py-obj docutils literal"><span class="pre">gfa</span></tt></a>(samples)</td>
<td>The general fractional anisotropy of a function evaluated</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.peaks.local_maxima" title="dipy.reconst.peaks.local_maxima"><tt class="xref py py-obj docutils literal"><span class="pre">local_maxima</span></tt></a>(odf,&nbsp;edges)</td>
<td>Finds the local maxima of a function evaluated on a discrete set of points.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.peaks.ndindex" title="dipy.reconst.peaks.ndindex"><tt class="xref py py-obj docutils literal"><span class="pre">ndindex</span></tt></a>(shape)</td>
<td>An N-dimensional iterator object to index arrays.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.peaks.peak_directions" title="dipy.reconst.peaks.peak_directions"><tt class="xref py py-obj docutils literal"><span class="pre">peak_directions</span></tt></a>(odf,&nbsp;sphere[,&nbsp;...])</td>
<td>Get the directions of odf peaks</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.peaks.peak_directions_nl" title="dipy.reconst.peaks.peak_directions_nl"><tt class="xref py py-obj docutils literal"><span class="pre">peak_directions_nl</span></tt></a>(sphere_eval[,&nbsp;...])</td>
<td>Non Linear Direction Finder</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.peaks.peaks_from_model" title="dipy.reconst.peaks.peaks_from_model"><tt class="xref py py-obj docutils literal"><span class="pre">peaks_from_model</span></tt></a>(model,&nbsp;data,&nbsp;sphere,&nbsp;...[,&nbsp;...])</td>
<td>Fits the model to data and computes peaks and metrics</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.peaks.remove_similar_vertices" title="dipy.reconst.peaks.remove_similar_vertices"><tt class="xref py py-obj docutils literal"><span class="pre">remove_similar_vertices</span></tt></a>(vertices,&nbsp;theta)</td>
<td>Returns vertices that are separated by at least theta degrees from all other vertices.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.peaks.reshape_peaks_for_visualization" title="dipy.reconst.peaks.reshape_peaks_for_visualization"><tt class="xref py py-obj docutils literal"><span class="pre">reshape_peaks_for_visualization</span></tt></a>(peaks)</td>
<td>Reshape peaks for visualization.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.peaks.search_descending" title="dipy.reconst.peaks.search_descending"><tt class="xref py py-obj docutils literal"><span class="pre">search_descending</span></tt></a></td>
<td>Searches a descending array for the first element smaller than some</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.peaks.sh_to_sf_matrix" title="dipy.reconst.peaks.sh_to_sf_matrix"><tt class="xref py py-obj docutils literal"><span class="pre">sh_to_sf_matrix</span></tt></a>(sphere,&nbsp;sh_order[,&nbsp;...])</td>
<td>Matrix that transforms Spherical harmonics (SH) to spherical function (SF).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.peaks.warn" title="dipy.reconst.peaks.warn"><tt class="xref py py-obj docutils literal"><span class="pre">warn</span></tt></a></td>
<td>Issue a warning, or maybe ignore it or raise an exception.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.reconst.sfm">
<span id="module-reconst-sfm"></span><h2>Module: <tt class="xref py py-mod docutils literal"><span class="pre">reconst.sfm</span></tt><a class="headerlink" href="#module-dipy.reconst.sfm" title="Permalink to this headline">¶</a></h2>
<p>This is an implementation of the sparse fascicle model described in
<a class="reference internal" href="#id206" id="id14">[Rokem2014a]</a>. The multi b-value version of this model is described in
<a class="reference internal" href="#id207" id="id15">[Rokem2014b]</a>.</p>
<table class="docutils citation" frame="void" id="rokem2014a" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Rokem2014a]</td><td>Ariel Rokem, Jason D. Yeatman, Franco Pestilli, Kendrick
N. Kay, Aviv Mezer, Stefan van der Walt, Brian A. Wandell
(2014). Evaluating the accuracy of diffusion MRI models in white
matter. <a class="reference external" href="http://arxiv.org/abs/1411.0721">http://arxiv.org/abs/1411.0721</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="rokem2014b" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Rokem2014b]</td><td>Ariel Rokem, Kimberly L. Chan, Jason D. Yeatman, Franco
Pestilli,  Brian A. Wandell (2014). Evaluating the accuracy of diffusion
models at multiple b-values with cross-validation. ISMRM 2014.</td></tr>
</tbody>
</table>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.sfm.Cache" title="dipy.reconst.sfm.Cache"><tt class="xref py py-obj docutils literal"><span class="pre">Cache</span></tt></a></td>
<td>Cache values based on a key object (such as a sphere or gradient table).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.sfm.ExponentialIsotropicFit" title="dipy.reconst.sfm.ExponentialIsotropicFit"><tt class="xref py py-obj docutils literal"><span class="pre">ExponentialIsotropicFit</span></tt></a>(model,&nbsp;params)</td>
<td>A fit to the ExponentialIsotropicModel object, based on data.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.sfm.ExponentialIsotropicModel" title="dipy.reconst.sfm.ExponentialIsotropicModel"><tt class="xref py py-obj docutils literal"><span class="pre">ExponentialIsotropicModel</span></tt></a>(gtab)</td>
<td>Representing the isotropic signal as a fit to an exponential decay function</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.sfm.IsotropicFit" title="dipy.reconst.sfm.IsotropicFit"><tt class="xref py py-obj docutils literal"><span class="pre">IsotropicFit</span></tt></a>(model,&nbsp;params)</td>
<td>A fit object for representing the isotropic signal as the mean of the</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.sfm.IsotropicModel" title="dipy.reconst.sfm.IsotropicModel"><tt class="xref py py-obj docutils literal"><span class="pre">IsotropicModel</span></tt></a>(gtab)</td>
<td>A base-class for the representation of isotropic signals.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.sfm.ReconstFit" title="dipy.reconst.sfm.ReconstFit"><tt class="xref py py-obj docutils literal"><span class="pre">ReconstFit</span></tt></a>(model,&nbsp;data)</td>
<td>Abstract class which holds the fit result of ReconstModel</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.sfm.ReconstModel" title="dipy.reconst.sfm.ReconstModel"><tt class="xref py py-obj docutils literal"><span class="pre">ReconstModel</span></tt></a>(gtab)</td>
<td>Abstract class for signal reconstruction models</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.sfm.SparseFascicleFit" title="dipy.reconst.sfm.SparseFascicleFit"><tt class="xref py py-obj docutils literal"><span class="pre">SparseFascicleFit</span></tt></a>(model,&nbsp;beta,&nbsp;S0,&nbsp;iso)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.sfm.SparseFascicleModel" title="dipy.reconst.sfm.SparseFascicleModel"><tt class="xref py py-obj docutils literal"><span class="pre">SparseFascicleModel</span></tt></a>(gtab[,&nbsp;sphere,&nbsp;...])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.sfm.auto_attr" title="dipy.reconst.sfm.auto_attr"><tt class="xref py py-obj docutils literal"><span class="pre">auto_attr</span></tt></a>(func)</td>
<td>Decorator to create OneTimeProperty attributes.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.sfm.nanmean" title="dipy.reconst.sfm.nanmean"><tt class="xref py py-obj docutils literal"><span class="pre">nanmean</span></tt></a>(a[,&nbsp;axis,&nbsp;dtype,&nbsp;out,&nbsp;keepdims])</td>
<td>Compute the arithmetic mean along the specified axis, ignoring NaNs.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.sfm.optional_package" title="dipy.reconst.sfm.optional_package"><tt class="xref py py-obj docutils literal"><span class="pre">optional_package</span></tt></a>(name[,&nbsp;trip_msg])</td>
<td>Return package-like thing and module setup for package <cite>name</cite></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.sfm.sfm_design_matrix" title="dipy.reconst.sfm.sfm_design_matrix"><tt class="xref py py-obj docutils literal"><span class="pre">sfm_design_matrix</span></tt></a>(gtab,&nbsp;sphere,&nbsp;response[,&nbsp;mode])</td>
<td>Construct the SFM design matrix</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.reconst.shm">
<span id="module-reconst-shm"></span><h2>Module: <tt class="xref py py-mod docutils literal"><span class="pre">reconst.shm</span></tt><a class="headerlink" href="#module-dipy.reconst.shm" title="Permalink to this headline">¶</a></h2>
<p>Tools for using spherical harmonic models to fit diffusion data</p>
<div class="section" id="references">
<h3>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt>Aganj, I., et. al. 2009. ODF Reconstruction in Q-Ball Imaging With Solid</dt>
<dd>Angle Consideration.</dd>
<dt>Descoteaux, M., et. al. 2007. Regularized, fast, and robust analytical</dt>
<dd>Q-ball imaging.</dd>
<dt>Tristan-Vega, A., et. al. 2010. A new methodology for estimation of fiber</dt>
<dd>populations in white matter of the brain with Funk-Radon transform.</dd>
<dt>Tristan-Vega, A., et. al. 2009. Estimation of fiber orientation probability</dt>
<dd>density functions in high angular resolution diffusion imaging.</dd>
</dl>
</div>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.Cache" title="dipy.reconst.shm.Cache"><tt class="xref py py-obj docutils literal"><span class="pre">Cache</span></tt></a></td>
<td>Cache values based on a key object (such as a sphere or gradient table).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.CsaOdfModel" title="dipy.reconst.shm.CsaOdfModel"><tt class="xref py py-obj docutils literal"><span class="pre">CsaOdfModel</span></tt></a>(gtab,&nbsp;sh_order[,&nbsp;smooth,&nbsp;...])</td>
<td>Implementation of Constant Solid Angle reconstruction method.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.LooseVersion" title="dipy.reconst.shm.LooseVersion"><tt class="xref py py-obj docutils literal"><span class="pre">LooseVersion</span></tt></a>([vstring])</td>
<td>Version numbering for anarchists and software realists.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.OdfFit" title="dipy.reconst.shm.OdfFit"><tt class="xref py py-obj docutils literal"><span class="pre">OdfFit</span></tt></a>(model,&nbsp;data)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.OdfModel" title="dipy.reconst.shm.OdfModel"><tt class="xref py py-obj docutils literal"><span class="pre">OdfModel</span></tt></a>(gtab)</td>
<td>An abstract class to be sub-classed by specific odf models</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.OpdtModel" title="dipy.reconst.shm.OpdtModel"><tt class="xref py py-obj docutils literal"><span class="pre">OpdtModel</span></tt></a>(gtab,&nbsp;sh_order[,&nbsp;smooth,&nbsp;...])</td>
<td>Implementation of Orientation Probability Density Transform reconstruction method.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.QballBaseModel" title="dipy.reconst.shm.QballBaseModel"><tt class="xref py py-obj docutils literal"><span class="pre">QballBaseModel</span></tt></a>(gtab,&nbsp;sh_order[,&nbsp;smooth,&nbsp;...])</td>
<td>To be subclassed by Qball type models.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.QballModel" title="dipy.reconst.shm.QballModel"><tt class="xref py py-obj docutils literal"><span class="pre">QballModel</span></tt></a>(gtab,&nbsp;sh_order[,&nbsp;smooth,&nbsp;...])</td>
<td>Implementation of regularized Qball reconstruction method.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.ResidualBootstrapWrapper" title="dipy.reconst.shm.ResidualBootstrapWrapper"><tt class="xref py py-obj docutils literal"><span class="pre">ResidualBootstrapWrapper</span></tt></a>(signal_object,&nbsp;B,&nbsp;...)</td>
<td>Returns a residual bootstrap sample of the signal_object when indexed</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.SphHarmFit" title="dipy.reconst.shm.SphHarmFit"><tt class="xref py py-obj docutils literal"><span class="pre">SphHarmFit</span></tt></a>(model,&nbsp;shm_coef,&nbsp;mask)</td>
<td>Diffusion data fit to a spherical harmonic model</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.SphHarmModel" title="dipy.reconst.shm.SphHarmModel"><tt class="xref py py-obj docutils literal"><span class="pre">SphHarmModel</span></tt></a>(gtab)</td>
<td>To be subclassed by all models that return a SphHarmFit when fit.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.Sphere" title="dipy.reconst.shm.Sphere"><tt class="xref py py-obj docutils literal"><span class="pre">Sphere</span></tt></a>([x,&nbsp;y,&nbsp;z,&nbsp;theta,&nbsp;phi,&nbsp;xyz,&nbsp;faces,&nbsp;edges])</td>
<td>Points on the unit sphere.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.all_tensor_evecs" title="dipy.reconst.shm.all_tensor_evecs"><tt class="xref py py-obj docutils literal"><span class="pre">all_tensor_evecs</span></tt></a>(e0)</td>
<td>Given the principle tensor axis, return the array of all eigenvectors (or, the rotation matrix that orientates the tensor).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.auto_attr" title="dipy.reconst.shm.auto_attr"><tt class="xref py py-obj docutils literal"><span class="pre">auto_attr</span></tt></a>(func)</td>
<td>Decorator to create OneTimeProperty attributes.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.bootstrap_data_array" title="dipy.reconst.shm.bootstrap_data_array"><tt class="xref py py-obj docutils literal"><span class="pre">bootstrap_data_array</span></tt></a>(data,&nbsp;H,&nbsp;R[,&nbsp;permute])</td>
<td>Applies the Residual Bootstraps to the data given H and R</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.bootstrap_data_voxel" title="dipy.reconst.shm.bootstrap_data_voxel"><tt class="xref py py-obj docutils literal"><span class="pre">bootstrap_data_voxel</span></tt></a>(data,&nbsp;H,&nbsp;R[,&nbsp;permute])</td>
<td>Like bootstrap_data_array but faster when for a single voxel</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.cart2sphere" title="dipy.reconst.shm.cart2sphere"><tt class="xref py py-obj docutils literal"><span class="pre">cart2sphere</span></tt></a>(x,&nbsp;y,&nbsp;z)</td>
<td>Return angles for Cartesian 3D coordinates <cite>x</cite>, <cite>y</cite>, and <cite>z</cite></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.concatenate" title="dipy.reconst.shm.concatenate"><tt class="xref py py-obj docutils literal"><span class="pre">concatenate</span></tt></a>((a1,&nbsp;a2,&nbsp;...)[,&nbsp;axis])</td>
<td>Join a sequence of arrays together.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.diag" title="dipy.reconst.shm.diag"><tt class="xref py py-obj docutils literal"><span class="pre">diag</span></tt></a>(v[,&nbsp;k])</td>
<td>Extract a diagonal or construct a diagonal array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.diff" title="dipy.reconst.shm.diff"><tt class="xref py py-obj docutils literal"><span class="pre">diff</span></tt></a>(a[,&nbsp;n,&nbsp;axis])</td>
<td>Calculate the n-th order discrete difference along given axis.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.dot" title="dipy.reconst.shm.dot"><tt class="xref py py-obj docutils literal"><span class="pre">dot</span></tt></a>(a,&nbsp;b[,&nbsp;out])</td>
<td>Dot product of two arrays.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.empty" title="dipy.reconst.shm.empty"><tt class="xref py py-obj docutils literal"><span class="pre">empty</span></tt></a>(shape[,&nbsp;dtype,&nbsp;order])</td>
<td>Return a new array of given shape and type, without initializing entries.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.eye" title="dipy.reconst.shm.eye"><tt class="xref py py-obj docutils literal"><span class="pre">eye</span></tt></a>(N[,&nbsp;M,&nbsp;k,&nbsp;dtype])</td>
<td>Return a 2-D array with ones on the diagonal and zeros elsewhere.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.forward_sdeconv_mat" title="dipy.reconst.shm.forward_sdeconv_mat"><tt class="xref py py-obj docutils literal"><span class="pre">forward_sdeconv_mat</span></tt></a>(r_rh,&nbsp;n)</td>
<td>Build forward spherical deconvolution matrix</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.gen_dirac" title="dipy.reconst.shm.gen_dirac"><tt class="xref py py-obj docutils literal"><span class="pre">gen_dirac</span></tt></a>(m,&nbsp;n,&nbsp;theta,&nbsp;phi)</td>
<td>Generate Dirac delta function orientated in (theta, phi) on the sphere</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.hat" title="dipy.reconst.shm.hat"><tt class="xref py py-obj docutils literal"><span class="pre">hat</span></tt></a>(B)</td>
<td>Returns the hat matrix for the design matrix B</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.lazy_index" title="dipy.reconst.shm.lazy_index"><tt class="xref py py-obj docutils literal"><span class="pre">lazy_index</span></tt></a>(index)</td>
<td>Produces a lazy index</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.lcr_matrix" title="dipy.reconst.shm.lcr_matrix"><tt class="xref py py-obj docutils literal"><span class="pre">lcr_matrix</span></tt></a>(H)</td>
<td>Returns a matrix for computing leveraged, centered residuals from data</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.lpn" title="dipy.reconst.shm.lpn"><tt class="xref py py-obj docutils literal"><span class="pre">lpn</span></tt></a>(n,&nbsp;z)</td>
<td>Compute sequence of Legendre functions of the first kind (polynomials), Pn(z) and derivatives for all degrees from 0 to n (inclusive).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.normalize_data" title="dipy.reconst.shm.normalize_data"><tt class="xref py py-obj docutils literal"><span class="pre">normalize_data</span></tt></a>(data,&nbsp;where_b0[,&nbsp;min_signal,&nbsp;out])</td>
<td>Normalizes the data with respect to the mean b0</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.order_from_ncoef" title="dipy.reconst.shm.order_from_ncoef"><tt class="xref py py-obj docutils literal"><span class="pre">order_from_ncoef</span></tt></a>(ncoef)</td>
<td>Given a number n of coefficients, calculate back the sh_order</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.pinv" title="dipy.reconst.shm.pinv"><tt class="xref py py-obj docutils literal"><span class="pre">pinv</span></tt></a>(a[,&nbsp;rcond])</td>
<td>Compute the (Moore-Penrose) pseudo-inverse of a matrix.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.randint" title="dipy.reconst.shm.randint"><tt class="xref py py-obj docutils literal"><span class="pre">randint</span></tt></a>(low[,&nbsp;high,&nbsp;size])</td>
<td>Return random integers from <cite>low</cite> (inclusive) to <cite>high</cite> (exclusive).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.real_sph_harm" title="dipy.reconst.shm.real_sph_harm"><tt class="xref py py-obj docutils literal"><span class="pre">real_sph_harm</span></tt></a>(m,&nbsp;n,&nbsp;theta,&nbsp;phi)</td>
<td>Compute real spherical harmonics.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.real_sym_sh_basis" title="dipy.reconst.shm.real_sym_sh_basis"><tt class="xref py py-obj docutils literal"><span class="pre">real_sym_sh_basis</span></tt></a>(sh_order,&nbsp;theta,&nbsp;phi)</td>
<td>Samples a real symmetric spherical harmonic basis at point on the sphere</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.real_sym_sh_mrtrix" title="dipy.reconst.shm.real_sym_sh_mrtrix"><tt class="xref py py-obj docutils literal"><span class="pre">real_sym_sh_mrtrix</span></tt></a>(sh_order,&nbsp;theta,&nbsp;phi)</td>
<td>Compute real spherical harmonics as in mrtrix, where the real harmonic</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.sf_to_sh" title="dipy.reconst.shm.sf_to_sh"><tt class="xref py py-obj docutils literal"><span class="pre">sf_to_sh</span></tt></a>(sf,&nbsp;sphere[,&nbsp;sh_order,&nbsp;basis_type,&nbsp;...])</td>
<td>Spherical function to spherical harmonics (SH).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.sh_to_rh" title="dipy.reconst.shm.sh_to_rh"><tt class="xref py py-obj docutils literal"><span class="pre">sh_to_rh</span></tt></a>(r_sh,&nbsp;m,&nbsp;n)</td>
<td>Spherical harmonics (SH) to rotational harmonics (RH)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.sh_to_sf" title="dipy.reconst.shm.sh_to_sf"><tt class="xref py py-obj docutils literal"><span class="pre">sh_to_sf</span></tt></a>(sh,&nbsp;sphere,&nbsp;sh_order[,&nbsp;basis_type])</td>
<td>Spherical harmonics (SH) to spherical function (SF).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.sh_to_sf_matrix" title="dipy.reconst.shm.sh_to_sf_matrix"><tt class="xref py py-obj docutils literal"><span class="pre">sh_to_sf_matrix</span></tt></a>(sphere,&nbsp;sh_order[,&nbsp;...])</td>
<td>Matrix that transforms Spherical harmonics (SH) to spherical function (SF).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.single_tensor" title="dipy.reconst.shm.single_tensor"><tt class="xref py py-obj docutils literal"><span class="pre">single_tensor</span></tt></a>(gtab[,&nbsp;S0,&nbsp;evals,&nbsp;evecs,&nbsp;snr])</td>
<td>Simulated Q-space signal with a single tensor.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.smooth_pinv" title="dipy.reconst.shm.smooth_pinv"><tt class="xref py py-obj docutils literal"><span class="pre">smooth_pinv</span></tt></a>(B,&nbsp;L)</td>
<td>Regularized psudo-inverse</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.sph_harm_ind_list" title="dipy.reconst.shm.sph_harm_ind_list"><tt class="xref py py-obj docutils literal"><span class="pre">sph_harm_ind_list</span></tt></a>(sh_order)</td>
<td>Returns the degree (n) and order (m) of all the symmetric spherical harmonics of degree less then or equal to <cite>sh_order</cite>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.spherical_harmonics" title="dipy.reconst.shm.spherical_harmonics"><tt class="xref py py-obj docutils literal"><span class="pre">spherical_harmonics</span></tt></a>(m,&nbsp;n,&nbsp;theta,&nbsp;phi)</td>
<td>Compute spherical harmonics</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.svd" title="dipy.reconst.shm.svd"><tt class="xref py py-obj docutils literal"><span class="pre">svd</span></tt></a>(a[,&nbsp;full_matrices,&nbsp;compute_uv])</td>
<td>Singular Value Decomposition.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.unique" title="dipy.reconst.shm.unique"><tt class="xref py py-obj docutils literal"><span class="pre">unique</span></tt></a>(ar[,&nbsp;return_index,&nbsp;return_inverse])</td>
<td>Find the unique elements of an array.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.reconst.shore">
<span id="module-reconst-shore"></span><h2>Module: <tt class="xref py py-mod docutils literal"><span class="pre">reconst.shore</span></tt><a class="headerlink" href="#module-dipy.reconst.shore" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shore.Cache" title="dipy.reconst.shore.Cache"><tt class="xref py py-obj docutils literal"><span class="pre">Cache</span></tt></a></td>
<td>Cache values based on a key object (such as a sphere or gradient table).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shore.ShoreFit" title="dipy.reconst.shore.ShoreFit"><tt class="xref py py-obj docutils literal"><span class="pre">ShoreFit</span></tt></a>(model,&nbsp;shore_coef)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shore.ShoreModel" title="dipy.reconst.shore.ShoreModel"><tt class="xref py py-obj docutils literal"><span class="pre">ShoreModel</span></tt></a>(gtab[,&nbsp;radial_order,&nbsp;zeta,&nbsp;...])</td>
<td>Simple Harmonic Oscillator based Reconstruction and Estimation (SHORE) [R66] of the diffusion signal.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shore.cart2sphere" title="dipy.reconst.shore.cart2sphere"><tt class="xref py py-obj docutils literal"><span class="pre">cart2sphere</span></tt></a>(x,&nbsp;y,&nbsp;z)</td>
<td>Return angles for Cartesian 3D coordinates <cite>x</cite>, <cite>y</cite>, and <cite>z</cite></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shore.create_rspace" title="dipy.reconst.shore.create_rspace"><tt class="xref py py-obj docutils literal"><span class="pre">create_rspace</span></tt></a>(gridsize,&nbsp;radius_max)</td>
<td>Create the real space table, that contains the points in which     to compute the pdf.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shore.factorial" title="dipy.reconst.shore.factorial"><tt class="xref py py-obj docutils literal"><span class="pre">factorial</span></tt></a>((x)&nbsp;-&gt;&nbsp;Integral)</td>
<td>Find x!.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shore.genlaguerre" title="dipy.reconst.shore.genlaguerre"><tt class="xref py py-obj docutils literal"><span class="pre">genlaguerre</span></tt></a>(n,&nbsp;alpha[,&nbsp;monic])</td>
<td>Returns the nth order generalized (associated) Laguerre polynomial,</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shore.l_shore" title="dipy.reconst.shore.l_shore"><tt class="xref py py-obj docutils literal"><span class="pre">l_shore</span></tt></a>(radial_order)</td>
<td>Returns the angular regularisation matrix for SHORE basis</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shore.multi_voxel_fit" title="dipy.reconst.shore.multi_voxel_fit"><tt class="xref py py-obj docutils literal"><span class="pre">multi_voxel_fit</span></tt></a>(single_voxel_fit)</td>
<td>Method decorator to turn a single voxel model fit</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shore.n_shore" title="dipy.reconst.shore.n_shore"><tt class="xref py py-obj docutils literal"><span class="pre">n_shore</span></tt></a>(radial_order)</td>
<td>Returns the angular regularisation matrix for SHORE basis</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shore.optional_package" title="dipy.reconst.shore.optional_package"><tt class="xref py py-obj docutils literal"><span class="pre">optional_package</span></tt></a>(name[,&nbsp;trip_msg])</td>
<td>Return package-like thing and module setup for package <cite>name</cite></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shore.real_sph_harm" title="dipy.reconst.shore.real_sph_harm"><tt class="xref py py-obj docutils literal"><span class="pre">real_sph_harm</span></tt></a>(m,&nbsp;n,&nbsp;theta,&nbsp;phi)</td>
<td>Compute real spherical harmonics.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shore.shore_indices" title="dipy.reconst.shore.shore_indices"><tt class="xref py py-obj docutils literal"><span class="pre">shore_indices</span></tt></a>(radial_order,&nbsp;index)</td>
<td>Given the basis order and the index, return the shore indices n, l, m</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shore.shore_matrix" title="dipy.reconst.shore.shore_matrix"><tt class="xref py py-obj docutils literal"><span class="pre">shore_matrix</span></tt></a>(radial_order,&nbsp;zeta,&nbsp;gtab[,&nbsp;tau])</td>
<td>Compute the SHORE matrix for modified Merlet&#8217;s 3D-SHORE [R71]</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shore.shore_matrix_odf" title="dipy.reconst.shore.shore_matrix_odf"><tt class="xref py py-obj docutils literal"><span class="pre">shore_matrix_odf</span></tt></a>(radial_order,&nbsp;zeta,&nbsp;...)</td>
<td>Compute the SHORE ODF matrix [R72]&#8220;</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shore.shore_matrix_pdf" title="dipy.reconst.shore.shore_matrix_pdf"><tt class="xref py py-obj docutils literal"><span class="pre">shore_matrix_pdf</span></tt></a>(radial_order,&nbsp;zeta,&nbsp;rtab)</td>
<td>Compute the SHORE propagator matrix [R73]&#8220;</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shore.shore_order" title="dipy.reconst.shore.shore_order"><tt class="xref py py-obj docutils literal"><span class="pre">shore_order</span></tt></a>(n,&nbsp;l,&nbsp;m)</td>
<td>Given the indices (n,l,m) of the basis, return the minimum order for those indices and their index for modified Merlet&#8217;s 3D-SHORE.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shore.warn" title="dipy.reconst.shore.warn"><tt class="xref py py-obj docutils literal"><span class="pre">warn</span></tt></a></td>
<td>Issue a warning, or maybe ignore it or raise an exception.</td>
</tr>
</tbody>
</table>
<div class="section" id="bench">
<h3>bench<a class="headerlink" href="#bench" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.bench">
<tt class="descclassname">dipy.reconst.</tt><tt class="descname">bench</tt><big>(</big><em>self</em>, <em>label='fast'</em>, <em>verbose=1</em>, <em>extra_argv=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.bench" title="Permalink to this definition">¶</a></dt>
<dd><p>Run benchmarks for module using nose.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>label</strong> : {&#8216;fast&#8217;, &#8216;full&#8217;, &#8216;&#8217;, attribute identifier}, optional</p>
<blockquote>
<div><p>Identifies the benchmarks to run. This can be a string to pass to
the nosetests executable with the &#8216;-A&#8217; option, or one of several
special values.  Special values are:
* &#8216;fast&#8217; - the default - which corresponds to the <tt class="docutils literal"><span class="pre">nosetests</span> <span class="pre">-A</span></tt></p>
<blockquote>
<div><p>option of &#8216;not slow&#8217;.</p>
</div></blockquote>
<ul class="simple">
<li>&#8216;full&#8217; - fast (as above) and slow benchmarks as in the
&#8216;no -A&#8217; option to nosetests - this is the same as &#8216;&#8217;.</li>
<li>None or &#8216;&#8217; - run all tests.</li>
</ul>
<p>attribute_identifier - string passed directly to nosetests as &#8216;-A&#8217;.</p>
</div></blockquote>
<p><strong>verbose</strong> : int, optional</p>
<blockquote>
<div><p>Verbosity value for benchmark outputs, in the range 1-10. Default is 1.</p>
</div></blockquote>
<p><strong>extra_argv</strong> : list, optional</p>
<blockquote>
<div><p>List with any extra arguments to pass to nosetests.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>success</strong> : bool</p>
<blockquote class="last">
<div><p>Returns True if running the benchmarks works, False if an error
occurred.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Benchmarks are like tests, but have names starting with &#8220;bench&#8221; instead
of &#8220;test&#8221;, and can be found under the &#8220;benchmarks&#8221; sub-directory of the
module.</p>
<p>Each NumPy module exposes <cite>bench</cite> in its namespace to run all benchmarks
for it.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">success</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">bench</span><span class="p">()</span> 
<span class="go">Running benchmarks for numpy.lib</span>
<span class="gp">...</span>
<span class="go">using 562341 items:</span>
<span class="go">unique:</span>
<span class="go">0.11</span>
<span class="go">unique1d:</span>
<span class="go">0.11</span>
<span class="go">ratio: 1.0</span>
<span class="go">nUnique: 56230 == 56230</span>
<span class="gp">...</span>
<span class="go">OK</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">success</span> 
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="test">
<h3>test<a class="headerlink" href="#test" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.test">
<tt class="descclassname">dipy.reconst.</tt><tt class="descname">test</tt><big>(</big><em>self</em>, <em>label='fast'</em>, <em>verbose=1</em>, <em>extra_argv=None</em>, <em>doctests=False</em>, <em>coverage=False</em>, <em>raise_warnings=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.test" title="Permalink to this definition">¶</a></dt>
<dd><p>Run tests for module using nose.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>label</strong> : {&#8216;fast&#8217;, &#8216;full&#8217;, &#8216;&#8217;, attribute identifier}, optional</p>
<blockquote>
<div><p>Identifies the tests to run. This can be a string to pass to
the nosetests executable with the &#8216;-A&#8217; option, or one of several
special values.  Special values are:
* &#8216;fast&#8217; - the default - which corresponds to the <tt class="docutils literal"><span class="pre">nosetests</span> <span class="pre">-A</span></tt></p>
<blockquote>
<div><p>option of &#8216;not slow&#8217;.</p>
</div></blockquote>
<ul class="simple">
<li>&#8216;full&#8217; - fast (as above) and slow tests as in the
&#8216;no -A&#8217; option to nosetests - this is the same as &#8216;&#8217;.</li>
<li>None or &#8216;&#8217; - run all tests.</li>
</ul>
<p>attribute_identifier - string passed directly to nosetests as &#8216;-A&#8217;.</p>
</div></blockquote>
<p><strong>verbose</strong> : int, optional</p>
<blockquote>
<div><p>Verbosity value for test outputs, in the range 1-10. Default is 1.</p>
</div></blockquote>
<p><strong>extra_argv</strong> : list, optional</p>
<blockquote>
<div><p>List with any extra arguments to pass to nosetests.</p>
</div></blockquote>
<p><strong>doctests</strong> : bool, optional</p>
<blockquote>
<div><p>If True, run doctests in module. Default is False.</p>
</div></blockquote>
<p><strong>coverage</strong> : bool, optional</p>
<blockquote>
<div><p>If True, report coverage of NumPy code. Default is False.
(This requires the <a href="#id20"><span class="problematic" id="id21">`</span></a>coverage module:</p>
<blockquote>
<div><p>&lt;<a class="reference external" href="http://nedbatchelder.com/code/modules/coverage.html">http://nedbatchelder.com/code/modules/coverage.html</a>&gt;`_).</p>
</div></blockquote>
</div></blockquote>
<p><strong>raise_warnings</strong> : str or sequence of warnings, optional</p>
<blockquote>
<div><p>This specifies which warnings to configure as &#8216;raise&#8217; instead
of &#8216;warn&#8217; during the test execution.  Valid strings are:</p>
<blockquote>
<div><ul class="simple">
<li>&#8220;develop&#8221; : equals <tt class="docutils literal"><span class="pre">(DeprecationWarning,</span> <span class="pre">RuntimeWarning)</span></tt></li>
<li>&#8220;release&#8221; : equals <tt class="docutils literal"><span class="pre">()</span></tt>, don&#8217;t raise on any warnings.</li>
</ul>
</div></blockquote>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : object</p>
<blockquote class="last">
<div><p>Returns the result of running the tests as a
<tt class="docutils literal"><span class="pre">nose.result.TextTestResult</span></tt> object.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Each NumPy module exposes <cite>test</cite> in its namespace to run all tests for it.
For example, to run all tests for numpy.lib:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">test</span><span class="p">()</span> 
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">test</span><span class="p">()</span> 
<span class="go">Running unit tests for numpy.lib</span>
<span class="gp">...</span>
<span class="go">Ran 976 tests in 3.933s</span>
</pre></div>
</div>
<p>OK</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">errors</span> 
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">knownfail</span> 
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="reconstfit">
<h3><a class="reference internal" href="#dipy.reconst.base.ReconstFit" title="dipy.reconst.base.ReconstFit"><tt class="xref py py-class docutils literal"><span class="pre">ReconstFit</span></tt></a><a class="headerlink" href="#reconstfit" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.base.ReconstFit">
<em class="property">class </em><tt class="descclassname">dipy.reconst.base.</tt><tt class="descname">ReconstFit</tt><big>(</big><em>model</em>, <em>data</em><big>)</big><a class="headerlink" href="#dipy.reconst.base.ReconstFit" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></a></p>
<p>Abstract class which holds the fit result of ReconstModel</p>
<p>For example that could be holding FA or GFA etc.</p>
<dl class="method">
<dt id="dipy.reconst.base.ReconstFit.__init__">
<tt class="descname">__init__</tt><big>(</big><em>model</em>, <em>data</em><big>)</big><a class="headerlink" href="#dipy.reconst.base.ReconstFit.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="reconstmodel">
<h3><a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><tt class="xref py py-class docutils literal"><span class="pre">ReconstModel</span></tt></a><a class="headerlink" href="#reconstmodel" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.base.ReconstModel">
<em class="property">class </em><tt class="descclassname">dipy.reconst.base.</tt><tt class="descname">ReconstModel</tt><big>(</big><em>gtab</em><big>)</big><a class="headerlink" href="#dipy.reconst.base.ReconstModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></a></p>
<p>Abstract class for signal reconstruction models</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.base.ReconstModel.fit" title="dipy.reconst.base.ReconstModel.fit"><tt class="xref py py-obj docutils literal"><span class="pre">fit</span></tt></a>(data[,&nbsp;mask])</td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.base.ReconstModel.__init__">
<tt class="descname">__init__</tt><big>(</big><em>gtab</em><big>)</big><a class="headerlink" href="#dipy.reconst.base.ReconstModel.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialization of the abstract class for signal reconstruction models</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>gtab</strong> : GradientTable class instance</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.base.ReconstModel.fit">
<tt class="descname">fit</tt><big>(</big><em>data</em>, <em>mask=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#dipy.reconst.base.ReconstModel.fit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="bench-bounding-box">
<h3>bench_bounding_box<a class="headerlink" href="#bench-bounding-box" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.benchmarks.bench_bounding_box.bench_bounding_box">
<tt class="descclassname">dipy.reconst.benchmarks.bench_bounding_box.</tt><tt class="descname">bench_bounding_box</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.benchmarks.bench_bounding_box.bench_bounding_box" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="bounding-box">
<h3>bounding_box<a class="headerlink" href="#bounding-box" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.benchmarks.bench_bounding_box.bounding_box">
<tt class="descclassname">dipy.reconst.benchmarks.bench_bounding_box.</tt><tt class="descname">bounding_box</tt><big>(</big><em>vol</em><big>)</big><a class="headerlink" href="#dipy.reconst.benchmarks.bench_bounding_box.bounding_box" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the bounding box of nonzero intensity voxels in the volume.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>vol</strong> : ndarray</p>
<blockquote>
<div><p>Volume to compute bounding box on.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>npmins</strong> : list</p>
<blockquote>
<div><p>Array containg minimum index of each dimension</p>
</div></blockquote>
<p><strong>npmaxs</strong> : list</p>
<blockquote class="last">
<div><p>Array containg maximum index of each dimension</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="measure">
<h3>measure<a class="headerlink" href="#measure" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.benchmarks.bench_bounding_box.measure">
<tt class="descclassname">dipy.reconst.benchmarks.bench_bounding_box.</tt><tt class="descname">measure</tt><big>(</big><em>code_str</em>, <em>times=1</em>, <em>label=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.benchmarks.bench_bounding_box.measure" title="Permalink to this definition">¶</a></dt>
<dd><p>Return elapsed time for executing code in the namespace of the caller.</p>
<p>The supplied code string is compiled with the Python builtin <tt class="docutils literal"><span class="pre">compile</span></tt>.
The precision of the timing is 10 milli-seconds. If the code will execute
fast on this timescale, it can be executed many times to get reasonable
timing accuracy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>code_str</strong> : str</p>
<blockquote>
<div><p>The code to be timed.</p>
</div></blockquote>
<p><strong>times</strong> : int, optional</p>
<blockquote>
<div><p>The number of times the code is executed. Default is 1. The code is
only compiled once.</p>
</div></blockquote>
<p><strong>label</strong> : str, optional</p>
<blockquote>
<div><p>A label to identify <cite>code_str</cite> with. This is passed into <tt class="docutils literal"><span class="pre">compile</span></tt>
as the second argument (for run-time error messages).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>elapsed</strong> : float</p>
<blockquote class="last">
<div><p>Total elapsed time in seconds for executing <cite>code_str</cite> <cite>times</cite> times.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">etime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="s">&#39;for i in range(1000): np.sqrt(i**2)&#39;</span><span class="p">,</span>
<span class="gp">... </span>                           <span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="s">&quot;Time for a single execution : &quot;</span><span class="p">,</span> <span class="n">etime</span> <span class="o">/</span> <span class="n">times</span><span class="p">,</span> <span class="s">&quot;s&quot;</span>
<span class="go">Time for a single execution :  0.005 s</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="constrainedsphericaldeconvmodel">
<h3><a class="reference internal" href="#dipy.reconst.benchmarks.bench_csd.ConstrainedSphericalDeconvModel" title="dipy.reconst.benchmarks.bench_csd.ConstrainedSphericalDeconvModel"><tt class="xref py py-class docutils literal"><span class="pre">ConstrainedSphericalDeconvModel</span></tt></a><a class="headerlink" href="#constrainedsphericaldeconvmodel" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.benchmarks.bench_csd.ConstrainedSphericalDeconvModel">
<em class="property">class </em><tt class="descclassname">dipy.reconst.benchmarks.bench_csd.</tt><tt class="descname">ConstrainedSphericalDeconvModel</tt><big>(</big><em>gtab</em>, <em>response</em>, <em>reg_sphere=None</em>, <em>sh_order=8</em>, <em>lambda_=1</em>, <em>tau=0.1</em><big>)</big><a class="headerlink" href="#dipy.reconst.benchmarks.bench_csd.ConstrainedSphericalDeconvModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.shm.SphHarmModel" title="dipy.reconst.shm.SphHarmModel"><tt class="xref py py-class docutils literal"><span class="pre">dipy.reconst.shm.SphHarmModel</span></tt></a></p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">cache_clear</span></tt>()</td>
<td>Clear the cache.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">cache_get</span></tt>(tag,&nbsp;key[,&nbsp;default])</td>
<td>Retrieve a value from the cache.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">cache_set</span></tt>(tag,&nbsp;key,&nbsp;value)</td>
<td>Store a value in the cache.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_csd.ConstrainedSphericalDeconvModel.fit" title="dipy.reconst.benchmarks.bench_csd.ConstrainedSphericalDeconvModel.fit"><tt class="xref py py-obj docutils literal"><span class="pre">fit</span></tt></a>(data[,&nbsp;mask])</td>
<td>Fit method for every voxel in data</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_csd.ConstrainedSphericalDeconvModel.predict" title="dipy.reconst.benchmarks.bench_csd.ConstrainedSphericalDeconvModel.predict"><tt class="xref py py-obj docutils literal"><span class="pre">predict</span></tt></a>(sh_coeff[,&nbsp;gtab,&nbsp;S0])</td>
<td>Compute a signal prediction given spherical harmonic coefficients for the provided GradientTable class instance.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">sampling_matrix</span></tt>(sphere)</td>
<td>The matrix needed to sample ODFs from coefficients of the model.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.benchmarks.bench_csd.ConstrainedSphericalDeconvModel.__init__">
<tt class="descname">__init__</tt><big>(</big><em>gtab</em>, <em>response</em>, <em>reg_sphere=None</em>, <em>sh_order=8</em>, <em>lambda_=1</em>, <em>tau=0.1</em><big>)</big><a class="headerlink" href="#dipy.reconst.benchmarks.bench_csd.ConstrainedSphericalDeconvModel.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constrained Spherical Deconvolution (CSD) <a class="reference internal" href="#r74" id="id22">[R74]</a>.</p>
<p>Spherical deconvolution computes a fiber orientation distribution
(FOD), also called fiber ODF (fODF) <a class="reference internal" href="#r75" id="id23">[R75]</a>, as opposed to a diffusion ODF
as the QballModel or the CsaOdfModel. This results in a sharper angular
profile with better angular resolution that is the best object to be
used for later deterministic and probabilistic tractography <a class="reference internal" href="#r76" id="id24">[R76]</a>.</p>
<p>A sharp fODF is obtained because a single fiber <em>response</em> function is
injected as <em>a priori</em> knowledge. The response function is often
data-driven and is thus provided as input to the
ConstrainedSphericalDeconvModel. It will be used as deconvolution
kernel, as described in <a class="reference internal" href="#r74" id="id25">[R74]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>gtab</strong> : GradientTable</p>
<p><strong>response</strong> : tuple or AxSymShResponse object</p>
<blockquote>
<div><p>A tuple with two elements. The first is the eigen-values as an (3,)
ndarray and the second is the signal value for the response
function without diffusion weighting.  This is to be able to
generate a single fiber synthetic signal. The response function
will be used as deconvolution kernel (<a class="reference internal" href="#r74" id="id26">[R74]</a>)</p>
</div></blockquote>
<p><strong>reg_sphere</strong> : Sphere (optional)</p>
<blockquote>
<div><p>sphere used to build the regularization B matrix.
Default: &#8216;symmetric362&#8217;.</p>
</div></blockquote>
<p><strong>sh_order</strong> : int (optional)</p>
<blockquote>
<div><p>maximal spherical harmonics order. Default: 8</p>
</div></blockquote>
<p><strong>lambda_</strong> : float (optional)</p>
<blockquote>
<div><p>weight given to the constrained-positivity regularization part of the
deconvolution equation (see <a class="reference internal" href="#r74" id="id27">[R74]</a>). Default: 1</p>
</div></blockquote>
<p><strong>tau</strong> : float (optional)</p>
<blockquote class="last">
<div><p>threshold controlling the amplitude below which the corresponding
fODF is assumed to be zero.  Ideally, tau should be set to
zero. However, to improve the stability of the algorithm, tau is
set to tau*100 % of the mean fODF amplitude (here, 10% by default)
(see <a class="reference internal" href="#r74" id="id28">[R74]</a>). Default: 0.1</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r74" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R74]</td><td><em>(<a class="fn-backref" href="#id22">1</a>, <a class="fn-backref" href="#id25">2</a>, <a class="fn-backref" href="#id26">3</a>, <a class="fn-backref" href="#id27">4</a>, <a class="fn-backref" href="#id28">5</a>, <a class="fn-backref" href="#id29">6</a>)</em> Tournier, J.D., et al. NeuroImage 2007. Robust determination of
the fibre orientation distribution in diffusion MRI:
Non-negativity constrained super-resolved spherical
deconvolution</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r75" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R75]</td><td><em>(<a class="fn-backref" href="#id23">1</a>, <a class="fn-backref" href="#id30">2</a>)</em> Descoteaux, M., et al. IEEE TMI 2009. Deterministic and
Probabilistic Tractography Based on Complex Fibre Orientation
Distributions</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r76" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R76]</td><td><em>(<a class="fn-backref" href="#id24">1</a>, <a class="fn-backref" href="#id31">2</a>)</em> C^ot&#8217;e, M-A., et al. Medical Image Analysis 2013. Tractometer:
Towards validation of tractography pipelines</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r77" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id32">[R77]</a></td><td>Tournier, J.D, et al. Imaging Systems and Technology
2012. MRtrix: Diffusion Tractography in Crossing Fiber Regions</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.benchmarks.bench_csd.ConstrainedSphericalDeconvModel.fit">
<tt class="descname">fit</tt><big>(</big><em>data</em>, <em>mask=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.benchmarks.bench_csd.ConstrainedSphericalDeconvModel.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.benchmarks.bench_csd.ConstrainedSphericalDeconvModel.predict">
<tt class="descname">predict</tt><big>(</big><em>sh_coeff</em>, <em>gtab=None</em>, <em>S0=1</em><big>)</big><a class="headerlink" href="#dipy.reconst.benchmarks.bench_csd.ConstrainedSphericalDeconvModel.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a signal prediction given spherical harmonic coefficients
for the provided GradientTable class instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sh_coeff</strong> : ndarray</p>
<blockquote>
<div><p>The spherical harmonic representation of the FOD from which to make
the signal prediction.</p>
</div></blockquote>
<p><strong>gtab</strong> : GradientTable</p>
<blockquote>
<div><p>The gradients for which the signal will be predicted. Use the
model&#8217;s gradient table by default.</p>
</div></blockquote>
<p><strong>S0</strong> : ndarray or float</p>
<blockquote>
<div><p>The non diffusion-weighted signal value.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>pred_sig</strong> : ndarray</p>
<blockquote class="last">
<div><p>The predicted signal.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="gradienttable">
<h3><a class="reference internal" href="#dipy.reconst.benchmarks.bench_csd.GradientTable" title="dipy.reconst.benchmarks.bench_csd.GradientTable"><tt class="xref py py-class docutils literal"><span class="pre">GradientTable</span></tt></a><a class="headerlink" href="#gradienttable" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.benchmarks.bench_csd.GradientTable">
<em class="property">class </em><tt class="descclassname">dipy.reconst.benchmarks.bench_csd.</tt><tt class="descname">GradientTable</tt><big>(</big><em>gradients</em>, <em>big_delta=None</em>, <em>small_delta=None</em>, <em>b0_threshold=0</em><big>)</big><a class="headerlink" href="#dipy.reconst.benchmarks.bench_csd.GradientTable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></a></p>
<p>Diffusion gradient information</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>gradients</strong> : array_like (N, 3)</p>
<blockquote>
<div><p>N diffusion gradients</p>
</div></blockquote>
<p><strong>b0_threshold</strong> : float</p>
<blockquote class="last">
<div><p>Gradients with b-value less than or equal to <cite>b0_threshold</cite> are
considered as b0s i.e. without diffusion weighting.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-obj docutils literal"><span class="pre">gradient_table</span></tt></p>
</div>
<p class="rubric">Attributes</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_csd.GradientTable.bvals" title="dipy.reconst.benchmarks.bench_csd.GradientTable.bvals"><tt class="xref py py-obj docutils literal"><span class="pre">bvals</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_csd.GradientTable.bvecs" title="dipy.reconst.benchmarks.bench_csd.GradientTable.bvecs"><tt class="xref py py-obj docutils literal"><span class="pre">bvecs</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_csd.GradientTable.b0s_mask" title="dipy.reconst.benchmarks.bench_csd.GradientTable.b0s_mask"><tt class="xref py py-obj docutils literal"><span class="pre">b0s_mask</span></tt></a>()</td>
<td></td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="14%" />
<col width="66%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>gradients</td>
<td>(N,3) ndarray</td>
<td>diffusion gradients</td>
</tr>
<tr class="row-even"><td>qvals: (N,) ndarray</td>
<td>&nbsp;</td>
<td>The q-value for each gradient direction. Needs big and small
delta.</td>
</tr>
<tr class="row-odd"><td>b0_threshold</td>
<td>float</td>
<td>Gradients with b-value less than or equal to <cite>b0_threshold</cite> are
considered to not have diffusion weighting.</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_csd.GradientTable.b0s_mask" title="dipy.reconst.benchmarks.bench_csd.GradientTable.b0s_mask"><tt class="xref py py-obj docutils literal"><span class="pre">b0s_mask</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_csd.GradientTable.bvals" title="dipy.reconst.benchmarks.bench_csd.GradientTable.bvals"><tt class="xref py py-obj docutils literal"><span class="pre">bvals</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_csd.GradientTable.bvecs" title="dipy.reconst.benchmarks.bench_csd.GradientTable.bvecs"><tt class="xref py py-obj docutils literal"><span class="pre">bvecs</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_csd.GradientTable.qvals" title="dipy.reconst.benchmarks.bench_csd.GradientTable.qvals"><tt class="xref py py-obj docutils literal"><span class="pre">qvals</span></tt></a>()</td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.benchmarks.bench_csd.GradientTable.__init__">
<tt class="descname">__init__</tt><big>(</big><em>gradients</em>, <em>big_delta=None</em>, <em>small_delta=None</em>, <em>b0_threshold=0</em><big>)</big><a class="headerlink" href="#dipy.reconst.benchmarks.bench_csd.GradientTable.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor for GradientTable class</p>
</dd></dl>

<dl class="staticmethod">
<dt id="dipy.reconst.benchmarks.bench_csd.GradientTable.b0s_mask">
<em class="property">static </em><tt class="descname">b0s_mask</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.benchmarks.bench_csd.GradientTable.b0s_mask" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="dipy.reconst.benchmarks.bench_csd.GradientTable.bvals">
<em class="property">static </em><tt class="descname">bvals</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.benchmarks.bench_csd.GradientTable.bvals" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="dipy.reconst.benchmarks.bench_csd.GradientTable.bvecs">
<em class="property">static </em><tt class="descname">bvecs</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.benchmarks.bench_csd.GradientTable.bvecs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.benchmarks.bench_csd.GradientTable.info">
<tt class="descname">info</tt><a class="headerlink" href="#dipy.reconst.benchmarks.bench_csd.GradientTable.info" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="dipy.reconst.benchmarks.bench_csd.GradientTable.qvals">
<em class="property">static </em><tt class="descname">qvals</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.benchmarks.bench_csd.GradientTable.qvals" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="bench-csdeconv">
<h3>bench_csdeconv<a class="headerlink" href="#bench-csdeconv" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.benchmarks.bench_csd.bench_csdeconv">
<tt class="descclassname">dipy.reconst.benchmarks.bench_csd.</tt><tt class="descname">bench_csdeconv</tt><big>(</big><em>center=(50</em>, <em>40</em>, <em>40)</em>, <em>width=12</em><big>)</big><a class="headerlink" href="#dipy.reconst.benchmarks.bench_csd.bench_csdeconv" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="num-grad">
<h3>num_grad<a class="headerlink" href="#num-grad" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.benchmarks.bench_csd.num_grad">
<tt class="descclassname">dipy.reconst.benchmarks.bench_csd.</tt><tt class="descname">num_grad</tt><big>(</big><em>gtab</em><big>)</big><a class="headerlink" href="#dipy.reconst.benchmarks.bench_csd.num_grad" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="read-stanford-labels">
<h3>read_stanford_labels<a class="headerlink" href="#read-stanford-labels" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.benchmarks.bench_csd.read_stanford_labels">
<tt class="descclassname">dipy.reconst.benchmarks.bench_csd.</tt><tt class="descname">read_stanford_labels</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.benchmarks.bench_csd.read_stanford_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Read stanford hardi data and label map</p>
</dd></dl>

</div>
<div class="section" id="bench-local-maxima">
<h3>bench_local_maxima<a class="headerlink" href="#bench-local-maxima" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.benchmarks.bench_peaks.bench_local_maxima">
<tt class="descclassname">dipy.reconst.benchmarks.bench_peaks.</tt><tt class="descname">bench_local_maxima</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.benchmarks.bench_peaks.bench_local_maxima" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="get-sphere">
<h3>get_sphere<a class="headerlink" href="#get-sphere" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.benchmarks.bench_peaks.get_sphere">
<tt class="descclassname">dipy.reconst.benchmarks.bench_peaks.</tt><tt class="descname">get_sphere</tt><big>(</big><em>name='symmetric362'</em><big>)</big><a class="headerlink" href="#dipy.reconst.benchmarks.bench_peaks.get_sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>provide triangulated spheres</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>name</strong> : str</p>
<blockquote>
<div><p>which sphere - one of:
* &#8216;symmetric362&#8217;
* &#8216;symmetric642&#8217;
* &#8216;symmetric724&#8217;
* &#8216;repulsion724&#8217;
* &#8216;repulsion100&#8217;</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>sphere</strong> : a dipy.core.sphere.Sphere class instance</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.data</span> <span class="kn">import</span> <span class="n">get_sphere</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere</span> <span class="o">=</span> <span class="n">get_sphere</span><span class="p">(</span><span class="s">&#39;symmetric362&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span><span class="p">,</span> <span class="n">faces</span> <span class="o">=</span> <span class="n">sphere</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">sphere</span><span class="o">.</span><span class="n">faces</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(362, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">faces</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(720, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span><span class="p">,</span> <span class="n">faces</span> <span class="o">=</span> <span class="n">get_sphere</span><span class="p">(</span><span class="s">&#39;not a sphere name&#39;</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">DataError</span>: <span class="n">No sphere called &quot;not a sphere name&quot;</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="local-maxima">
<h3>local_maxima<a class="headerlink" href="#local-maxima" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.benchmarks.bench_peaks.local_maxima">
<tt class="descclassname">dipy.reconst.benchmarks.bench_peaks.</tt><tt class="descname">local_maxima</tt><big>(</big><em>odf</em>, <em>edges</em><big>)</big><a class="headerlink" href="#dipy.reconst.benchmarks.bench_peaks.local_maxima" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the local maxima of a function evaluated on a discrete set of points.</p>
<p>If a function is evaluated on some set of points where each pair of
neighboring points is an edge in edges, find the local maxima.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>odf</strong> : array, 1d, dtype=double</p>
<blockquote>
<div><p>The function evaluated on a set of discrete points.</p>
</div></blockquote>
<p><strong>edges</strong> : array (N, 2)</p>
<blockquote>
<div><p>The set of neighbor relations between the points. Every edge, ie
<cite>edges[i, :]</cite>, is a pair of neighboring points.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>peak_values</strong> : ndarray</p>
<blockquote>
<div><p>Value of odf at a maximum point. Peak values is sorted in descending
order.</p>
</div></blockquote>
<p><strong>peak_indices</strong> : ndarray</p>
<blockquote class="last">
<div><p>Indices of maximum points. Sorted in the same order as <cite>peak_values</cite> so
<cite>odf[peak_indices[i]] == peak_values[i]</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="dipy.core.html#module-dipy.core.sphere" title="dipy.core.sphere"><tt class="xref py py-obj docutils literal"><span class="pre">dipy.core.sphere</span></tt></a></p>
</div>
</dd></dl>

</div>
<div class="section" id="id33">
<h3>measure<a class="headerlink" href="#id33" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.benchmarks.bench_peaks.measure">
<tt class="descclassname">dipy.reconst.benchmarks.bench_peaks.</tt><tt class="descname">measure</tt><big>(</big><em>code_str</em>, <em>times=1</em>, <em>label=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.benchmarks.bench_peaks.measure" title="Permalink to this definition">¶</a></dt>
<dd><p>Return elapsed time for executing code in the namespace of the caller.</p>
<p>The supplied code string is compiled with the Python builtin <tt class="docutils literal"><span class="pre">compile</span></tt>.
The precision of the timing is 10 milli-seconds. If the code will execute
fast on this timescale, it can be executed many times to get reasonable
timing accuracy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>code_str</strong> : str</p>
<blockquote>
<div><p>The code to be timed.</p>
</div></blockquote>
<p><strong>times</strong> : int, optional</p>
<blockquote>
<div><p>The number of times the code is executed. Default is 1. The code is
only compiled once.</p>
</div></blockquote>
<p><strong>label</strong> : str, optional</p>
<blockquote>
<div><p>A label to identify <cite>code_str</cite> with. This is passed into <tt class="docutils literal"><span class="pre">compile</span></tt>
as the second argument (for run-time error messages).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>elapsed</strong> : float</p>
<blockquote class="last">
<div><p>Total elapsed time in seconds for executing <cite>code_str</cite> <cite>times</cite> times.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">etime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="s">&#39;for i in range(1000): np.sqrt(i**2)&#39;</span><span class="p">,</span>
<span class="gp">... </span>                           <span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="s">&quot;Time for a single execution : &quot;</span><span class="p">,</span> <span class="n">etime</span> <span class="o">/</span> <span class="n">times</span><span class="p">,</span> <span class="s">&quot;s&quot;</span>
<span class="go">Time for a single execution :  0.005 s</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="unique-edges">
<h3>unique_edges<a class="headerlink" href="#unique-edges" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.benchmarks.bench_peaks.unique_edges">
<tt class="descclassname">dipy.reconst.benchmarks.bench_peaks.</tt><tt class="descname">unique_edges</tt><big>(</big><em>faces</em>, <em>return_mapping=False</em><big>)</big><a class="headerlink" href="#dipy.reconst.benchmarks.bench_peaks.unique_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract all unique edges from given triangular faces.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>faces</strong> : (N, 3) ndarray</p>
<blockquote>
<div><p>Vertex indices forming triangular faces.</p>
</div></blockquote>
<p><strong>return_mapping</strong> : bool</p>
<blockquote>
<div><p>If true, a mapping to the edges of each face is returned.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>edges</strong> : (N, 2) ndarray</p>
<blockquote>
<div><p>Unique edges.</p>
</div></blockquote>
<p><strong>mapping</strong> : (N, 3)</p>
<blockquote class="last">
<div><p>For each face, [x, y, z], a mapping to it&#8217;s edges [a, b, c].</p>
<div class="highlight-python"><div class="highlight"><pre>   y
   /               /               a/    
/                  /                   /__________          x      c     z
</pre></div>
</div>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="bench-quick-squash">
<h3>bench_quick_squash<a class="headerlink" href="#bench-quick-squash" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.benchmarks.bench_squash.bench_quick_squash">
<tt class="descclassname">dipy.reconst.benchmarks.bench_squash.</tt><tt class="descname">bench_quick_squash</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.benchmarks.bench_squash.bench_quick_squash" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="id34">
<h3>measure<a class="headerlink" href="#id34" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.benchmarks.bench_squash.measure">
<tt class="descclassname">dipy.reconst.benchmarks.bench_squash.</tt><tt class="descname">measure</tt><big>(</big><em>code_str</em>, <em>times=1</em>, <em>label=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.benchmarks.bench_squash.measure" title="Permalink to this definition">¶</a></dt>
<dd><p>Return elapsed time for executing code in the namespace of the caller.</p>
<p>The supplied code string is compiled with the Python builtin <tt class="docutils literal"><span class="pre">compile</span></tt>.
The precision of the timing is 10 milli-seconds. If the code will execute
fast on this timescale, it can be executed many times to get reasonable
timing accuracy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>code_str</strong> : str</p>
<blockquote>
<div><p>The code to be timed.</p>
</div></blockquote>
<p><strong>times</strong> : int, optional</p>
<blockquote>
<div><p>The number of times the code is executed. Default is 1. The code is
only compiled once.</p>
</div></blockquote>
<p><strong>label</strong> : str, optional</p>
<blockquote>
<div><p>A label to identify <cite>code_str</cite> with. This is passed into <tt class="docutils literal"><span class="pre">compile</span></tt>
as the second argument (for run-time error messages).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>elapsed</strong> : float</p>
<blockquote class="last">
<div><p>Total elapsed time in seconds for executing <cite>code_str</cite> <cite>times</cite> times.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">etime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="s">&#39;for i in range(1000): np.sqrt(i**2)&#39;</span><span class="p">,</span>
<span class="gp">... </span>                           <span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="s">&quot;Time for a single execution : &quot;</span><span class="p">,</span> <span class="n">etime</span> <span class="o">/</span> <span class="n">times</span><span class="p">,</span> <span class="s">&quot;s&quot;</span>
<span class="go">Time for a single execution :  0.005 s</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="ndindex">
<h3>ndindex<a class="headerlink" href="#ndindex" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.benchmarks.bench_squash.ndindex">
<tt class="descclassname">dipy.reconst.benchmarks.bench_squash.</tt><tt class="descname">ndindex</tt><big>(</big><em>shape</em><big>)</big><a class="headerlink" href="#dipy.reconst.benchmarks.bench_squash.ndindex" title="Permalink to this definition">¶</a></dt>
<dd><p>An N-dimensional iterator object to index arrays.</p>
<p>Given the shape of an array, an <cite>ndindex</cite> instance iterates over
the N-dimensional index of the array. At each iteration a tuple
of indices is returned; the last dimension is iterated over first.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>shape</strong> : tuple of ints</p>
<blockquote class="last">
<div><p>The dimensions of the array.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.core.ndindex</span> <span class="kn">import</span> <span class="n">ndindex</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
<span class="go">(0, 0, 0)</span>
<span class="go">(0, 1, 0)</span>
<span class="go">(1, 0, 0)</span>
<span class="go">(1, 1, 0)</span>
<span class="go">(2, 0, 0)</span>
<span class="go">(2, 1, 0)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="old-squash">
<h3>old_squash<a class="headerlink" href="#old-squash" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.benchmarks.bench_squash.old_squash">
<tt class="descclassname">dipy.reconst.benchmarks.bench_squash.</tt><tt class="descname">old_squash</tt><big>(</big><em>arr</em>, <em>mask=None</em>, <em>fill=0</em><big>)</big><a class="headerlink" href="#dipy.reconst.benchmarks.bench_squash.old_squash" title="Permalink to this definition">¶</a></dt>
<dd><p>Try and make a standard array from an object array</p>
<p>This function takes an object array and attempts to convert it to a more
useful dtype. If array can be converted to a better dtype, Nones are
replaced by <cite>fill</cite>. To make the behaviour of this function more clear, here
are the most common cases:</p>
<ol class="arabic simple">
<li><cite>arr</cite> is an array of scalars of type <cite>T</cite>. Returns an array like
<cite>arr.astype(T)</cite></li>
<li><cite>arr</cite> is an array of arrays. All items in <cite>arr</cite> have the same shape
<cite>S</cite>. Returns an array with shape <cite>arr.shape + S</cite>.</li>
<li><cite>arr</cite> is an array of arrays of different shapes. Returns <cite>arr</cite>.</li>
<li>Items in <cite>arr</cite> are not ndarrys or scalars. Returns <cite>arr</cite>.</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>arr</strong> : array, dtype=object</p>
<blockquote>
<div><p>The array to be converted.</p>
</div></blockquote>
<p><strong>mask</strong> : array, dtype=bool, optional</p>
<blockquote>
<div><p>Where arr has Nones.</p>
</div></blockquote>
<p><strong>fill</strong> : number, optional</p>
<blockquote>
<div><p>Nones are replaced by fill.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>result</strong> : array</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">old_squash</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
<span class="go">array([2, 2, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">old_squash</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
<span class="go">array([0, 2, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">old_squash</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">dtype</span>
<span class="go">dtype(&#39;float64&#39;)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="quick-squash">
<h3>quick_squash<a class="headerlink" href="#quick-squash" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.benchmarks.bench_squash.quick_squash">
<tt class="descclassname">dipy.reconst.benchmarks.bench_squash.</tt><tt class="descname">quick_squash</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.benchmarks.bench_squash.quick_squash" title="Permalink to this definition">¶</a></dt>
<dd><p>Try and make a standard array from an object array</p>
<p>This function takes an object array and attempts to convert it to a more
useful dtype. If array can be converted to a better dtype, Nones are
replaced by <cite>fill</cite>. To make the behaviour of this function more clear, here
are the most common cases:</p>
<ol class="arabic simple">
<li><cite>obj_arr</cite> is an array of scalars of type <cite>T</cite>. Returns an array like
<cite>obj_arr.astype(T)</cite></li>
<li><cite>obj_arr</cite> is an array of arrays. All items in <cite>obj_arr</cite> have the same
shape <tt class="docutils literal"><span class="pre">S</span></tt>. Returns an array with shape <tt class="docutils literal"><span class="pre">obj_arr.shape</span> <span class="pre">+</span> <span class="pre">S</span></tt></li>
<li><cite>obj_arr</cite> is an array of arrays of different shapes. Returns <cite>obj_arr</cite>.</li>
<li>Items in <cite>obj_arr</cite> are not ndarrays or scalars. Returns <cite>obj_arr</cite>.</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>obj_arr</strong> : array, dtype=object</p>
<blockquote>
<div><p>The array to be converted.</p>
</div></blockquote>
<p><strong>mask</strong> : array, dtype=bool, optional</p>
<blockquote>
<div><p>mask is nonzero where <cite>obj_arr</cite> has Nones.</p>
</div></blockquote>
<p><strong>fill</strong> : number, optional</p>
<blockquote>
<div><p>Nones are replaced by <cite>fill</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>result</strong> : array</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">quick_squash</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
<span class="go">array([2, 2, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">quick_squash</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
<span class="go">array([0, 2, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">quick_squash</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">dtype</span>
<span class="go">dtype(&#39;float64&#39;)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="reduce">
<h3>reduce<a class="headerlink" href="#reduce" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.benchmarks.bench_squash.reduce">
<tt class="descclassname">dipy.reconst.benchmarks.bench_squash.</tt><tt class="descname">reduce</tt><big>(</big><em>function</em>, <em>sequence</em><span class="optional">[</span>, <em>initial</em><span class="optional">]</span><big>)</big> &rarr; value<a class="headerlink" href="#dipy.reconst.benchmarks.bench_squash.reduce" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a function of two arguments cumulatively to the items of a sequence,
from left to right, so as to reduce the sequence to a single value.
For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates
((((1+2)+3)+4)+5).  If initial is present, it is placed before the items
of the sequence in the calculation, and serves as a default when the
sequence is empty.</p>
</dd></dl>

</div>
<div class="section" id="bench-vec-val-vect">
<h3>bench_vec_val_vect<a class="headerlink" href="#bench-vec-val-vect" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.benchmarks.bench_vec_val_sum.bench_vec_val_vect">
<tt class="descclassname">dipy.reconst.benchmarks.bench_vec_val_sum.</tt><tt class="descname">bench_vec_val_vect</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.benchmarks.bench_vec_val_sum.bench_vec_val_vect" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="id35">
<h3>measure<a class="headerlink" href="#id35" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.benchmarks.bench_vec_val_sum.measure">
<tt class="descclassname">dipy.reconst.benchmarks.bench_vec_val_sum.</tt><tt class="descname">measure</tt><big>(</big><em>code_str</em>, <em>times=1</em>, <em>label=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.benchmarks.bench_vec_val_sum.measure" title="Permalink to this definition">¶</a></dt>
<dd><p>Return elapsed time for executing code in the namespace of the caller.</p>
<p>The supplied code string is compiled with the Python builtin <tt class="docutils literal"><span class="pre">compile</span></tt>.
The precision of the timing is 10 milli-seconds. If the code will execute
fast on this timescale, it can be executed many times to get reasonable
timing accuracy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>code_str</strong> : str</p>
<blockquote>
<div><p>The code to be timed.</p>
</div></blockquote>
<p><strong>times</strong> : int, optional</p>
<blockquote>
<div><p>The number of times the code is executed. Default is 1. The code is
only compiled once.</p>
</div></blockquote>
<p><strong>label</strong> : str, optional</p>
<blockquote>
<div><p>A label to identify <cite>code_str</cite> with. This is passed into <tt class="docutils literal"><span class="pre">compile</span></tt>
as the second argument (for run-time error messages).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>elapsed</strong> : float</p>
<blockquote class="last">
<div><p>Total elapsed time in seconds for executing <cite>code_str</cite> <cite>times</cite> times.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">etime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="s">&#39;for i in range(1000): np.sqrt(i**2)&#39;</span><span class="p">,</span>
<span class="gp">... </span>                           <span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="s">&quot;Time for a single execution : &quot;</span><span class="p">,</span> <span class="n">etime</span> <span class="o">/</span> <span class="n">times</span><span class="p">,</span> <span class="s">&quot;s&quot;</span>
<span class="go">Time for a single execution :  0.005 s</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="randn">
<h3>randn<a class="headerlink" href="#randn" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.benchmarks.bench_vec_val_sum.randn">
<tt class="descclassname">dipy.reconst.benchmarks.bench_vec_val_sum.</tt><tt class="descname">randn</tt><big>(</big><em>d0</em>, <em>d1</em>, <em>...</em>, <em>dn</em><big>)</big><a class="headerlink" href="#dipy.reconst.benchmarks.bench_vec_val_sum.randn" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a sample (or samples) from the &#8220;standard normal&#8221; distribution.</p>
<p>If positive, int_like or int-convertible arguments are provided,
<cite>randn</cite> generates an array of shape <tt class="docutils literal"><span class="pre">(d0,</span> <span class="pre">d1,</span> <span class="pre">...,</span> <span class="pre">dn)</span></tt>, filled
with random floats sampled from a univariate &#8220;normal&#8221; (Gaussian)
distribution of mean 0 and variance 1 (if any of the <span class="math">d_i</span> are
floats, they are first converted to integers by truncation). A single
float randomly sampled from the distribution is returned if no
argument is provided.</p>
<p>This is a convenience function.  If you want an interface that takes a
tuple as the first argument, use <cite>numpy.random.standard_normal</cite> instead.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>d0, d1, ..., dn</strong> : int, optional</p>
<blockquote>
<div><p>The dimensions of the returned array, should be all positive.
If no argument is given a single Python float is returned.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Z</strong> : ndarray or float</p>
<blockquote class="last">
<div><p>A <tt class="docutils literal"><span class="pre">(d0,</span> <span class="pre">d1,</span> <span class="pre">...,</span> <span class="pre">dn)</span></tt>-shaped array of floating-point samples from
the standard normal distribution, or a single such float if
no parameters were supplied.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><tt class="xref py py-obj docutils literal"><span class="pre">random.standard_normal</span></tt></dt>
<dd>Similar, but takes a tuple as its argument.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>For random samples from <span class="math">N(\mu, \sigma^2)</span>, use:</p>
<p><tt class="docutils literal"><span class="pre">sigma</span> <span class="pre">*</span> <span class="pre">np.random.randn(...)</span> <span class="pre">+</span> <span class="pre">mu</span></tt></p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">()</span>
<span class="go">2.1923875335537315 #random</span>
</pre></div>
</div>
<p>Two-by-four array of samples from N(3, 6.25):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span>
<span class="go">array([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],  #random</span>
<span class="go">       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]]) #random</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="vec-val-vect">
<h3>vec_val_vect<a class="headerlink" href="#vec-val-vect" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.benchmarks.bench_vec_val_sum.vec_val_vect">
<tt class="descclassname">dipy.reconst.benchmarks.bench_vec_val_sum.</tt><tt class="descname">vec_val_vect</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.benchmarks.bench_vec_val_sum.vec_val_vect" title="Permalink to this definition">¶</a></dt>
<dd><p>Vectorize <cite>vecs</cite>.diag(<cite>vals</cite>).`vecs`.T for last 2 dimensions of <cite>vecs</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>vecs</strong> : shape (..., M, N) array</p>
<blockquote>
<div><p>containing tensor in last two dimensions; M, N usually equal to (3, 3)</p>
</div></blockquote>
<p><strong>vals</strong> : shape (..., N) array</p>
<blockquote>
<div><p>diagonal values carried in last dimension, <tt class="docutils literal"><span class="pre">...</span></tt> shape above must
match that for <cite>vecs</cite></p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>res</strong> : shape (..., M, M) array</p>
<blockquote>
<div><p>For all the dimensions ellided by <tt class="docutils literal"><span class="pre">...</span></tt>, loops to get (M, N) <tt class="docutils literal"><span class="pre">vec</span></tt>
matrix, and (N,) <tt class="docutils literal"><span class="pre">vals</span></tt> vector, and calculates
<tt class="docutils literal"><span class="pre">vec.dot(np.diag(val).dot(vec.T)</span></tt>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>ValueError</strong> : non-matching <tt class="docutils literal"><span class="pre">...</span></tt> dimensions of <cite>vecs</cite>, <cite>vals</cite></p>
<p class="last"><strong>ValueError</strong> : non-matching <tt class="docutils literal"><span class="pre">N</span></tt> dimensions of <cite>vecs</cite>, <cite>vals</cite></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Make a 3D array where the first dimension is only 1</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">vecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vec_val_vect</span><span class="p">(</span><span class="n">vecs</span><span class="p">,</span> <span class="n">vals</span><span class="p">)</span>
<span class="go">array([[[   9.,   24.,   39.],</span>
<span class="go">        [  24.,   66.,  108.],</span>
<span class="go">        [  39.,  108.,  177.]]])</span>
</pre></div>
</div>
<p>That&#8217;s the same as the 2D case (apart from the float casting):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">vecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vecs</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">vals</span><span class="p">),</span> <span class="n">vecs</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
<span class="go">array([[  9,  24,  39],</span>
<span class="go">       [ 24,  66, 108],</span>
<span class="go">       [ 39, 108, 177]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="with-einsum">
<h3>with_einsum<a class="headerlink" href="#with-einsum" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.benchmarks.bench_vec_val_sum.with_einsum">
<tt class="descclassname">dipy.reconst.benchmarks.bench_vec_val_sum.</tt><tt class="descname">with_einsum</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#dipy.reconst.benchmarks.bench_vec_val_sum.with_einsum" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="cache">
<h3><a class="reference internal" href="#dipy.reconst.cache.Cache" title="dipy.reconst.cache.Cache"><tt class="xref py py-class docutils literal"><span class="pre">Cache</span></tt></a><a class="headerlink" href="#cache" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.cache.Cache">
<em class="property">class </em><tt class="descclassname">dipy.reconst.cache.</tt><tt class="descname">Cache</tt><a class="headerlink" href="#dipy.reconst.cache.Cache" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></a></p>
<p>Cache values based on a key object (such as a sphere or gradient table).</p>
<p class="rubric">Notes</p>
<p>This class is meant to be used as a mix-in:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MyModel</span><span class="p">(</span><span class="n">Model</span><span class="p">,</span> <span class="n">Cache</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">MyModelFit</span><span class="p">(</span><span class="n">Fit</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>Inside a method on the fit, typical usage would be:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">odf</span><span class="p">(</span><span class="n">sphere</span><span class="p">):</span>
    <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">cache_get</span><span class="p">(</span><span class="s">&#39;odf_basis_matrix&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sphere</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">M</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_basis_matrix</span><span class="p">(</span><span class="n">sphere</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">cache_set</span><span class="p">(</span><span class="s">&#39;odf_basis_matrix&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sphere</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">M</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.cache.Cache.cache_clear" title="dipy.reconst.cache.Cache.cache_clear"><tt class="xref py py-obj docutils literal"><span class="pre">cache_clear</span></tt></a>()</td>
<td>Clear the cache.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.cache.Cache.cache_get" title="dipy.reconst.cache.Cache.cache_get"><tt class="xref py py-obj docutils literal"><span class="pre">cache_get</span></tt></a>(tag,&nbsp;key[,&nbsp;default])</td>
<td>Retrieve a value from the cache.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.cache.Cache.cache_set" title="dipy.reconst.cache.Cache.cache_set"><tt class="xref py py-obj docutils literal"><span class="pre">cache_set</span></tt></a>(tag,&nbsp;key,&nbsp;value)</td>
<td>Store a value in the cache.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.cache.Cache.__init__">
<tt class="descname">__init__</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.cache.Cache.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.cache.Cache.cache_clear">
<tt class="descname">cache_clear</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.cache.Cache.cache_clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear the cache.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.cache.Cache.cache_get">
<tt class="descname">cache_get</tt><big>(</big><em>tag</em>, <em>key</em>, <em>default=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.cache.Cache.cache_get" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a value from the cache.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>tag</strong> : str</p>
<blockquote>
<div><p>Description of the cached value.</p>
</div></blockquote>
<p><strong>key</strong> : object</p>
<blockquote>
<div><p>Key object used to look up the cached value.</p>
</div></blockquote>
<p><strong>default</strong> : object</p>
<blockquote>
<div><p>Value to be returned if no cached entry is found.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>v</strong> : object</p>
<blockquote class="last">
<div><p>Value from the cache associated with <tt class="docutils literal"><span class="pre">(tag,</span> <span class="pre">key)</span></tt>.  Returns
<cite>default</cite> if no cached entry is found.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.cache.Cache.cache_set">
<tt class="descname">cache_set</tt><big>(</big><em>tag</em>, <em>key</em>, <em>value</em><big>)</big><a class="headerlink" href="#dipy.reconst.cache.Cache.cache_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Store a value in the cache.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>tag</strong> : str</p>
<blockquote>
<div><p>Description of the cached value.</p>
</div></blockquote>
<p><strong>key</strong> : object</p>
<blockquote>
<div><p>Key object used to look up the cached value.</p>
</div></blockquote>
<p><strong>value</strong> : object</p>
<blockquote class="last">
<div><p>Value stored in the cache for each unique combination
of <tt class="docutils literal"><span class="pre">(tag,</span> <span class="pre">key)</span></tt>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">compute_expensive_matrix</span><span class="p">(</span><span class="n">parameters</span><span class="p">):</span>
<span class="gp">... </span>    <span class="c"># Imagine the following computation is very expensive</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Cache</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">parameters</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X1</span> <span class="o">=</span> <span class="n">compute_expensive_matrix</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">cache_set</span><span class="p">(</span><span class="s">&#39;expensive_matrix&#39;</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">X1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X2</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">cache_get</span><span class="p">(</span><span class="s">&#39;expensive_matrix&#39;</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">X1</span> <span class="ow">is</span> <span class="n">X2</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="auto-attr">
<h3>auto_attr<a class="headerlink" href="#auto-attr" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.cache.auto_attr">
<tt class="descclassname">dipy.reconst.cache.</tt><tt class="descname">auto_attr</tt><big>(</big><em>func</em><big>)</big><a class="headerlink" href="#dipy.reconst.cache.auto_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator to create OneTimeProperty attributes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>func</strong> : method</p>
<blockquote class="last">
<div><p>The method that will be called the first time to compute a value.
Afterwards, the method&#8217;s name will be a standard attribute holding the
value of this computation.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MagicProp</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nd">@auto_attr</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">a</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">99</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">MagicProp</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s">&#39;a&#39;</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">__dict__</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">a</span>
<span class="go">99</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s">&#39;a&#39;</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">__dict__</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="range">
<h3><a class="reference internal" href="#dipy.reconst.cross_validation.range" title="dipy.reconst.cross_validation.range"><tt class="xref py py-class docutils literal"><span class="pre">range</span></tt></a><a class="headerlink" href="#range" title="Permalink to this headline">¶</a></h3>
<dl class="attribute">
<dt id="dipy.reconst.cross_validation.range">
<tt class="descclassname">dipy.reconst.cross_validation.</tt><tt class="descname">range</tt><a class="headerlink" href="#dipy.reconst.cross_validation.range" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <tt class="xref py py-class docutils literal"><span class="pre">xrange</span></tt></p>
</dd></dl>

</div>
<div class="section" id="coeff-of-determination">
<h3>coeff_of_determination<a class="headerlink" href="#coeff-of-determination" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.cross_validation.coeff_of_determination">
<tt class="descclassname">dipy.reconst.cross_validation.</tt><tt class="descname">coeff_of_determination</tt><big>(</big><em>data</em>, <em>model</em>, <em>axis=-1</em><big>)</big><a class="headerlink" href="#dipy.reconst.cross_validation.coeff_of_determination" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Calculate the coefficient of determination for a model prediction, relative
to data.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : ndarray</p>
<blockquote>
<div><blockquote>
<div><p>The data</p>
</div></blockquote>
<dl class="docutils">
<dt>model <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The predictions of a model for this data. Same shape as the data.</p>
</dd>
<dt>axis: int, optional</dt>
<dd><p class="first last">The axis along which different samples are laid out (default: -1).</p>
</dd>
</dl>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>COD</strong> : ndarray</p>
<blockquote class="last">
<div><p>The coefficient of determination. This has shape <cite>data.shape[:-1]</cite></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p>rac{SSE}{SSD})</p>
<blockquote>
<div>where SSE is the sum of the squared error between the model and the data
(sum of the squared residuals) and SSD is the sum of the squares of the
deviations of the data from the mean of the data (variance * N).</div></blockquote>
</dd></dl>

</div>
<div class="section" id="kfold-xval">
<h3>kfold_xval<a class="headerlink" href="#kfold-xval" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.cross_validation.kfold_xval">
<tt class="descclassname">dipy.reconst.cross_validation.</tt><tt class="descname">kfold_xval</tt><big>(</big><em>model</em>, <em>data</em>, <em>folds</em>, <em>*model_args</em>, <em>**model_kwargs</em><big>)</big><a class="headerlink" href="#dipy.reconst.cross_validation.kfold_xval" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform k-fold cross-validation to generate out-of-sample predictions for
each measurement.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>model</strong> : Model class instance</p>
<blockquote>
<div><p>The type of the model to use for prediction. The corresponding Fit
object must have a <cite>predict</cite> function implementd One of the following:
<cite>reconst.dti.TensorModel</cite> or
<cite>reconst.csdeconv.ConstrainedSphericalDeconvModel</cite>.</p>
</div></blockquote>
<p><strong>data</strong> : ndarray</p>
<blockquote>
<div><p>Diffusion MRI data acquired with the GradientTable of the model. Shape
will typically be <cite>(x, y, z, b)</cite> where <cite>xyz</cite> are spatial dimensions and
b is the number of bvals/bvecs in the GradientTable.</p>
</div></blockquote>
<p><strong>folds</strong> : int</p>
<blockquote>
<div><p>The number of divisions to apply to the data</p>
</div></blockquote>
<p><strong>model_args</strong> : list</p>
<blockquote>
<div><p>Additional arguments to the model initialization</p>
</div></blockquote>
<p><strong>model_kwargs</strong> : dict</p>
<blockquote class="last">
<div><p>Additional key-word arguments to the model initialization</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This function assumes that a prediction API is implemented in the Model
class for which prediction is conducted. That is, the Fit object that gets
generated upon fitting the model needs to have a <cite>predict</cite> method, which
receives a GradientTable class instance as input and produces a predicted
signal as output.</p>
<p>It also assumes that the model object has <cite>bval</cite> and <cite>bvec</cite> attributes
holding b-values and corresponding unit vectors.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r78" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id36">[R78]</a></td><td>Rokem, A., Chan, K.L. Yeatman, J.D., Pestilli, F., Mezer, A.,
Wandell, B.A., 2014. Evaluating the accuracy of diffusion models at
multiple b-values with cross-validation. ISMRM 2014.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="axsymshresponse">
<h3><a class="reference internal" href="#dipy.reconst.csdeconv.AxSymShResponse" title="dipy.reconst.csdeconv.AxSymShResponse"><tt class="xref py py-class docutils literal"><span class="pre">AxSymShResponse</span></tt></a><a class="headerlink" href="#axsymshresponse" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.csdeconv.AxSymShResponse">
<em class="property">class </em><tt class="descclassname">dipy.reconst.csdeconv.</tt><tt class="descname">AxSymShResponse</tt><big>(</big><em>S0</em>, <em>dwi_response</em>, <em>bvalue=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.csdeconv.AxSymShResponse" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></a></p>
<p>A simple wrapper for response functions represented using only axially
symmetric, even spherical harmonic functions (ie, m == 0 and n even).</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.csdeconv.AxSymShResponse.basis" title="dipy.reconst.csdeconv.AxSymShResponse.basis"><tt class="xref py py-obj docutils literal"><span class="pre">basis</span></tt></a>(sphere)</td>
<td>A basis that maps the response coefficients onto a sphere.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.csdeconv.AxSymShResponse.on_sphere" title="dipy.reconst.csdeconv.AxSymShResponse.on_sphere"><tt class="xref py py-obj docutils literal"><span class="pre">on_sphere</span></tt></a>(sphere)</td>
<td>Evaluates the response function on sphere.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.csdeconv.AxSymShResponse.__init__">
<tt class="descname">__init__</tt><big>(</big><em>S0</em>, <em>dwi_response</em>, <em>bvalue=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.csdeconv.AxSymShResponse.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.reconst.csdeconv.AxSymShResponse.basis">
<tt class="descname">basis</tt><big>(</big><em>sphere</em><big>)</big><a class="headerlink" href="#dipy.reconst.csdeconv.AxSymShResponse.basis" title="Permalink to this definition">¶</a></dt>
<dd><p>A basis that maps the response coefficients onto a sphere.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.csdeconv.AxSymShResponse.on_sphere">
<tt class="descname">on_sphere</tt><big>(</big><em>sphere</em><big>)</big><a class="headerlink" href="#dipy.reconst.csdeconv.AxSymShResponse.on_sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates the response function on sphere.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="constrainedsdtmodel">
<h3><a class="reference internal" href="#dipy.reconst.csdeconv.ConstrainedSDTModel" title="dipy.reconst.csdeconv.ConstrainedSDTModel"><tt class="xref py py-class docutils literal"><span class="pre">ConstrainedSDTModel</span></tt></a><a class="headerlink" href="#constrainedsdtmodel" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.csdeconv.ConstrainedSDTModel">
<em class="property">class </em><tt class="descclassname">dipy.reconst.csdeconv.</tt><tt class="descname">ConstrainedSDTModel</tt><big>(</big><em>gtab</em>, <em>ratio</em>, <em>reg_sphere=None</em>, <em>sh_order=8</em>, <em>lambda_=1.0</em>, <em>tau=0.1</em><big>)</big><a class="headerlink" href="#dipy.reconst.csdeconv.ConstrainedSDTModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.shm.SphHarmModel" title="dipy.reconst.shm.SphHarmModel"><tt class="xref py py-class docutils literal"><span class="pre">dipy.reconst.shm.SphHarmModel</span></tt></a></p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">cache_clear</span></tt>()</td>
<td>Clear the cache.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">cache_get</span></tt>(tag,&nbsp;key[,&nbsp;default])</td>
<td>Retrieve a value from the cache.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">cache_set</span></tt>(tag,&nbsp;key,&nbsp;value)</td>
<td>Store a value in the cache.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.csdeconv.ConstrainedSDTModel.fit" title="dipy.reconst.csdeconv.ConstrainedSDTModel.fit"><tt class="xref py py-obj docutils literal"><span class="pre">fit</span></tt></a>(data[,&nbsp;mask])</td>
<td>Fit method for every voxel in data</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">sampling_matrix</span></tt>(sphere)</td>
<td>The matrix needed to sample ODFs from coefficients of the model.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.csdeconv.ConstrainedSDTModel.__init__">
<tt class="descname">__init__</tt><big>(</big><em>gtab</em>, <em>ratio</em>, <em>reg_sphere=None</em>, <em>sh_order=8</em>, <em>lambda_=1.0</em>, <em>tau=0.1</em><big>)</big><a class="headerlink" href="#dipy.reconst.csdeconv.ConstrainedSDTModel.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Spherical Deconvolution Transform (SDT) <a class="reference internal" href="#r79" id="id37">[R79]</a>.</p>
<p>The SDT computes a fiber orientation distribution (FOD) as opposed to a
diffusion ODF as the QballModel or the CsaOdfModel. This results in a
sharper angular profile with better angular resolution. The Constrained
SDTModel is similar to the Constrained CSDModel but mathematically it
deconvolves the q-ball ODF as oppposed to the HARDI signal (see <a class="reference internal" href="#r79" id="id38">[R79]</a>
for a comparison and a through discussion).</p>
<p>A sharp fODF is obtained because a single fiber <em>response</em> function is
injected as <em>a priori</em> knowledge. In the SDTModel, this response is a
single fiber q-ball ODF as opposed to a single fiber signal function
for the CSDModel. The response function will be used as deconvolution
kernel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>gtab</strong> : GradientTable</p>
<p><strong>ratio</strong> : float</p>
<blockquote>
<div><p>ratio of the smallest vs the largest eigenvalue of the single
prolate tensor response function</p>
</div></blockquote>
<p><strong>reg_sphere</strong> : Sphere</p>
<blockquote>
<div><p>sphere used to build the regularization B matrix</p>
</div></blockquote>
<p><strong>sh_order</strong> : int</p>
<blockquote>
<div><p>maximal spherical harmonics order</p>
</div></blockquote>
<p><strong>lambda_</strong> : float</p>
<blockquote>
<div><p>weight given to the constrained-positivity regularization part of the
deconvolution equation</p>
</div></blockquote>
<p><strong>tau</strong> : float</p>
<blockquote class="last">
<div><p>threshold (tau <a href="#id39"><span class="problematic" id="id40">*</span></a>mean(fODF)) controlling the amplitude below
which the corresponding fODF is assumed to be zero.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r79" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R79]</td><td><em>(<a class="fn-backref" href="#id37">1</a>, <a class="fn-backref" href="#id38">2</a>, <a class="fn-backref" href="#id41">3</a>)</em> Descoteaux, M., et al. IEEE TMI 2009. Deterministic and
Probabilistic Tractography Based on Complex Fibre Orientation
Distributions.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.csdeconv.ConstrainedSDTModel.fit">
<tt class="descname">fit</tt><big>(</big><em>data</em>, <em>mask=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.csdeconv.ConstrainedSDTModel.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id42">
<h3><a class="reference internal" href="#dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel" title="dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel"><tt class="xref py py-class docutils literal"><span class="pre">ConstrainedSphericalDeconvModel</span></tt></a><a class="headerlink" href="#id42" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel">
<em class="property">class </em><tt class="descclassname">dipy.reconst.csdeconv.</tt><tt class="descname">ConstrainedSphericalDeconvModel</tt><big>(</big><em>gtab</em>, <em>response</em>, <em>reg_sphere=None</em>, <em>sh_order=8</em>, <em>lambda_=1</em>, <em>tau=0.1</em><big>)</big><a class="headerlink" href="#dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.shm.SphHarmModel" title="dipy.reconst.shm.SphHarmModel"><tt class="xref py py-class docutils literal"><span class="pre">dipy.reconst.shm.SphHarmModel</span></tt></a></p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">cache_clear</span></tt>()</td>
<td>Clear the cache.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">cache_get</span></tt>(tag,&nbsp;key[,&nbsp;default])</td>
<td>Retrieve a value from the cache.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">cache_set</span></tt>(tag,&nbsp;key,&nbsp;value)</td>
<td>Store a value in the cache.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.fit" title="dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.fit"><tt class="xref py py-obj docutils literal"><span class="pre">fit</span></tt></a>(data[,&nbsp;mask])</td>
<td>Fit method for every voxel in data</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.predict" title="dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.predict"><tt class="xref py py-obj docutils literal"><span class="pre">predict</span></tt></a>(sh_coeff[,&nbsp;gtab,&nbsp;S0])</td>
<td>Compute a signal prediction given spherical harmonic coefficients for the provided GradientTable class instance.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">sampling_matrix</span></tt>(sphere)</td>
<td>The matrix needed to sample ODFs from coefficients of the model.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.__init__">
<tt class="descname">__init__</tt><big>(</big><em>gtab</em>, <em>response</em>, <em>reg_sphere=None</em>, <em>sh_order=8</em>, <em>lambda_=1</em>, <em>tau=0.1</em><big>)</big><a class="headerlink" href="#dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constrained Spherical Deconvolution (CSD) <a class="reference internal" href="#r80" id="id43">[R80]</a>.</p>
<p>Spherical deconvolution computes a fiber orientation distribution
(FOD), also called fiber ODF (fODF) <a class="reference internal" href="#r81" id="id44">[R81]</a>, as opposed to a diffusion ODF
as the QballModel or the CsaOdfModel. This results in a sharper angular
profile with better angular resolution that is the best object to be
used for later deterministic and probabilistic tractography <a class="reference internal" href="#r82" id="id45">[R82]</a>.</p>
<p>A sharp fODF is obtained because a single fiber <em>response</em> function is
injected as <em>a priori</em> knowledge. The response function is often
data-driven and is thus provided as input to the
ConstrainedSphericalDeconvModel. It will be used as deconvolution
kernel, as described in <a class="reference internal" href="#r80" id="id46">[R80]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>gtab</strong> : GradientTable</p>
<p><strong>response</strong> : tuple or AxSymShResponse object</p>
<blockquote>
<div><p>A tuple with two elements. The first is the eigen-values as an (3,)
ndarray and the second is the signal value for the response
function without diffusion weighting.  This is to be able to
generate a single fiber synthetic signal. The response function
will be used as deconvolution kernel (<a class="reference internal" href="#r80" id="id47">[R80]</a>)</p>
</div></blockquote>
<p><strong>reg_sphere</strong> : Sphere (optional)</p>
<blockquote>
<div><p>sphere used to build the regularization B matrix.
Default: &#8216;symmetric362&#8217;.</p>
</div></blockquote>
<p><strong>sh_order</strong> : int (optional)</p>
<blockquote>
<div><p>maximal spherical harmonics order. Default: 8</p>
</div></blockquote>
<p><strong>lambda_</strong> : float (optional)</p>
<blockquote>
<div><p>weight given to the constrained-positivity regularization part of the
deconvolution equation (see <a class="reference internal" href="#r80" id="id48">[R80]</a>). Default: 1</p>
</div></blockquote>
<p><strong>tau</strong> : float (optional)</p>
<blockquote class="last">
<div><p>threshold controlling the amplitude below which the corresponding
fODF is assumed to be zero.  Ideally, tau should be set to
zero. However, to improve the stability of the algorithm, tau is
set to tau*100 % of the mean fODF amplitude (here, 10% by default)
(see <a class="reference internal" href="#r80" id="id49">[R80]</a>). Default: 0.1</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r80" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R80]</td><td><em>(<a class="fn-backref" href="#id43">1</a>, <a class="fn-backref" href="#id46">2</a>, <a class="fn-backref" href="#id47">3</a>, <a class="fn-backref" href="#id48">4</a>, <a class="fn-backref" href="#id49">5</a>, <a class="fn-backref" href="#id50">6</a>)</em> Tournier, J.D., et al. NeuroImage 2007. Robust determination of
the fibre orientation distribution in diffusion MRI:
Non-negativity constrained super-resolved spherical
deconvolution</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r81" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R81]</td><td><em>(<a class="fn-backref" href="#id44">1</a>, <a class="fn-backref" href="#id51">2</a>)</em> Descoteaux, M., et al. IEEE TMI 2009. Deterministic and
Probabilistic Tractography Based on Complex Fibre Orientation
Distributions</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r82" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R82]</td><td><em>(<a class="fn-backref" href="#id45">1</a>, <a class="fn-backref" href="#id52">2</a>)</em> C^ot&#8217;e, M-A., et al. Medical Image Analysis 2013. Tractometer:
Towards validation of tractography pipelines</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r83" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id53">[R83]</a></td><td>Tournier, J.D, et al. Imaging Systems and Technology
2012. MRtrix: Diffusion Tractography in Crossing Fiber Regions</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.fit">
<tt class="descname">fit</tt><big>(</big><em>data</em>, <em>mask=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.predict">
<tt class="descname">predict</tt><big>(</big><em>sh_coeff</em>, <em>gtab=None</em>, <em>S0=1</em><big>)</big><a class="headerlink" href="#dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a signal prediction given spherical harmonic coefficients
for the provided GradientTable class instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sh_coeff</strong> : ndarray</p>
<blockquote>
<div><p>The spherical harmonic representation of the FOD from which to make
the signal prediction.</p>
</div></blockquote>
<p><strong>gtab</strong> : GradientTable</p>
<blockquote>
<div><p>The gradients for which the signal will be predicted. Use the
model&#8217;s gradient table by default.</p>
</div></blockquote>
<p><strong>S0</strong> : ndarray or float</p>
<blockquote>
<div><p>The non diffusion-weighted signal value.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>pred_sig</strong> : ndarray</p>
<blockquote class="last">
<div><p>The predicted signal.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="sphharmfit">
<h3><a class="reference internal" href="#dipy.reconst.csdeconv.SphHarmFit" title="dipy.reconst.csdeconv.SphHarmFit"><tt class="xref py py-class docutils literal"><span class="pre">SphHarmFit</span></tt></a><a class="headerlink" href="#sphharmfit" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.csdeconv.SphHarmFit">
<em class="property">class </em><tt class="descclassname">dipy.reconst.csdeconv.</tt><tt class="descname">SphHarmFit</tt><big>(</big><em>model</em>, <em>shm_coef</em>, <em>mask</em><big>)</big><a class="headerlink" href="#dipy.reconst.csdeconv.SphHarmFit" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.odf.OdfFit" title="dipy.reconst.odf.OdfFit"><tt class="xref py py-class docutils literal"><span class="pre">dipy.reconst.odf.OdfFit</span></tt></a></p>
<p>Diffusion data fit to a spherical harmonic model</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.csdeconv.SphHarmFit.gfa" title="dipy.reconst.csdeconv.SphHarmFit.gfa"><tt class="xref py py-obj docutils literal"><span class="pre">gfa</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.csdeconv.SphHarmFit.odf" title="dipy.reconst.csdeconv.SphHarmFit.odf"><tt class="xref py py-obj docutils literal"><span class="pre">odf</span></tt></a>(sphere)</td>
<td>Samples the odf function on the points of a sphere</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.csdeconv.SphHarmFit.predict" title="dipy.reconst.csdeconv.SphHarmFit.predict"><tt class="xref py py-obj docutils literal"><span class="pre">predict</span></tt></a>([gtab,&nbsp;S0])</td>
<td>Predict the diffusion signal from the model coefficients.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.csdeconv.SphHarmFit.__init__">
<tt class="descname">__init__</tt><big>(</big><em>model</em>, <em>shm_coef</em>, <em>mask</em><big>)</big><a class="headerlink" href="#dipy.reconst.csdeconv.SphHarmFit.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="dipy.reconst.csdeconv.SphHarmFit.gfa">
<em class="property">static </em><tt class="descname">gfa</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.csdeconv.SphHarmFit.gfa" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.reconst.csdeconv.SphHarmFit.odf">
<tt class="descname">odf</tt><big>(</big><em>sphere</em><big>)</big><a class="headerlink" href="#dipy.reconst.csdeconv.SphHarmFit.odf" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples the odf function on the points of a sphere</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sphere</strong> : Sphere</p>
<blockquote>
<div><p>The points on which to sample the odf.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>values</strong> : ndarray</p>
<blockquote class="last">
<div><p>The value of the odf on each point of <cite>sphere</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.csdeconv.SphHarmFit.predict">
<tt class="descname">predict</tt><big>(</big><em>gtab=None</em>, <em>S0=1.0</em><big>)</big><a class="headerlink" href="#dipy.reconst.csdeconv.SphHarmFit.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict the diffusion signal from the model coefficients.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>gtab</strong> : a GradientTable class instance</p>
<blockquote>
<div><p>The directions and bvalues on which prediction is desired</p>
</div></blockquote>
<p><strong>S0</strong> : float array</p>
<blockquote class="last">
<div><p>The mean non-diffusion-weighted signal in each voxel.
Default: 1.0 in all voxels</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.csdeconv.SphHarmFit.shape">
<tt class="descname">shape</tt><a class="headerlink" href="#dipy.reconst.csdeconv.SphHarmFit.shape" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.csdeconv.SphHarmFit.shm_coeff">
<tt class="descname">shm_coeff</tt><a class="headerlink" href="#dipy.reconst.csdeconv.SphHarmFit.shm_coeff" title="Permalink to this definition">¶</a></dt>
<dd><p>The spherical harmonic coefficients of the odf</p>
<p>Make this a property for now, if there is a usecase for modifying
the coefficients we can add a setter or expose the coefficients more
directly</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="sphharmmodel">
<h3><a class="reference internal" href="#dipy.reconst.csdeconv.SphHarmModel" title="dipy.reconst.csdeconv.SphHarmModel"><tt class="xref py py-class docutils literal"><span class="pre">SphHarmModel</span></tt></a><a class="headerlink" href="#sphharmmodel" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.csdeconv.SphHarmModel">
<em class="property">class </em><tt class="descclassname">dipy.reconst.csdeconv.</tt><tt class="descname">SphHarmModel</tt><big>(</big><em>gtab</em><big>)</big><a class="headerlink" href="#dipy.reconst.csdeconv.SphHarmModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.odf.OdfModel" title="dipy.reconst.odf.OdfModel"><tt class="xref py py-class docutils literal"><span class="pre">dipy.reconst.odf.OdfModel</span></tt></a>, <a class="reference internal" href="#dipy.reconst.cache.Cache" title="dipy.reconst.cache.Cache"><tt class="xref py py-class docutils literal"><span class="pre">dipy.reconst.cache.Cache</span></tt></a></p>
<p>To be subclassed by all models that return a SphHarmFit when fit.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">cache_clear</span></tt>()</td>
<td>Clear the cache.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">cache_get</span></tt>(tag,&nbsp;key[,&nbsp;default])</td>
<td>Retrieve a value from the cache.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">cache_set</span></tt>(tag,&nbsp;key,&nbsp;value)</td>
<td>Store a value in the cache.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">fit</span></tt>(data)</td>
<td>To be implemented by specific odf models</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.csdeconv.SphHarmModel.sampling_matrix" title="dipy.reconst.csdeconv.SphHarmModel.sampling_matrix"><tt class="xref py py-obj docutils literal"><span class="pre">sampling_matrix</span></tt></a>(sphere)</td>
<td>The matrix needed to sample ODFs from coefficients of the model.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.csdeconv.SphHarmModel.__init__">
<tt class="descname">__init__</tt><big>(</big><em>gtab</em><big>)</big><a class="headerlink" href="#dipy.reconst.csdeconv.SphHarmModel.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.reconst.csdeconv.SphHarmModel.sampling_matrix">
<tt class="descname">sampling_matrix</tt><big>(</big><em>sphere</em><big>)</big><a class="headerlink" href="#dipy.reconst.csdeconv.SphHarmModel.sampling_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>The matrix needed to sample ODFs from coefficients of the model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sphere</strong> : Sphere</p>
<blockquote>
<div><p>Points used to sample ODF.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>sampling_matrix</strong> : array</p>
<blockquote class="last">
<div><p>The size of the matrix will be (N, M) where N is the number of
vertices on sphere and M is the number of coefficients needed by
the model.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="tensormodel">
<h3><a class="reference internal" href="#dipy.reconst.csdeconv.TensorModel" title="dipy.reconst.csdeconv.TensorModel"><tt class="xref py py-class docutils literal"><span class="pre">TensorModel</span></tt></a><a class="headerlink" href="#tensormodel" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.csdeconv.TensorModel">
<em class="property">class </em><tt class="descclassname">dipy.reconst.csdeconv.</tt><tt class="descname">TensorModel</tt><big>(</big><em>gtab</em>, <em>fit_method='WLS'</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#dipy.reconst.csdeconv.TensorModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><tt class="xref py py-class docutils literal"><span class="pre">dipy.reconst.base.ReconstModel</span></tt></a></p>
<p>Diffusion Tensor</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.csdeconv.TensorModel.fit" title="dipy.reconst.csdeconv.TensorModel.fit"><tt class="xref py py-obj docutils literal"><span class="pre">fit</span></tt></a>(data[,&nbsp;mask])</td>
<td>Fit method of the DTI model class</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.csdeconv.TensorModel.predict" title="dipy.reconst.csdeconv.TensorModel.predict"><tt class="xref py py-obj docutils literal"><span class="pre">predict</span></tt></a>(dti_params[,&nbsp;S0])</td>
<td>Predict a signal for this TensorModel class instance given parameters.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.csdeconv.TensorModel.__init__">
<tt class="descname">__init__</tt><big>(</big><em>gtab</em>, <em>fit_method='WLS'</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#dipy.reconst.csdeconv.TensorModel.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>A Diffusion Tensor Model <a class="reference internal" href="#r84" id="id54">[R84]</a>, <a class="reference internal" href="#r85" id="id55">[R85]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>gtab</strong> : GradientTable class instance</p>
<p><strong>fit_method</strong> : str or callable</p>
<blockquote>
<div><p>str can be one of the following:
&#8216;WLS&#8217; for weighted least squares</p>
<blockquote>
<div><p>dti.wls_fit_tensor</p>
</div></blockquote>
<dl class="docutils">
<dt>&#8216;LS&#8217; or &#8216;OLS&#8217; for ordinary least squares</dt>
<dd><p class="first last">dti.ols_fit_tensor</p>
</dd>
<dt>&#8216;NLLS&#8217; for non-linear least-squares</dt>
<dd><p class="first last">dti.nlls_fit_tensor</p>
</dd>
<dt>&#8216;RT&#8217; or &#8216;restore&#8217; or &#8216;RESTORE&#8217; for RESTORE robust tensor fitting <a class="reference internal" href="#r86" id="id56">[R86]</a></dt>
<dd><p class="first last">dti.restore_fit_tensor</p>
</dd>
<dt>callable has to have the signature:</dt>
<dd><p class="first last">fit_method(design_matrix, data, <a href="#id57"><span class="problematic" id="id58">*</span></a>args, <a href="#id59"><span class="problematic" id="id60">**</span></a>kwargs)</p>
</dd>
</dl>
</div></blockquote>
<p><strong>args, kwargs</strong> : arguments and key-word arguments passed to the</p>
<blockquote>
<div><p>fit_method. See dti.wls_fit_tensor, dti.ols_fit_tensor for details</p>
</div></blockquote>
<p><strong>min_signal</strong> : float</p>
<blockquote class="last">
<div><p>The minimum signal value. Needs to be a strictly positive
number. Default: minimal signal in the data provided to <cite>fit</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r84" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R84]</td><td><em>(<a class="fn-backref" href="#id54">1</a>, <a class="fn-backref" href="#id61">2</a>)</em> Basser, P.J., Mattiello, J., LeBihan, D., 1994. Estimation of
the effective self-diffusion tensor from the NMR spin echo. J Magn
Reson B 103, 247-254.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r85" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R85]</td><td><em>(<a class="fn-backref" href="#id55">1</a>, <a class="fn-backref" href="#id62">2</a>)</em> Basser, P., Pierpaoli, C., 1996. Microstructural and
physiological features of tissues elucidated by quantitative
diffusion-tensor MRI.  Journal of Magnetic Resonance 111, 209-219.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r86" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R86]</td><td><em>(<a class="fn-backref" href="#id56">1</a>, <a class="fn-backref" href="#id63">2</a>)</em> Lin-Ching C., Jones D.K., Pierpaoli, C. 2005. RESTORE: Robust
estimation of tensors by outlier rejection. MRM 53: 1088-1095</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.csdeconv.TensorModel.fit">
<tt class="descname">fit</tt><big>(</big><em>data</em>, <em>mask=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.csdeconv.TensorModel.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit method of the DTI model class</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : array</p>
<blockquote>
<div><p>The measured signal from one voxel.</p>
</div></blockquote>
<p><strong>mask</strong> : array</p>
<blockquote class="last">
<div><p>A boolean array used to mark the coordinates in the data that
should be analyzed that has the shape data.shape[:-1]</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.csdeconv.TensorModel.predict">
<tt class="descname">predict</tt><big>(</big><em>dti_params</em>, <em>S0=1</em><big>)</big><a class="headerlink" href="#dipy.reconst.csdeconv.TensorModel.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict a signal for this TensorModel class instance given parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dti_params</strong> : ndarray</p>
<blockquote>
<div><p>The last dimension should have 12 tensor parameters: 3
eigenvalues, followed by the 3 eigenvectors</p>
</div></blockquote>
<p><strong>S0</strong> : float or ndarray</p>
<blockquote class="last">
<div><p>The non diffusion-weighted signal in every voxel, or across all
voxels. Default: 1</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id64">
<h3><a class="reference internal" href="#dipy.reconst.csdeconv.range" title="dipy.reconst.csdeconv.range"><tt class="xref py py-class docutils literal"><span class="pre">range</span></tt></a><a class="headerlink" href="#id64" title="Permalink to this headline">¶</a></h3>
<dl class="attribute">
<dt id="dipy.reconst.csdeconv.range">
<tt class="descclassname">dipy.reconst.csdeconv.</tt><tt class="descname">range</tt><a class="headerlink" href="#dipy.reconst.csdeconv.range" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <tt class="xref py py-class docutils literal"><span class="pre">xrange</span></tt></p>
</dd></dl>

</div>
<div class="section" id="auto-response">
<h3>auto_response<a class="headerlink" href="#auto-response" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.auto_response">
<tt class="descclassname">dipy.reconst.csdeconv.</tt><tt class="descname">auto_response</tt><big>(</big><em>gtab</em>, <em>data</em>, <em>roi_center=None</em>, <em>roi_radius=10</em>, <em>fa_thr=0.7</em>, <em>return_number_of_voxels=False</em><big>)</big><a class="headerlink" href="#dipy.reconst.csdeconv.auto_response" title="Permalink to this definition">¶</a></dt>
<dd><p>Automatic estimation of response function using FA.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>gtab</strong> : GradientTable</p>
<p><strong>data</strong> : ndarray</p>
<blockquote>
<div><p>diffusion data</p>
</div></blockquote>
<p><strong>roi_center</strong> : tuple, (3,)</p>
<blockquote>
<div><p>Center of ROI in data. If center is None, it is assumed that it is
the center of the volume with shape <cite>data.shape[:3]</cite>.</p>
</div></blockquote>
<p><strong>roi_radius</strong> : int</p>
<blockquote>
<div><p>radius of cubic ROI</p>
</div></blockquote>
<p><strong>fa_thr</strong> : float</p>
<blockquote>
<div><p>FA threshold</p>
</div></blockquote>
<p><strong>return_number_of_voxels</strong> : bool</p>
<blockquote>
<div><p>If True, returns the number of voxels used for estimating the response
function.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>response</strong> : tuple, (2,)</p>
<blockquote>
<div><p>(<cite>evals</cite>, <cite>S0</cite>)</p>
</div></blockquote>
<p><strong>ratio</strong> : float</p>
<blockquote>
<div><p>The ratio between smallest versus largest eigenvalue of the response.</p>
</div></blockquote>
<p><strong>number of voxels</strong> : int (optional)</p>
<blockquote class="last">
<div><p>The number of voxels used for estimating the response function.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>In CSD there is an important pre-processing step: the estimation of the
fiber response function. In order to do this we look for voxels with very
anisotropic configurations. For example we can use an ROI (20x20x20) at
the center of the volume and store the signal values for the voxels with
FA values higher than 0.7. Of course, if we haven&#8217;t precalculated FA we
need to fit a Tensor model to the datasets. Which is what we do in this
function.</p>
<p>For the response we also need to find the average S0 in the ROI. This is
possible using <cite>gtab.b0s_mask()</cite> we can find all the S0 volumes (which
correspond to b-values equal 0) in the dataset.</p>
<p>The <cite>response</cite> consists always of a prolate tensor created by averaging
the highest and second highest eigenvalues in the ROI with FA higher than
threshold. We also include the average S0s.</p>
<p>We also return the <cite>ratio</cite> which is used for the SDT models. If requested,
the number of voxels used for estimating the response function is also
returned, which can be used to judge the fidelity of the response function.
As a rule of thumb, at least 300 voxels should be used to estimate a good
response function (see <a class="reference internal" href="#r87" id="id65">[R87]</a>).</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r87" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R87]</td><td><em>(<a class="fn-backref" href="#id65">1</a>, <a class="fn-backref" href="#id66">2</a>)</em> Tournier, J.D., et al. NeuroImage 2004. Direct estimation of the</td></tr>
</tbody>
</table>
<p>fiber orientation density function from diffusion-weighted MRI
data using spherical deconvolution</p>
</dd></dl>

</div>
<div class="section" id="cart2sphere">
<h3>cart2sphere<a class="headerlink" href="#cart2sphere" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.cart2sphere">
<tt class="descclassname">dipy.reconst.csdeconv.</tt><tt class="descname">cart2sphere</tt><big>(</big><em>x</em>, <em>y</em>, <em>z</em><big>)</big><a class="headerlink" href="#dipy.reconst.csdeconv.cart2sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Return angles for Cartesian 3D coordinates <cite>x</cite>, <cite>y</cite>, and <cite>z</cite></p>
<p>See doc for <tt class="docutils literal"><span class="pre">sphere2cart</span></tt> for angle conventions and derivation
of the formulae.</p>
<p><span class="math">0\le\theta\mathrm{(theta)}\le\pi</span> and <span class="math">-\pi\le\phi\mathrm{(phi)}\le\pi</span></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x</strong> : array_like</p>
<blockquote>
<div><p>x coordinate in Cartesian space</p>
</div></blockquote>
<p><strong>y</strong> : array_like</p>
<blockquote>
<div><p>y coordinate in Cartesian space</p>
</div></blockquote>
<p><strong>z</strong> : array_like</p>
<blockquote>
<div><p>z coordinate</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>r</strong> : array</p>
<blockquote>
<div><p>radius</p>
</div></blockquote>
<p><strong>theta</strong> : array</p>
<blockquote>
<div><p>inclination (polar) angle</p>
</div></blockquote>
<p><strong>phi</strong> : array</p>
<blockquote class="last">
<div><p>azimuth angle</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="csdeconv">
<h3>csdeconv<a class="headerlink" href="#csdeconv" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.csdeconv">
<tt class="descclassname">dipy.reconst.csdeconv.</tt><tt class="descname">csdeconv</tt><big>(</big><em>dwsignal</em>, <em>X</em>, <em>B_reg</em>, <em>tau=0.1</em>, <em>convergence=50</em>, <em>P=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.csdeconv.csdeconv" title="Permalink to this definition">¶</a></dt>
<dd><p>Constrained-regularized spherical deconvolution (CSD) <a class="reference internal" href="#r88" id="id67">[R88]</a></p>
<p>Deconvolves the axially symmetric single fiber response function <cite>r_rh</cite> in
rotational harmonics coefficients from the diffusion weighted signal in
<cite>dwsignal</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dwsignal</strong> : array</p>
<blockquote>
<div><p>Diffusion weighted signals to be deconvolved.</p>
</div></blockquote>
<p><strong>X</strong> : array</p>
<blockquote>
<div><p>Prediction matrix which estimates diffusion weighted signals from FOD
coefficients.</p>
</div></blockquote>
<p><strong>B_reg</strong> : array (N, B)</p>
<blockquote>
<div><p>SH basis matrix which maps FOD coefficients to FOD values on the
surface of the sphere. B_reg should be scaled to account for lambda.</p>
</div></blockquote>
<p><strong>tau</strong> : float</p>
<blockquote>
<div><p>Threshold controlling the amplitude below which the corresponding fODF
is assumed to be zero.  Ideally, tau should be set to zero. However, to
improve the stability of the algorithm, tau is set to tau*100 % of the
max fODF amplitude (here, 10% by default). This is similar to peak
detection where peaks below 0.1 amplitude are usually considered noise
peaks. Because SDT is based on a q-ball ODF deconvolution, and not
signal deconvolution, using the max instead of mean (as in CSD), is
more stable.</p>
</div></blockquote>
<p><strong>convergence</strong> : int</p>
<blockquote>
<div><p>Maximum number of iterations to allow the deconvolution to converge.</p>
</div></blockquote>
<p><strong>P</strong> : ndarray</p>
<blockquote>
<div><p>This is an optimization to avoid computing <tt class="docutils literal"><span class="pre">dot(X.T,</span> <span class="pre">X)</span></tt> many times.
If the same <tt class="docutils literal"><span class="pre">X</span></tt> is used many times, <tt class="docutils literal"><span class="pre">P</span></tt> can be precomputed and
passed to this function.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fodf_sh</strong> : ndarray (<tt class="docutils literal"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)*(sh_order</span> <span class="pre">+</span> <span class="pre">2)/2</span></tt>,)</p>
<blockquote>
<div><p>Spherical harmonics coefficients of the constrained-regularized fiber
ODF.</p>
</div></blockquote>
<p><strong>num_it</strong> : int</p>
<blockquote class="last">
<div><p>Number of iterations in the constrained-regularization used for
convergence.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This section describes how the fitting of the SH coefficients is done.
Problem is to minimise per iteration:</p>
<p><span class="math">F(f_n) = ||Xf_n - S||^2 + \lambda^2 ||H_{n-1} f_n||^2</span></p>
<p>Where <span class="math">X</span> maps current FOD SH coefficients <span class="math">f_n</span> to DW signals <span class="math">s</span> and
<span class="math">H_{n-1}</span> maps FOD SH coefficients <span class="math">f_n</span> to amplitudes along set of negative
directions identified in previous iteration, i.e. the matrix formed by the
rows of <span class="math">B_{reg}</span> for which <span class="math">Hf_{n-1}&lt;0</span> where <span class="math">B_{reg}</span> maps <span class="math">f_n</span> to FOD
amplitude on a sphere.</p>
<p>Solve by differentiating and setting to zero:</p>
<p><span class="math">\Rightarrow \frac{\delta F}{\delta f_n} = 2X^T(Xf_n - S) + 2 \lambda^2
H_{n-1}^TH_{n-1}f_n=0</span></p>
<p>Or:</p>
<p><span class="math">(X^TX + \lambda^2 H_{n-1}^TH_{n-1})f_n = X^Ts</span></p>
<p>Define <span class="math">Q = X^TX + \lambda^2 H_{n-1}^TH_{n-1}</span> , which by construction is a
square positive definite symmetric matrix of size <span class="math">n_{SH} by n_{SH}</span>. If
needed, positive definiteness can be enforced with a small minimum norm
regulariser (helps a lot with poorly conditioned direction sets and/or
superresolution):</p>
<p><span class="math">Q = X^TX + (\lambda H_{n-1}^T) (\lambda H_{n-1}) + \mu I</span></p>
<p>Solve <span class="math">Qf_n = X^Ts</span> using Cholesky decomposition:</p>
<p><span class="math">Q = LL^T</span></p>
<p>where <span class="math">L</span> is lower triangular. Then problem can be solved by
back-substitution:</p>
<p><span class="math">L_y = X^Ts</span></p>
<p><span class="math">L^Tf_n = y</span></p>
<p>To speeds things up further, form <span class="math">P = X^TX + \mu I</span>, and update to form
<span class="math">Q</span> by rankn update with <span class="math">H_{n-1}</span>. The dipy implementation looks like:</p>
<blockquote>
<div><p>form initially <span class="math">P = X^T X + \mu I</span> and <span class="math">\lambda B_{reg}</span></p>
<p>for each voxel: form <span class="math">z = X^Ts</span></p>
<blockquote>
<div><p>estimate <span class="math">f_0</span> by solving <span class="math">Pf_0=z</span>. We use a simplified <span class="math">l_{max}=4</span>
solution here, but it might not make a big difference.</p>
<p>Then iterate until no change in rows of <span class="math">H</span> used in <span class="math">H_n</span></p>
<blockquote>
<div><p>form <span class="math">H_{n}</span> given <span class="math">f_{n-1}</span></p>
<p>form <span class="math">Q = P + (\lambda H_{n-1}^T) (\lambda H_{n-1}</span>) (this can
be done by rankn update, but we currently do not use rankn
update).</p>
<p>solve <span class="math">Qf_n = z</span> using Cholesky decomposition</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
<p>We&#8217;d like to thanks Donald Tournier for his help with describing and
implementing this algorithm.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r88" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R88]</td><td><em>(<a class="fn-backref" href="#id67">1</a>, <a class="fn-backref" href="#id68">2</a>)</em> Tournier, J.D., et al. NeuroImage 2007. Robust determination of the
fibre orientation distribution in diffusion MRI: Non-negativity
constrained super-resolved spherical deconvolution.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="estimate-response">
<h3>estimate_response<a class="headerlink" href="#estimate-response" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.estimate_response">
<tt class="descclassname">dipy.reconst.csdeconv.</tt><tt class="descname">estimate_response</tt><big>(</big><em>gtab</em>, <em>evals</em>, <em>S0</em><big>)</big><a class="headerlink" href="#dipy.reconst.csdeconv.estimate_response" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate single fiber response function</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>gtab</strong> : GradientTable</p>
<p><strong>evals</strong> : ndarray</p>
<p><strong>S0</strong> : float</p>
<blockquote>
<div><p>non diffusion weighted</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>S</strong> : estimated signal</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="fa-trace-to-lambdas">
<h3>fa_trace_to_lambdas<a class="headerlink" href="#fa-trace-to-lambdas" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.fa_trace_to_lambdas">
<tt class="descclassname">dipy.reconst.csdeconv.</tt><tt class="descname">fa_trace_to_lambdas</tt><big>(</big><em>fa=0.08</em>, <em>trace=0.0021</em><big>)</big><a class="headerlink" href="#dipy.reconst.csdeconv.fa_trace_to_lambdas" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="forward-sdeconv-mat">
<h3>forward_sdeconv_mat<a class="headerlink" href="#forward-sdeconv-mat" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.forward_sdeconv_mat">
<tt class="descclassname">dipy.reconst.csdeconv.</tt><tt class="descname">forward_sdeconv_mat</tt><big>(</big><em>r_rh</em>, <em>n</em><big>)</big><a class="headerlink" href="#dipy.reconst.csdeconv.forward_sdeconv_mat" title="Permalink to this definition">¶</a></dt>
<dd><p>Build forward spherical deconvolution matrix</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>r_rh</strong> : ndarray</p>
<blockquote>
<div><p>Rotational harmonics coefficients for the single fiber response
function. Each element <cite>rh[i]</cite> is associated with spherical harmonics
of degree <cite>2*i</cite>.</p>
</div></blockquote>
<p><strong>n</strong> : ndarray</p>
<blockquote>
<div><p>The degree of spherical harmonic function associated with each row of
the deconvolution matrix. Only even degrees are allowed</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>R</strong> : ndarray (N, N)</p>
<blockquote class="last">
<div><p>Deconvolution matrix with shape (N, N)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="forward-sdt-deconv-mat">
<h3>forward_sdt_deconv_mat<a class="headerlink" href="#forward-sdt-deconv-mat" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.forward_sdt_deconv_mat">
<tt class="descclassname">dipy.reconst.csdeconv.</tt><tt class="descname">forward_sdt_deconv_mat</tt><big>(</big><em>ratio</em>, <em>n</em>, <em>r2_term=False</em><big>)</big><a class="headerlink" href="#dipy.reconst.csdeconv.forward_sdt_deconv_mat" title="Permalink to this definition">¶</a></dt>
<dd><p>Build forward sharpening deconvolution transform (SDT) matrix</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ratio</strong> : float</p>
<blockquote>
<div><p>ratio = :math:<a href="#id69"><span class="problematic" id="id70">`</span></a></p>
</div></blockquote>
<p><strong>rac{lambda_2}{lambda_1}` of the single fiber response</strong> :</p>
<blockquote>
<div><blockquote>
<div><p>function</p>
</div></blockquote>
<dl class="docutils">
<dt>n <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (N,)</span></dt>
<dd><p class="first last">The degree of spherical harmonic function associated with each row of
the deconvolution matrix. Only even degrees are allowed.</p>
</dd>
<dt>r2_term <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">True if ODF comes from an ODF computed from a model using the <span class="math">r^2</span> term
in the integral. For example, DSI, GQI, SHORE, CSA, Tensor, Multi-tensor
ODFs. This results in using the proper analytical response function
solution solving from the single-fiber ODF with the r^2 term. This
derivation is not published anywhere but is very similar to [R89].</p>
</dd>
</dl>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>R</strong> : ndarray (N, N)</p>
<blockquote class="last">
<div><blockquote>
<div><p>SDT deconvolution matrix</p>
</div></blockquote>
<dl class="docutils">
<dt>P <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (N, N)</span></dt>
<dd><p class="first last">Funk-Radon Transform (FRT) matrix</p>
</dd>
</dl>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="fractional-anisotropy">
<h3>fractional_anisotropy<a class="headerlink" href="#fractional-anisotropy" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.fractional_anisotropy">
<tt class="descclassname">dipy.reconst.csdeconv.</tt><tt class="descname">fractional_anisotropy</tt><big>(</big><em>evals</em>, <em>axis=-1</em><big>)</big><a class="headerlink" href="#dipy.reconst.csdeconv.fractional_anisotropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Fractional anisotropy (FA) of a diffusion tensor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>evals</strong> : array-like</p>
<blockquote>
<div><p>Eigenvalues of a diffusion tensor.</p>
</div></blockquote>
<p><strong>axis</strong> : int</p>
<blockquote>
<div><p>Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fa</strong> : array</p>
<blockquote class="last">
<div><p>Calculated FA. Range is 0 &lt;= FA &lt;= 1.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>FA is calculated using the following equation:</p>
<div class="math">
<p><span class="math">FA = \sqrt{\frac{1}{2}\frac{(\lambda_1-\lambda_2)^2+(\lambda_1-
            \lambda_3)^2+(\lambda_2-\lambda_3)^2}{\lambda_1^2+
            \lambda_2^2+\lambda_3^2}}</span></p>
</div></dd></dl>

</div>
<div class="section" id="id72">
<h3>get_sphere<a class="headerlink" href="#id72" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.get_sphere">
<tt class="descclassname">dipy.reconst.csdeconv.</tt><tt class="descname">get_sphere</tt><big>(</big><em>name='symmetric362'</em><big>)</big><a class="headerlink" href="#dipy.reconst.csdeconv.get_sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>provide triangulated spheres</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>name</strong> : str</p>
<blockquote>
<div><p>which sphere - one of:
* &#8216;symmetric362&#8217;
* &#8216;symmetric642&#8217;
* &#8216;symmetric724&#8217;
* &#8216;repulsion724&#8217;
* &#8216;repulsion100&#8217;</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>sphere</strong> : a dipy.core.sphere.Sphere class instance</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.data</span> <span class="kn">import</span> <span class="n">get_sphere</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere</span> <span class="o">=</span> <span class="n">get_sphere</span><span class="p">(</span><span class="s">&#39;symmetric362&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span><span class="p">,</span> <span class="n">faces</span> <span class="o">=</span> <span class="n">sphere</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">sphere</span><span class="o">.</span><span class="n">faces</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(362, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">faces</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(720, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span><span class="p">,</span> <span class="n">faces</span> <span class="o">=</span> <span class="n">get_sphere</span><span class="p">(</span><span class="s">&#39;not a sphere name&#39;</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">DataError</span>: <span class="n">No sphere called &quot;not a sphere name&quot;</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="lazy-index">
<h3>lazy_index<a class="headerlink" href="#lazy-index" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.lazy_index">
<tt class="descclassname">dipy.reconst.csdeconv.</tt><tt class="descname">lazy_index</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#dipy.reconst.csdeconv.lazy_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Produces a lazy index</p>
<p>Returns a slice that can be used for indexing an array, if no slice can be
made index is returned as is.</p>
</dd></dl>

</div>
<div class="section" id="lpn">
<h3>lpn<a class="headerlink" href="#lpn" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.lpn">
<tt class="descclassname">dipy.reconst.csdeconv.</tt><tt class="descname">lpn</tt><big>(</big><em>n</em>, <em>z</em><big>)</big><a class="headerlink" href="#dipy.reconst.csdeconv.lpn" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute sequence of Legendre functions of the first kind (polynomials),
Pn(z) and derivatives for all degrees from 0 to n (inclusive).</p>
<p>See also special.legendre  for polynomial class.</p>
</dd></dl>

</div>
<div class="section" id="multi-voxel-fit">
<h3>multi_voxel_fit<a class="headerlink" href="#multi-voxel-fit" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.multi_voxel_fit">
<tt class="descclassname">dipy.reconst.csdeconv.</tt><tt class="descname">multi_voxel_fit</tt><big>(</big><em>single_voxel_fit</em><big>)</big><a class="headerlink" href="#dipy.reconst.csdeconv.multi_voxel_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Method decorator to turn a single voxel model fit
definition into a multi voxel model fit definition</p>
</dd></dl>

</div>
<div class="section" id="id73">
<h3>ndindex<a class="headerlink" href="#id73" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.ndindex">
<tt class="descclassname">dipy.reconst.csdeconv.</tt><tt class="descname">ndindex</tt><big>(</big><em>shape</em><big>)</big><a class="headerlink" href="#dipy.reconst.csdeconv.ndindex" title="Permalink to this definition">¶</a></dt>
<dd><p>An N-dimensional iterator object to index arrays.</p>
<p>Given the shape of an array, an <cite>ndindex</cite> instance iterates over
the N-dimensional index of the array. At each iteration a tuple
of indices is returned; the last dimension is iterated over first.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>shape</strong> : tuple of ints</p>
<blockquote class="last">
<div><p>The dimensions of the array.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.core.ndindex</span> <span class="kn">import</span> <span class="n">ndindex</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
<span class="go">(0, 0, 0)</span>
<span class="go">(0, 1, 0)</span>
<span class="go">(1, 0, 0)</span>
<span class="go">(1, 1, 0)</span>
<span class="go">(2, 0, 0)</span>
<span class="go">(2, 1, 0)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="odf-deconv">
<h3>odf_deconv<a class="headerlink" href="#odf-deconv" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.odf_deconv">
<tt class="descclassname">dipy.reconst.csdeconv.</tt><tt class="descname">odf_deconv</tt><big>(</big><em>odf_sh</em>, <em>R</em>, <em>B_reg</em>, <em>lambda_=1.0</em>, <em>tau=0.1</em>, <em>r2_term=False</em><big>)</big><a class="headerlink" href="#dipy.reconst.csdeconv.odf_deconv" title="Permalink to this definition">¶</a></dt>
<dd><p>ODF constrained-regularized spherical deconvolution using
the Sharpening Deconvolution Transform (SDT) <a class="reference internal" href="#r90" id="id74">[R90]</a>, <a class="reference internal" href="#r91" id="id75">[R91]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>odf_sh</strong> : ndarray (<tt class="docutils literal"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)*(sh_order</span> <span class="pre">+</span> <span class="pre">2)/2</span></tt>,)</p>
<blockquote>
<div><p>ndarray of SH coefficients for the ODF spherical function to be
deconvolved</p>
</div></blockquote>
<p><strong>R</strong> : ndarray (<tt class="docutils literal"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)(sh_order</span> <span class="pre">+</span> <span class="pre">2)/2</span></tt>, <tt class="docutils literal"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)(sh_order</span> <span class="pre">+</span> <span class="pre">2)/2</span></tt>)</p>
<blockquote>
<div><p>SDT matrix in SH basis</p>
</div></blockquote>
<p><strong>B_reg</strong> : ndarray (<tt class="docutils literal"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)(sh_order</span> <span class="pre">+</span> <span class="pre">2)/2</span></tt>, <tt class="docutils literal"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)(sh_order</span> <span class="pre">+</span> <span class="pre">2)/2</span></tt>)</p>
<blockquote>
<div><p>SH basis matrix used for deconvolution</p>
</div></blockquote>
<p><strong>lambda_</strong> : float</p>
<blockquote>
<div><p>lambda parameter in minimization equation (default 1.0)</p>
</div></blockquote>
<p><strong>tau</strong> : float</p>
<blockquote>
<div><p>threshold (tau <a href="#id76"><span class="problematic" id="id77">*</span></a>max(fODF)) controlling the amplitude below
which the corresponding fODF is assumed to be zero.</p>
</div></blockquote>
<p><strong>r2_term</strong> : bool</p>
<blockquote>
<div><p>True if ODF is computed from model that uses the <span class="math">r^2</span> term in the
integral.  Recall that Tuch&#8217;s ODF (used in Q-ball Imaging <a class="reference internal" href="#r90" id="id78">[R90]</a>) and
the true normalized ODF definition differ from a <span class="math">r^2</span> term in the ODF
integral. The original Sharpening Deconvolution Transform (SDT)
technique <a class="reference internal" href="#r91" id="id79">[R91]</a> is expecting Tuch&#8217;s ODF without the <span class="math">r^2</span> (see <a class="reference internal" href="#r92" id="id80">[R92]</a> for
the mathematical details).  Now, this function supports ODF that have
been computed using the <span class="math">r^2</span> term because the proper analytical
response function has be derived.  For example, models such as DSI,
GQI, SHORE, CSA, Tensor, Multi-tensor ODFs, should now be deconvolved
with the r2_term=True.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fodf_sh</strong> : ndarray (<tt class="docutils literal"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)(sh_order</span> <span class="pre">+</span> <span class="pre">2)/2</span></tt>,)</p>
<blockquote>
<div><p>Spherical harmonics coefficients of the constrained-regularized fiber
ODF</p>
</div></blockquote>
<p><strong>num_it</strong> : int</p>
<blockquote class="last">
<div><p>Number of iterations in the constrained-regularization used for
convergence</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r90" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R90]</td><td><em>(<a class="fn-backref" href="#id74">1</a>, <a class="fn-backref" href="#id78">2</a>, <a class="fn-backref" href="#id81">3</a>)</em> Tuch, D. MRM 2004. Q-Ball Imaging.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r91" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R91]</td><td><em>(<a class="fn-backref" href="#id75">1</a>, <a class="fn-backref" href="#id79">2</a>, <a class="fn-backref" href="#id82">3</a>)</em> Descoteaux, M., et al. IEEE TMI 2009. Deterministic and
Probabilistic Tractography Based on Complex Fibre Orientation
Distributions</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r92" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R92]</td><td><em>(<a class="fn-backref" href="#id80">1</a>, <a class="fn-backref" href="#id83">2</a>)</em> Descoteaux, M, PhD thesis, INRIA Sophia-Antipolis, 2008.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="odf-sh-to-sharp">
<h3>odf_sh_to_sharp<a class="headerlink" href="#odf-sh-to-sharp" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.odf_sh_to_sharp">
<tt class="descclassname">dipy.reconst.csdeconv.</tt><tt class="descname">odf_sh_to_sharp</tt><big>(</big><em>odfs_sh</em>, <em>sphere</em>, <em>basis=None</em>, <em>ratio=0.2</em>, <em>sh_order=8</em>, <em>lambda_=1.0</em>, <em>tau=0.1</em>, <em>r2_term=False</em><big>)</big><a class="headerlink" href="#dipy.reconst.csdeconv.odf_sh_to_sharp" title="Permalink to this definition">¶</a></dt>
<dd><p>Sharpen odfs using the spherical deconvolution transform <a class="reference internal" href="#r93" id="id84">[R93]</a></p>
<p>This function can be used to sharpen any smooth ODF spherical function. In
theory, this should only be used to sharpen QballModel ODFs, but in
practice, one can play with the deconvolution ratio and sharpen almost any
ODF-like spherical function. The constrained-regularization is stable and
will not only sharp the ODF peaks but also regularize the noisy peaks.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>odfs_sh</strong> : ndarray (<tt class="docutils literal"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)*(sh_order</span> <span class="pre">+</span> <span class="pre">2)/2</span></tt>, )</p>
<blockquote>
<div><p>array of odfs expressed as spherical harmonics coefficients</p>
</div></blockquote>
<p><strong>sphere</strong> : Sphere</p>
<blockquote>
<div><p>sphere used to build the regularization matrix</p>
</div></blockquote>
<p><strong>basis</strong> : {None, &#8216;mrtrix&#8217;, &#8216;fibernav&#8217;}</p>
<blockquote>
<div><p>different spherical harmonic basis. None is the fibernav basis as well.</p>
</div></blockquote>
<p><strong>ratio</strong> : float,</p>
<blockquote>
<div><p>ratio of the smallest vs the largest eigenvalue of the single prolate
tensor response function (<span class="math">\frac{\lambda_2}{\lambda_1}</span>)</p>
</div></blockquote>
<p><strong>sh_order</strong> : int</p>
<blockquote>
<div><p>maximal SH order of the SH representation</p>
</div></blockquote>
<p><strong>lambda_</strong> : float</p>
<blockquote>
<div><p>lambda parameter (see odfdeconv) (default 1.0)</p>
</div></blockquote>
<p><strong>tau</strong> : float</p>
<blockquote>
<div><p>tau parameter in the L matrix construction (see odfdeconv) (default 0.1)</p>
</div></blockquote>
<p><strong>r2_term</strong> : bool</p>
<blockquote>
<div><p>True if ODF is computed from model that uses the <span class="math">r^2</span> term in the
integral.  Recall that Tuch&#8217;s ODF (used in Q-ball Imaging <a class="reference internal" href="#r93" id="id85">[R93]</a>) and
the true normalized ODF definition differ from a <span class="math">r^2</span> term in the ODF
integral. The original Sharpening Deconvolution Transform (SDT)
technique <a class="reference internal" href="#r94" id="id86">[R94]</a> is expecting Tuch&#8217;s ODF without the <span class="math">r^2</span> (see <a class="reference internal" href="#r95" id="id87">[R95]</a> for
the mathematical details).  Now, this function supports ODF that have
been computed using the <span class="math">r^2</span> term because the proper analytical
response function has be derived.  For example, models such as DSI,
GQI, SHORE, CSA, Tensor, Multi-tensor ODFs, should now be deconvolved
with the r2_term=True.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fodf_sh</strong> : ndarray</p>
<blockquote class="last">
<div><p>sharpened odf expressed as spherical harmonics coefficients</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r93" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R93]</td><td><em>(<a class="fn-backref" href="#id84">1</a>, <a class="fn-backref" href="#id85">2</a>, <a class="fn-backref" href="#id88">3</a>)</em> Tuch, D. MRM 2004. Q-Ball Imaging.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r94" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R94]</td><td><em>(<a class="fn-backref" href="#id86">1</a>, <a class="fn-backref" href="#id89">2</a>)</em> Descoteaux, M., et al. IEEE TMI 2009. Deterministic and
Probabilistic Tractography Based on Complex Fibre Orientation
Distributions</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r95" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R95]</td><td><em>(<a class="fn-backref" href="#id87">1</a>, <a class="fn-backref" href="#id90">2</a>)</em> Descoteaux, M, et al. MRM 2007. Fast, Regularized and Analytical
Q-Ball Imaging</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="peaks-from-model">
<h3>peaks_from_model<a class="headerlink" href="#peaks-from-model" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.peaks_from_model">
<tt class="descclassname">dipy.reconst.csdeconv.</tt><tt class="descname">peaks_from_model</tt><big>(</big><em>model</em>, <em>data</em>, <em>sphere</em>, <em>relative_peak_threshold</em>, <em>min_separation_angle</em>, <em>mask=None</em>, <em>return_odf=False</em>, <em>return_sh=True</em>, <em>gfa_thr=0</em>, <em>normalize_peaks=False</em>, <em>sh_order=8</em>, <em>sh_basis_type=None</em>, <em>npeaks=5</em>, <em>B=None</em>, <em>invB=None</em>, <em>parallel=False</em>, <em>nbr_processes=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.csdeconv.peaks_from_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Fits the model to data and computes peaks and metrics</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>model</strong> : a model instance</p>
<blockquote>
<div><p><cite>model</cite> will be used to fit the data.</p>
</div></blockquote>
<p><strong>sphere</strong> : Sphere</p>
<blockquote>
<div><p>The Sphere providing discrete directions for evaluation.</p>
</div></blockquote>
<p><strong>relative_peak_threshold</strong> : float</p>
<blockquote>
<div><p>Only return peaks greater than <tt class="docutils literal"><span class="pre">relative_peak_threshold</span> <span class="pre">*</span> <span class="pre">m</span></tt> where m
is the largest peak.</p>
</div></blockquote>
<p><strong>min_separation_angle</strong> : float in [0, 90] The minimum distance between</p>
<blockquote>
<div><p>directions. If two peaks are too close only the larger of the two is
returned.</p>
</div></blockquote>
<p><strong>mask</strong> : array, optional</p>
<blockquote>
<div><p>If <cite>mask</cite> is provided, voxels that are False in <cite>mask</cite> are skipped and
no peaks are returned.</p>
</div></blockquote>
<p><strong>return_odf</strong> : bool</p>
<blockquote>
<div><p>If True, the odfs are returned.</p>
</div></blockquote>
<p><strong>return_sh</strong> : bool</p>
<blockquote>
<div><p>If True, the odf as spherical harmonics coefficients is returned</p>
</div></blockquote>
<p><strong>gfa_thr</strong> : float</p>
<blockquote>
<div><p>Voxels with gfa less than <cite>gfa_thr</cite> are skipped, no peaks are returned.</p>
</div></blockquote>
<p><strong>normalize_peaks</strong> : bool</p>
<blockquote>
<div><p>If true, all peak values are calculated relative to <cite>max(odf)</cite>.</p>
</div></blockquote>
<p><strong>sh_order</strong> : int, optional</p>
<blockquote>
<div><p>Maximum SH order in the SH fit.  For <cite>sh_order</cite>, there will be
<tt class="docutils literal"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">*</span> <span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">2)</span> <span class="pre">/</span> <span class="pre">2</span></tt> SH coefficients (default 8).</p>
</div></blockquote>
<p><strong>sh_basis_type</strong> : {None, &#8216;mrtrix&#8217;, &#8216;fibernav&#8217;}</p>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">None</span></tt> for the default dipy basis which is the fibernav basis,
<tt class="docutils literal"><span class="pre">mrtrix</span></tt> for the MRtrix basis, and
<tt class="docutils literal"><span class="pre">fibernav</span></tt> for the FiberNavigator basis</p>
</div></blockquote>
<p><strong>sh_smooth</strong> : float, optional</p>
<blockquote>
<div><p>Lambda-regularization in the SH fit (default 0.0).</p>
</div></blockquote>
<p><strong>npeaks</strong> : int</p>
<blockquote>
<div><p>Maximum number of peaks found (default 5 peaks).</p>
</div></blockquote>
<p><strong>B</strong> : ndarray, optional</p>
<blockquote>
<div><p>Matrix that transforms spherical harmonics to spherical function
<tt class="docutils literal"><span class="pre">sf</span> <span class="pre">=</span> <span class="pre">np.dot(sh,</span> <span class="pre">B)</span></tt>.</p>
</div></blockquote>
<p><strong>invB</strong> : ndarray, optional</p>
<blockquote>
<div><p>Inverse of B.</p>
</div></blockquote>
<p><strong>parallel: bool</strong> :</p>
<blockquote>
<div><p>If True, use multiprocessing to compute peaks and metric
(default False). Temporary files are saved in the default temporary
directory of the system. It can be changed using <tt class="docutils literal"><span class="pre">import</span> <span class="pre">tempfile</span></tt>
and <tt class="docutils literal"><span class="pre">tempfile.tempdir</span> <span class="pre">=</span> <span class="pre">'/path/to/tempdir'</span></tt>.</p>
</div></blockquote>
<p><strong>nbr_processes: int</strong> :</p>
<blockquote>
<div><p>If <cite>parallel</cite> is True, the number of subprocesses to use
(default multiprocessing.cpu_count()).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>pam</strong> : PeaksAndMetrics</p>
<blockquote class="last">
<div><p>An object with <tt class="docutils literal"><span class="pre">gfa</span></tt>, <tt class="docutils literal"><span class="pre">peak_directions</span></tt>, <tt class="docutils literal"><span class="pre">peak_values</span></tt>,
<tt class="docutils literal"><span class="pre">peak_indices</span></tt>, <tt class="docutils literal"><span class="pre">odf</span></tt>, <tt class="docutils literal"><span class="pre">shm_coeffs</span></tt> as attributes</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="quad">
<h3>quad<a class="headerlink" href="#quad" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.quad">
<tt class="descclassname">dipy.reconst.csdeconv.</tt><tt class="descname">quad</tt><big>(</big><em>func</em>, <em>a</em>, <em>b</em>, <em>args=()</em>, <em>full_output=0</em>, <em>epsabs=1.49e-08</em>, <em>epsrel=1.49e-08</em>, <em>limit=50</em>, <em>points=None</em>, <em>weight=None</em>, <em>wvar=None</em>, <em>wopts=None</em>, <em>maxp1=50</em>, <em>limlst=50</em><big>)</big><a class="headerlink" href="#dipy.reconst.csdeconv.quad" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a definite integral.</p>
<p>Integrate func from <cite>a</cite> to <cite>b</cite> (possibly infinite interval) using a
technique from the Fortran library QUADPACK.</p>
<p>Run scipy.integrate.quad_explain() for more information on the
more esoteric inputs and outputs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>func</strong> : function</p>
<blockquote>
<div><p>A Python function or method to integrate.  If <cite>func</cite> takes many
arguments, it is integrated along the axis corresponding to the
first argument.</p>
</div></blockquote>
<p><strong>a</strong> : float</p>
<blockquote>
<div><p>Lower limit of integration (use -numpy.inf for -infinity).</p>
</div></blockquote>
<p><strong>b</strong> : float</p>
<blockquote>
<div><p>Upper limit of integration (use numpy.inf for +infinity).</p>
</div></blockquote>
<p><strong>args</strong> : tuple, optional</p>
<blockquote>
<div><p>Extra arguments to pass to <cite>func</cite>.</p>
</div></blockquote>
<p><strong>full_output</strong> : int, optional</p>
<blockquote>
<div><p>Non-zero to return a dictionary of integration information.
If non-zero, warning messages are also suppressed and the
message is appended to the output tuple.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>y</strong> : float</p>
<blockquote>
<div><p>The integral of func from <cite>a</cite> to <cite>b</cite>.</p>
</div></blockquote>
<p><strong>abserr</strong> : float</p>
<blockquote>
<div><p>An estimate of the absolute error in the result.</p>
</div></blockquote>
<p><strong>infodict</strong> : dict</p>
<blockquote>
<div><p>A dictionary containing additional information.
Run scipy.integrate.quad_explain() for more information.</p>
</div></blockquote>
<p><strong>message :</strong> :</p>
<blockquote>
<div><p>A convergence message.</p>
</div></blockquote>
<p><strong>explain :</strong> :</p>
<blockquote>
<div><p>Appended only with &#8216;cos&#8217; or &#8216;sin&#8217; weighting and infinite
integration limits, it contains an explanation of the codes in
infodict[&#8216;ierlst&#8217;]</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Other Parameters:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first"><strong>epsabs</strong> : float or int, optional</p>
<blockquote>
<div><p>Absolute error tolerance.</p>
</div></blockquote>
<p><strong>epsrel</strong> : float or int, optional</p>
<blockquote>
<div><p>Relative error tolerance.</p>
</div></blockquote>
<p><strong>limit</strong> : float or int, optional</p>
<blockquote>
<div><p>An upper bound on the number of subintervals used in the adaptive
algorithm.</p>
</div></blockquote>
<p><strong>points</strong> : (sequence of floats,ints), optional</p>
<blockquote>
<div><p>A sequence of break points in the bounded integration interval
where local difficulties of the integrand may occur (e.g.,
singularities, discontinuities). The sequence does not have
to be sorted.</p>
</div></blockquote>
<p><strong>weight</strong> : float or int, optional</p>
<blockquote>
<div><p>String indicating weighting function.</p>
</div></blockquote>
<p><strong>wvar</strong> : optional</p>
<blockquote>
<div><p>Variables for use with weighting functions.</p>
</div></blockquote>
<p><strong>wopts</strong> : optional</p>
<blockquote>
<div><p>Optional input for reusing Chebyshev moments.</p>
</div></blockquote>
<p><strong>maxp1</strong> : float or int, optional</p>
<blockquote>
<div><p>An upper bound on the number of Chebyshev moments.</p>
</div></blockquote>
<p><strong>limlst</strong> : int, optional</p>
<blockquote class="last">
<div><p>Upper bound on the number of cylces (&gt;=3) for use with a sinusoidal
weighting and an infinite end-point.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><tt class="xref py py-obj docutils literal"><span class="pre">dblquad</span></tt></dt>
<dd>double integral</dd>
<dt><tt class="xref py py-obj docutils literal"><span class="pre">tplquad</span></tt></dt>
<dd>triple integral</dd>
<dt><tt class="xref py py-obj docutils literal"><span class="pre">nquad</span></tt></dt>
<dd>n-dimensional integrals (uses <cite>quad</cite> recursively)</dd>
<dt><tt class="xref py py-obj docutils literal"><span class="pre">fixed_quad</span></tt></dt>
<dd>fixed-order Gaussian quadrature</dd>
<dt><tt class="xref py py-obj docutils literal"><span class="pre">quadrature</span></tt></dt>
<dd>adaptive Gaussian quadrature</dd>
<dt><tt class="xref py py-obj docutils literal"><span class="pre">odeint</span></tt></dt>
<dd>ODE integrator</dd>
<dt><tt class="xref py py-obj docutils literal"><span class="pre">ode</span></tt></dt>
<dd>ODE integrator</dd>
<dt><tt class="xref py py-obj docutils literal"><span class="pre">simps</span></tt></dt>
<dd>integrator for sampled data</dd>
<dt><tt class="xref py py-obj docutils literal"><span class="pre">romb</span></tt></dt>
<dd>integrator for sampled data</dd>
<dt><tt class="xref py py-obj docutils literal"><span class="pre">scipy.special</span></tt></dt>
<dd>for coefficients and roots of orthogonal polynomials</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Calculate <span class="math">\int^4_0 x^2 dx</span> and compare with an analytic result</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">integrate</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">(21.333333333333332, 2.3684757858670003e-13)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="mi">4</span><span class="o">**</span><span class="mi">3</span> <span class="o">/</span> <span class="mf">3.</span><span class="p">)</span>  <span class="c"># analytical result</span>
<span class="go">21.3333333333</span>
</pre></div>
</div>
<p>Calculate <span class="math">\int^\infty_0 e^{-x} dx</span></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">invexp</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">invexp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="go">(1.0, 5.842605999138044e-11)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">a</span> <span class="p">:</span> <span class="n">a</span><span class="o">*</span><span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">1.5</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="real-sph-harm">
<h3>real_sph_harm<a class="headerlink" href="#real-sph-harm" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.real_sph_harm">
<tt class="descclassname">dipy.reconst.csdeconv.</tt><tt class="descname">real_sph_harm</tt><big>(</big><em>m</em>, <em>n</em>, <em>theta</em>, <em>phi</em><big>)</big><a class="headerlink" href="#dipy.reconst.csdeconv.real_sph_harm" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute real spherical harmonics.</p>
<p>Where the real harmonic <span class="math">Y^m_n</span> is defined to be:</p>
<blockquote>
<div>Real(<span class="math">Y^m_n</span>) * sqrt(2) if m &gt; 0
<span class="math">Y^m_n</span>                 if m == 0
Imag(<span class="math">Y^m_n</span>) * sqrt(2) if m &lt; 0</div></blockquote>
<p>This may take scalar or array arguments. The inputs will be broadcasted
against each other.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>m</strong> : int <tt class="docutils literal"><span class="pre">|m|</span> <span class="pre">&lt;=</span> <span class="pre">n</span></tt></p>
<blockquote>
<div><p>The order of the harmonic.</p>
</div></blockquote>
<p><strong>n</strong> : int <tt class="docutils literal"><span class="pre">&gt;=</span> <span class="pre">0</span></tt></p>
<blockquote>
<div><p>The degree of the harmonic.</p>
</div></blockquote>
<p><strong>theta</strong> : float [0, 2*pi]</p>
<blockquote>
<div><p>The azimuthal (longitudinal) coordinate.</p>
</div></blockquote>
<p><strong>phi</strong> : float [0, pi]</p>
<blockquote>
<div><p>The polar (colatitudinal) coordinate.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>y_mn</strong> : real float</p>
<blockquote class="last">
<div><p>The real harmonic <span class="math">Y^m_n</span> sampled at <cite>theta</cite> and <cite>phi</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-obj docutils literal"><span class="pre">scipy.special.sph_harm</span></tt></p>
</div>
</dd></dl>

</div>
<div class="section" id="real-sym-sh-basis">
<h3>real_sym_sh_basis<a class="headerlink" href="#real-sym-sh-basis" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.real_sym_sh_basis">
<tt class="descclassname">dipy.reconst.csdeconv.</tt><tt class="descname">real_sym_sh_basis</tt><big>(</big><em>sh_order</em>, <em>theta</em>, <em>phi</em><big>)</big><a class="headerlink" href="#dipy.reconst.csdeconv.real_sym_sh_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples a real symmetric spherical harmonic basis at point on the sphere</p>
<p>Samples the basis functions up to order <cite>sh_order</cite> at points on the sphere
given by <cite>theta</cite> and <cite>phi</cite>. The basis functions are defined here the same
way as in fibernavigator <a class="reference internal" href="#r96" id="id91">[R96]</a> where the real harmonic <span class="math">Y^m_n</span> is defined to
be:</p>
<blockquote>
<div>Imag(<span class="math">Y^m_n</span>) * sqrt(2)     if m &gt; 0
<span class="math">Y^m_n</span>                     if m == 0
Real(<span class="math">Y^|m|_n</span>) * sqrt(2)   if m &lt; 0</div></blockquote>
<p>This may take scalar or array arguments. The inputs will be broadcasted
against each other.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sh_order</strong> : int</p>
<blockquote>
<div><p>even int &gt; 0, max spherical harmonic degree</p>
</div></blockquote>
<p><strong>theta</strong> : float [0, 2*pi]</p>
<blockquote>
<div><p>The azimuthal (longitudinal) coordinate.</p>
</div></blockquote>
<p><strong>phi</strong> : float [0, pi]</p>
<blockquote>
<div><p>The polar (colatitudinal) coordinate.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>y_mn</strong> : real float</p>
<blockquote>
<div><p>The real harmonic <span class="math">Y^m_n</span> sampled at <cite>theta</cite> and <cite>phi</cite></p>
</div></blockquote>
<p><strong>m</strong> : array</p>
<blockquote>
<div><p>The order of the harmonics.</p>
</div></blockquote>
<p><strong>n</strong> : array</p>
<blockquote class="last">
<div><p>The degree of the harmonics.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r96" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R96]</td><td><em>(<a class="fn-backref" href="#id91">1</a>, <a class="fn-backref" href="#id92">2</a>)</em> <a class="reference external" href="http://code.google.com/p/fibernavigator/">http://code.google.com/p/fibernavigator/</a></td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="recursive-response">
<h3>recursive_response<a class="headerlink" href="#recursive-response" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.recursive_response">
<tt class="descclassname">dipy.reconst.csdeconv.</tt><tt class="descname">recursive_response</tt><big>(</big><em>gtab</em>, <em>data</em>, <em>mask=None</em>, <em>sh_order=8</em>, <em>peak_thr=0.01</em>, <em>init_fa=0.08</em>, <em>init_trace=0.0021</em>, <em>iter=8</em>, <em>convergence=0.001</em>, <em>parallel=True</em>, <em>nbr_processes=None</em>, <em>sphere=&lt;dipy.core.sphere.HemiSphere object at 0x2abac40027d0&gt;</em><big>)</big><a class="headerlink" href="#dipy.reconst.csdeconv.recursive_response" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursive calibration of response function using peak threshold</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>gtab</strong> : GradientTable</p>
<p><strong>data</strong> : ndarray</p>
<blockquote>
<div><p>diffusion data</p>
</div></blockquote>
<p><strong>mask</strong> : ndarray, optional</p>
<blockquote>
<div><p>mask for recursive calibration, for example a white matter mask. It has
shape <cite>data.shape[0:3]</cite> and dtype=bool. Default: use the entire data
array.</p>
</div></blockquote>
<p><strong>sh_order</strong> : int, optional</p>
<blockquote>
<div><p>maximal spherical harmonics order. Default: 8</p>
</div></blockquote>
<p><strong>peak_thr</strong> : float, optional</p>
<blockquote>
<div><p>peak threshold, how large the second peak can be relative to the first
peak in order to call it a single fiber population [1]. Default: 0.01</p>
</div></blockquote>
<p><strong>init_fa</strong> : float, optional</p>
<blockquote>
<div><p>FA of the initial &#8216;fat&#8217; response function (tensor). Default: 0.08</p>
</div></blockquote>
<p><strong>init_trace</strong> : float, optional</p>
<blockquote>
<div><p>trace of the initial &#8216;fat&#8217; response function (tensor). Default: 0.0021</p>
</div></blockquote>
<p><strong>iter</strong> : int, optional</p>
<blockquote>
<div><p>maximum number of iterations for calibration. Default: 8.</p>
</div></blockquote>
<p><strong>convergence</strong> : float, optional</p>
<blockquote>
<div><p>convergence criterion, maximum relative change of SH
coefficients. Default: 0.001.</p>
</div></blockquote>
<p><strong>parallel</strong> : bool, optional</p>
<blockquote>
<div><p>Whether to use parallelization in peak-finding during the calibration
procedure. Default: True</p>
</div></blockquote>
<p><strong>nbr_processes: int</strong> :</p>
<blockquote>
<div><p>If <cite>parallel</cite> is True, the number of subprocesses to use
(default multiprocessing.cpu_count()).</p>
</div></blockquote>
<p><strong>sphere</strong> : Sphere, optional.</p>
<blockquote>
<div><p>The sphere used for peak finding. Default: default_sphere.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>response</strong> : ndarray</p>
<blockquote class="last">
<div><p>response function in SH coefficients</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>In CSD there is an important pre-processing step: the estimation of the
fiber response function. Using an FA threshold is not a very robust method.
It is dependent on the dataset (non-informed used subjectivity), and still
depends on the diffusion tensor (FA and first eigenvector),
which has low accuracy at high b-value. This function recursively
calibrates the response function, for more information see [1].</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r97" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id93">[R97]</a></td><td>Tax, C.M.W., et al. NeuroImage 2014. Recursive calibration of
the fiber response function for spherical deconvolution of
diffusion MRI data.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="sh-to-rh">
<h3>sh_to_rh<a class="headerlink" href="#sh-to-rh" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.sh_to_rh">
<tt class="descclassname">dipy.reconst.csdeconv.</tt><tt class="descname">sh_to_rh</tt><big>(</big><em>r_sh</em>, <em>m</em>, <em>n</em><big>)</big><a class="headerlink" href="#dipy.reconst.csdeconv.sh_to_rh" title="Permalink to this definition">¶</a></dt>
<dd><p>Spherical harmonics (SH) to rotational harmonics (RH)</p>
<p>Calculate the rotational harmonic decomposition up to
harmonic order <cite>m</cite>, degree <cite>n</cite> for an axially and antipodally
symmetric function. Note that all <tt class="docutils literal"><span class="pre">m</span> <span class="pre">!=</span> <span class="pre">0</span></tt> coefficients
will be ignored as axial symmetry is assumed. Hence, there
will be <tt class="docutils literal"><span class="pre">(sh_order/2</span> <span class="pre">+</span> <span class="pre">1)</span></tt> non-zero coefficients.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>r_sh</strong> : ndarray (N,)</p>
<blockquote>
<div><p>ndarray of SH coefficients for the single fiber response function.
These coefficients must correspond to the real spherical harmonic
functions produced by <cite>shm.real_sph_harm</cite>.</p>
</div></blockquote>
<p><strong>m</strong> : ndarray (N,)</p>
<blockquote>
<div><p>The order of the spherical harmonic function associated with each
coefficient.</p>
</div></blockquote>
<p><strong>n</strong> : ndarray (N,)</p>
<blockquote>
<div><p>The degree of the spherical harmonic function associated with each
coefficient.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>r_rh</strong> : ndarray (<tt class="docutils literal"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)*(sh_order</span> <span class="pre">+</span> <span class="pre">2)/2</span></tt>,)</p>
<blockquote class="last">
<div><p>Rotational harmonics coefficients representing the input <cite>r_sh</cite></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-obj docutils literal"><span class="pre">shm.real_sph_harm</span></tt>, <tt class="xref py py-obj docutils literal"><span class="pre">shm.real_sym_sh_basis</span></tt></p>
</div>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r98" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id94">[R98]</a></td><td>Tournier, J.D., et al. NeuroImage 2007. Robust determination of the
fibre orientation distribution in diffusion MRI: Non-negativity
constrained super-resolved spherical deconvolution</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="single-tensor">
<h3>single_tensor<a class="headerlink" href="#single-tensor" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.single_tensor">
<tt class="descclassname">dipy.reconst.csdeconv.</tt><tt class="descname">single_tensor</tt><big>(</big><em>gtab</em>, <em>S0=1</em>, <em>evals=None</em>, <em>evecs=None</em>, <em>snr=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.csdeconv.single_tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulated Q-space signal with a single tensor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>gtab</strong> : GradientTable</p>
<blockquote>
<div><p>Measurement directions.</p>
</div></blockquote>
<p><strong>S0</strong> : double,</p>
<blockquote>
<div><p>Strength of signal in the presence of no diffusion gradient (also
called the <tt class="docutils literal"><span class="pre">b=0</span></tt> value).</p>
</div></blockquote>
<p><strong>evals</strong> : (3,) ndarray</p>
<blockquote>
<div><p>Eigenvalues of the diffusion tensor.  By default, values typical for
prolate white matter are used.</p>
</div></blockquote>
<p><strong>evecs</strong> : (3, 3) ndarray</p>
<blockquote>
<div><p>Eigenvectors of the tensor.  You can also think of this as a rotation
matrix that transforms the direction of the tensor. The eigenvectors
needs to be column wise.</p>
</div></blockquote>
<p><strong>snr</strong> : float</p>
<blockquote>
<div><p>Signal to noise ratio, assuming Rician noise.  None implies no noise.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>S</strong> : (N,) ndarray</p>
<blockquote class="last">
<div><p>Simulated signal: <tt class="docutils literal"><span class="pre">S(q,</span> <span class="pre">tau)</span> <span class="pre">=</span> <span class="pre">S_0</span> <span class="pre">e^(-b</span> <span class="pre">g^T</span> <span class="pre">R</span> <span class="pre">D</span> <span class="pre">R.T</span> <span class="pre">g)</span></tt>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r99" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id95">[R99]</a></td><td>M. Descoteaux, &#8220;High Angular Resolution Diffusion MRI: from Local
Estimation to Segmentation and Tractography&#8221;, PhD thesis,
University of Nice-Sophia Antipolis, p. 42, 2008.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r100" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id96">[R100]</a></td><td>E. Stejskal and J. Tanner, &#8220;Spin diffusion measurements: spin echos
in the presence of a time-dependent field gradient&#8221;, Journal of
Chemical Physics, nr. 42, pp. 288&#8211;292, 1965.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="sph-harm-ind-list">
<h3>sph_harm_ind_list<a class="headerlink" href="#sph-harm-ind-list" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.sph_harm_ind_list">
<tt class="descclassname">dipy.reconst.csdeconv.</tt><tt class="descname">sph_harm_ind_list</tt><big>(</big><em>sh_order</em><big>)</big><a class="headerlink" href="#dipy.reconst.csdeconv.sph_harm_ind_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the degree (n) and order (m) of all the symmetric spherical
harmonics of degree less then or equal to <cite>sh_order</cite>. The results, <cite>m_list</cite>
and <cite>n_list</cite> are kx1 arrays, where k depends on sh_order. They can be
passed to <a class="reference internal" href="#dipy.reconst.csdeconv.real_sph_harm" title="dipy.reconst.csdeconv.real_sph_harm"><tt class="xref py py-func docutils literal"><span class="pre">real_sph_harm()</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sh_order</strong> : int</p>
<blockquote>
<div><p>even int &gt; 0, max degree to return</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>m_list</strong> : array</p>
<blockquote>
<div><p>orders of even spherical harmonics</p>
</div></blockquote>
<p><strong>n_list</strong> : array</p>
<blockquote class="last">
<div><p>degrees of even spherical harmonics</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#dipy.reconst.csdeconv.real_sph_harm" title="dipy.reconst.csdeconv.real_sph_harm"><tt class="xref py py-obj docutils literal"><span class="pre">real_sph_harm</span></tt></a></p>
</div>
</dd></dl>

</div>
<div class="section" id="vec2vec-rotmat">
<h3>vec2vec_rotmat<a class="headerlink" href="#vec2vec-rotmat" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.vec2vec_rotmat">
<tt class="descclassname">dipy.reconst.csdeconv.</tt><tt class="descname">vec2vec_rotmat</tt><big>(</big><em>u</em>, <em>v</em><big>)</big><a class="headerlink" href="#dipy.reconst.csdeconv.vec2vec_rotmat" title="Permalink to this definition">¶</a></dt>
<dd><p>rotation matrix from 2 unit vectors</p>
<p>u,v being unit 3d vectors return a 3x3 rotation matrix R than aligns u to v.</p>
<p>In general there are many rotations that will map u to v. If S is any
rotation using v as an axis then R.S will also map u to v since (S.R)u =
S(Ru) = Sv = v.  The rotation R returned by vec2vec_rotmat leaves fixed the
perpendicular to the plane spanned by u and v.</p>
<p>The transpose of R will align v to u.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>u</strong> : array, shape(3,)</p>
<p><strong>v</strong> : array, shape(3,)</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>R</strong> : array, shape(3,3)</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.core.geometry</span> <span class="kn">import</span> <span class="n">vec2vec_rotmat</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span><span class="o">=</span><span class="n">vec2vec_rotmat</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">u</span><span class="p">)</span>
<span class="go">array([ 0.,  1.,  0.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
<span class="go">array([ 1.,  0.,  0.])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="id97">
<h3><a class="reference internal" href="#dipy.reconst.dsi.Cache" title="dipy.reconst.dsi.Cache"><tt class="xref py py-class docutils literal"><span class="pre">Cache</span></tt></a><a class="headerlink" href="#id97" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.dsi.Cache">
<em class="property">class </em><tt class="descclassname">dipy.reconst.dsi.</tt><tt class="descname">Cache</tt><a class="headerlink" href="#dipy.reconst.dsi.Cache" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></a></p>
<p>Cache values based on a key object (such as a sphere or gradient table).</p>
<p class="rubric">Notes</p>
<p>This class is meant to be used as a mix-in:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MyModel</span><span class="p">(</span><span class="n">Model</span><span class="p">,</span> <span class="n">Cache</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">MyModelFit</span><span class="p">(</span><span class="n">Fit</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>Inside a method on the fit, typical usage would be:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">odf</span><span class="p">(</span><span class="n">sphere</span><span class="p">):</span>
    <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">cache_get</span><span class="p">(</span><span class="s">&#39;odf_basis_matrix&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sphere</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">M</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_basis_matrix</span><span class="p">(</span><span class="n">sphere</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">cache_set</span><span class="p">(</span><span class="s">&#39;odf_basis_matrix&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sphere</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">M</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dsi.Cache.cache_clear" title="dipy.reconst.dsi.Cache.cache_clear"><tt class="xref py py-obj docutils literal"><span class="pre">cache_clear</span></tt></a>()</td>
<td>Clear the cache.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dsi.Cache.cache_get" title="dipy.reconst.dsi.Cache.cache_get"><tt class="xref py py-obj docutils literal"><span class="pre">cache_get</span></tt></a>(tag,&nbsp;key[,&nbsp;default])</td>
<td>Retrieve a value from the cache.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dsi.Cache.cache_set" title="dipy.reconst.dsi.Cache.cache_set"><tt class="xref py py-obj docutils literal"><span class="pre">cache_set</span></tt></a>(tag,&nbsp;key,&nbsp;value)</td>
<td>Store a value in the cache.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.dsi.Cache.__init__">
<tt class="descname">__init__</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.dsi.Cache.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dsi.Cache.cache_clear">
<tt class="descname">cache_clear</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.dsi.Cache.cache_clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear the cache.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dsi.Cache.cache_get">
<tt class="descname">cache_get</tt><big>(</big><em>tag</em>, <em>key</em>, <em>default=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.dsi.Cache.cache_get" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a value from the cache.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>tag</strong> : str</p>
<blockquote>
<div><p>Description of the cached value.</p>
</div></blockquote>
<p><strong>key</strong> : object</p>
<blockquote>
<div><p>Key object used to look up the cached value.</p>
</div></blockquote>
<p><strong>default</strong> : object</p>
<blockquote>
<div><p>Value to be returned if no cached entry is found.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>v</strong> : object</p>
<blockquote class="last">
<div><p>Value from the cache associated with <tt class="docutils literal"><span class="pre">(tag,</span> <span class="pre">key)</span></tt>.  Returns
<cite>default</cite> if no cached entry is found.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dsi.Cache.cache_set">
<tt class="descname">cache_set</tt><big>(</big><em>tag</em>, <em>key</em>, <em>value</em><big>)</big><a class="headerlink" href="#dipy.reconst.dsi.Cache.cache_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Store a value in the cache.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>tag</strong> : str</p>
<blockquote>
<div><p>Description of the cached value.</p>
</div></blockquote>
<p><strong>key</strong> : object</p>
<blockquote>
<div><p>Key object used to look up the cached value.</p>
</div></blockquote>
<p><strong>value</strong> : object</p>
<blockquote class="last">
<div><p>Value stored in the cache for each unique combination
of <tt class="docutils literal"><span class="pre">(tag,</span> <span class="pre">key)</span></tt>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">compute_expensive_matrix</span><span class="p">(</span><span class="n">parameters</span><span class="p">):</span>
<span class="gp">... </span>    <span class="c"># Imagine the following computation is very expensive</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Cache</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">parameters</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X1</span> <span class="o">=</span> <span class="n">compute_expensive_matrix</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">cache_set</span><span class="p">(</span><span class="s">&#39;expensive_matrix&#39;</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">X1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X2</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">cache_get</span><span class="p">(</span><span class="s">&#39;expensive_matrix&#39;</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">X1</span> <span class="ow">is</span> <span class="n">X2</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="diffusionspectrumdeconvfit">
<h3><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvFit" title="dipy.reconst.dsi.DiffusionSpectrumDeconvFit"><tt class="xref py py-class docutils literal"><span class="pre">DiffusionSpectrumDeconvFit</span></tt></a><a class="headerlink" href="#diffusionspectrumdeconvfit" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.dsi.DiffusionSpectrumDeconvFit">
<em class="property">class </em><tt class="descclassname">dipy.reconst.dsi.</tt><tt class="descname">DiffusionSpectrumDeconvFit</tt><big>(</big><em>model</em>, <em>data</em><big>)</big><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvFit" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumFit" title="dipy.reconst.dsi.DiffusionSpectrumFit"><tt class="xref py py-class docutils literal"><span class="pre">dipy.reconst.dsi.DiffusionSpectrumFit</span></tt></a></p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">msd_discrete</span></tt>([normalized])</td>
<td>Calculates the mean squared displacement on the discrete propagator</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">odf</span></tt>(sphere)</td>
<td>Calculates the real discrete odf for a given discrete sphere</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvFit.pdf" title="dipy.reconst.dsi.DiffusionSpectrumDeconvFit.pdf"><tt class="xref py py-obj docutils literal"><span class="pre">pdf</span></tt></a>()</td>
<td>Applies the 3D FFT in the q-space grid to generate</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">rtop_pdf</span></tt>([normalized])</td>
<td>Calculates the return to origin probability from the propagator, which is the propagator evaluated at zero (see Descoteaux et Al.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">rtop_signal</span></tt>([filtering])</td>
<td>Calculates the return to origin probability (rtop) from the signal</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.dsi.DiffusionSpectrumDeconvFit.__init__">
<tt class="descname">__init__</tt><big>(</big><em>model</em>, <em>data</em><big>)</big><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvFit.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates PDF and ODF and other properties for a single voxel</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>model</strong> : object,</p>
<blockquote>
<div><p>DiffusionSpectrumModel</p>
</div></blockquote>
<p><strong>data</strong> : 1d ndarray,</p>
<blockquote class="last">
<div><p>signal values</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dsi.DiffusionSpectrumDeconvFit.pdf">
<tt class="descname">pdf</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvFit.pdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the 3D FFT in the q-space grid to generate
the DSI diffusion propagator, remove the background noise with a
hard threshold and then deconvolve the propagator with the
Lucy-Richardson deconvolution algorithm</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="diffusionspectrumdeconvmodel">
<h3><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvModel" title="dipy.reconst.dsi.DiffusionSpectrumDeconvModel"><tt class="xref py py-class docutils literal"><span class="pre">DiffusionSpectrumDeconvModel</span></tt></a><a class="headerlink" href="#diffusionspectrumdeconvmodel" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.dsi.DiffusionSpectrumDeconvModel">
<em class="property">class </em><tt class="descclassname">dipy.reconst.dsi.</tt><tt class="descname">DiffusionSpectrumDeconvModel</tt><big>(</big><em>gtab</em>, <em>qgrid_size=35</em>, <em>r_start=4.1</em>, <em>r_end=13.0</em>, <em>r_step=0.4</em>, <em>filter_width=inf</em>, <em>normalize_peaks=False</em><big>)</big><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumModel" title="dipy.reconst.dsi.DiffusionSpectrumModel"><tt class="xref py py-class docutils literal"><span class="pre">dipy.reconst.dsi.DiffusionSpectrumModel</span></tt></a></p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">cache_clear</span></tt>()</td>
<td>Clear the cache.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">cache_get</span></tt>(tag,&nbsp;key[,&nbsp;default])</td>
<td>Retrieve a value from the cache.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">cache_set</span></tt>(tag,&nbsp;key,&nbsp;value)</td>
<td>Store a value in the cache.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvModel.fit" title="dipy.reconst.dsi.DiffusionSpectrumDeconvModel.fit"><tt class="xref py py-obj docutils literal"><span class="pre">fit</span></tt></a>(data[,&nbsp;mask])</td>
<td>Fit method for every voxel in data</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.dsi.DiffusionSpectrumDeconvModel.__init__">
<tt class="descname">__init__</tt><big>(</big><em>gtab</em>, <em>qgrid_size=35</em>, <em>r_start=4.1</em>, <em>r_end=13.0</em>, <em>r_step=0.4</em>, <em>filter_width=inf</em>, <em>normalize_peaks=False</em><big>)</big><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvModel.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Diffusion Spectrum Deconvolution</p>
<p>The idea is to remove the convolution on the DSI propagator that is
caused by the truncation of the q-space in the DSI sampling.</p>
<dl class="docutils">
<dt>..math::</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">nowrap:</th><td class="field-body"><dl class="first docutils">
<dt>begin{eqnarray*}</dt>
<dd><p class="first last">P_{dsi}(mathbf{r}) &amp; = &amp; S_{0}^{-1}iiintlimits_{| mathbf{q} | le mathbf{q_{max}}} S(mathbf{q})exp(-i2pimathbf{q}cdotmathbf{r})dmathbf{q} \
&amp; = &amp; S_{0}^{-1}iiintlimits_{mathbf{q}} left( S(mathbf{q}) cdot M(mathbf{q}) right) exp(-i2pimathbf{q}cdotmathbf{r})dmathbf{q} \
&amp; = &amp; P(mathbf{r}) otimes left( S_{0}^{-1}iiintlimits_{mathbf{q}}  M(mathbf{q}) exp(-i2pimathbf{q}cdotmathbf{r})dmathbf{q} right) \</p>
</dd>
</dl>
<p class="last">end{eqnarray*}</p>
</td>
</tr>
</tbody>
</table>
</dd>
</dl>
<p>where <span class="math">\mathbf{r}</span> is the displacement vector and <span class="math">\mathbf{q}</span> is the
wavector which corresponds to different gradient directions,
<span class="math">M(\mathbf{q})</span> is a mask corresponding to your q-space sampling and
<span class="math">\otimes</span> is the convolution operator <a class="reference internal" href="#r105" id="id98">[R105]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>gtab</strong> : GradientTable,</p>
<blockquote>
<div><p>Gradient directions and bvalues container class</p>
</div></blockquote>
<p><strong>qgrid_size</strong> : int,</p>
<blockquote>
<div><p>has to be an odd number. Sets the size of the q_space grid.
For example if qgrid_size is 35 then the shape of the grid will be
<tt class="docutils literal"><span class="pre">(35,</span> <span class="pre">35,</span> <span class="pre">35)</span></tt>.</p>
</div></blockquote>
<p><strong>r_start</strong> : float,</p>
<blockquote>
<div><p>ODF is sampled radially in the PDF. This parameters shows where the
sampling should start.</p>
</div></blockquote>
<p><strong>r_end</strong> : float,</p>
<blockquote>
<div><p>Radial endpoint of ODF sampling</p>
</div></blockquote>
<p><strong>r_step</strong> : float,</p>
<blockquote>
<div><p>Step size of the ODf sampling from r_start to r_end</p>
</div></blockquote>
<p><strong>filter_width</strong> : float,</p>
<blockquote class="last">
<div><p>Strength of the hanning filter</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r105" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R105]</td><td><em>(<a class="fn-backref" href="#id98">1</a>, <a class="fn-backref" href="#id99">2</a>)</em> Canales-Rodriguez E.J et. al, &#8220;Deconvolution in Diffusion</td></tr>
</tbody>
</table>
<p>Spectrum Imaging&#8221;, Neuroimage, 2010.</p>
<table class="docutils citation" frame="void" id="r106" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id100">[R106]</a></td><td>Biggs David S.C. et. al, &#8220;Acceleration of Iterative Image</td></tr>
</tbody>
</table>
<p>Restoration Algorithms&#8221;, Applied Optics, vol. 36, No. 8, p. 1766-1775,
1997.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dsi.DiffusionSpectrumDeconvModel.fit">
<tt class="descname">fit</tt><big>(</big><em>data</em>, <em>mask=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvModel.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="diffusionspectrumfit">
<h3><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumFit" title="dipy.reconst.dsi.DiffusionSpectrumFit"><tt class="xref py py-class docutils literal"><span class="pre">DiffusionSpectrumFit</span></tt></a><a class="headerlink" href="#diffusionspectrumfit" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.dsi.DiffusionSpectrumFit">
<em class="property">class </em><tt class="descclassname">dipy.reconst.dsi.</tt><tt class="descname">DiffusionSpectrumFit</tt><big>(</big><em>model</em>, <em>data</em><big>)</big><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumFit" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.odf.OdfFit" title="dipy.reconst.odf.OdfFit"><tt class="xref py py-class docutils literal"><span class="pre">dipy.reconst.odf.OdfFit</span></tt></a></p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumFit.msd_discrete" title="dipy.reconst.dsi.DiffusionSpectrumFit.msd_discrete"><tt class="xref py py-obj docutils literal"><span class="pre">msd_discrete</span></tt></a>([normalized])</td>
<td>Calculates the mean squared displacement on the discrete propagator</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumFit.odf" title="dipy.reconst.dsi.DiffusionSpectrumFit.odf"><tt class="xref py py-obj docutils literal"><span class="pre">odf</span></tt></a>(sphere)</td>
<td>Calculates the real discrete odf for a given discrete sphere</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumFit.pdf" title="dipy.reconst.dsi.DiffusionSpectrumFit.pdf"><tt class="xref py py-obj docutils literal"><span class="pre">pdf</span></tt></a>([normalized])</td>
<td>Applies the 3D FFT in the q-space grid to generate</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumFit.rtop_pdf" title="dipy.reconst.dsi.DiffusionSpectrumFit.rtop_pdf"><tt class="xref py py-obj docutils literal"><span class="pre">rtop_pdf</span></tt></a>([normalized])</td>
<td>Calculates the return to origin probability from the propagator, which is the propagator evaluated at zero (see Descoteaux et Al.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumFit.rtop_signal" title="dipy.reconst.dsi.DiffusionSpectrumFit.rtop_signal"><tt class="xref py py-obj docutils literal"><span class="pre">rtop_signal</span></tt></a>([filtering])</td>
<td>Calculates the return to origin probability (rtop) from the signal</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.dsi.DiffusionSpectrumFit.__init__">
<tt class="descname">__init__</tt><big>(</big><em>model</em>, <em>data</em><big>)</big><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumFit.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates PDF and ODF and other properties for a single voxel</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>model</strong> : object,</p>
<blockquote>
<div><p>DiffusionSpectrumModel</p>
</div></blockquote>
<p><strong>data</strong> : 1d ndarray,</p>
<blockquote class="last">
<div><p>signal values</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dsi.DiffusionSpectrumFit.msd_discrete">
<tt class="descname">msd_discrete</tt><big>(</big><em>normalized=True</em><big>)</big><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumFit.msd_discrete" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the mean squared displacement on the discrete propagator</p>
<dl class="docutils">
<dt>..math::</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">nowrap:</th><td class="field-body"><dl class="first docutils">
<dt>begin{equation}</dt>
<dd><p class="first last">MSD:{DSI}=int_{-infty}^{infty}int_{-infty}^{infty}int_{-infty}^{infty} P(hat{mathbf{r}}) cdot hat{mathbf{r}}^{2} dr_x dr_y dr_z</p>
</dd>
</dl>
<p class="last">end{equation}</p>
</td>
</tr>
</tbody>
</table>
</dd>
</dl>
<p>where <span class="math">\hat{\mathbf{r}}</span> is a point in the 3D Propagator space (see Wu et. al <a class="reference internal" href="#r107" id="id101">[R107]</a>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>normalized</strong> : boolean</p>
<blockquote>
<div><p>default true, normalize the propagator by its sum in order to obtain a pdf</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>msd</strong> : float</p>
<blockquote class="last">
<div><p>the mean square displacement</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r107" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R107]</td><td><em>(<a class="fn-backref" href="#id101">1</a>, <a class="fn-backref" href="#id102">2</a>)</em> Wu Y. et. al, &#8220;Hybrid diffusion imaging&#8221;, NeuroImage, vol 36,</td></tr>
</tbody>
</table>
<ol class="loweralpha simple" start="16">
<li>617-629, 2007.</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dsi.DiffusionSpectrumFit.odf">
<tt class="descname">odf</tt><big>(</big><em>sphere</em><big>)</big><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumFit.odf" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the real discrete odf for a given discrete sphere</p>
<dl class="docutils">
<dt>..math::</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">nowrap:</th><td class="field-body"><dl class="first docutils">
<dt>begin{equation}</dt>
<dd><p class="first last">psi_{DSI}(hat{mathbf{u}})=int_{0}^{infty}P(rhat{mathbf{u}})r^{2}dr</p>
</dd>
</dl>
<p class="last">end{equation}</p>
</td>
</tr>
</tbody>
</table>
</dd>
</dl>
<p>where <span class="math">\hat{\mathbf{u}}</span> is the unit vector which corresponds to a
sphere point.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dsi.DiffusionSpectrumFit.pdf">
<tt class="descname">pdf</tt><big>(</big><em>normalized=True</em><big>)</big><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumFit.pdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the 3D FFT in the q-space grid to generate
the diffusion propagator</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dsi.DiffusionSpectrumFit.rtop_pdf">
<tt class="descname">rtop_pdf</tt><big>(</big><em>normalized=True</em><big>)</big><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumFit.rtop_pdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the return to origin probability from the propagator, which is
the propagator evaluated at zero (see Descoteaux et Al. <a class="reference internal" href="#r108" id="id103">[R108]</a>, Tuch <a class="reference internal" href="#r109" id="id104">[R109]</a>, Wu et al. <a class="reference internal" href="#r110" id="id105">[R110]</a>)
rtop = P(0)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>normalized</strong> : boolean</p>
<blockquote>
<div><p>default true, normalize the propagator by its sum in order to obtain a pdf</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>rtop</strong> : float</p>
<blockquote class="last">
<div><p>the return to origin probability</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r108" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R108]</td><td><em>(<a class="fn-backref" href="#id103">1</a>, <a class="fn-backref" href="#id106">2</a>)</em> Descoteaux M. et. al, &#8220;Multiple q-shell diffusion propagator</td></tr>
</tbody>
</table>
<p>imaging&#8221;, Medical Image Analysis, vol 15, No. 4, p. 603-621, 2011.</p>
<table class="docutils citation" frame="void" id="r109" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R109]</td><td><em>(<a class="fn-backref" href="#id104">1</a>, <a class="fn-backref" href="#id107">2</a>)</em> Tuch D.S., &#8220;Diffusion MRI of Complex Tissue Structure&#8221;,
PhD Thesis, 2002.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r110" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R110]</td><td><em>(<a class="fn-backref" href="#id105">1</a>, <a class="fn-backref" href="#id108">2</a>)</em> Wu Y. et. al, &#8220;Computation of Diffusion Function Measures</td></tr>
</tbody>
</table>
<p>in q -Space Using Magnetic Resonance Hybrid Diffusion Imaging&#8221;, 
IEEE TRANSACTIONS ON MEDICAL IMAGING, vol. 27, No. 6, p. 858-865, 2008</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dsi.DiffusionSpectrumFit.rtop_signal">
<tt class="descname">rtop_signal</tt><big>(</big><em>filtering=True</em><big>)</big><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumFit.rtop_signal" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the return to origin probability (rtop) from the signal
rtop equals to the sum of all signal values</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>filtering</strong> : boolean</p>
<blockquote>
<div><p>default true, perform the hanning filtering</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>rtop</strong> : float</p>
<blockquote class="last">
<div><p>the return to origin probability</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="diffusionspectrummodel">
<h3><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumModel" title="dipy.reconst.dsi.DiffusionSpectrumModel"><tt class="xref py py-class docutils literal"><span class="pre">DiffusionSpectrumModel</span></tt></a><a class="headerlink" href="#diffusionspectrummodel" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.dsi.DiffusionSpectrumModel">
<em class="property">class </em><tt class="descclassname">dipy.reconst.dsi.</tt><tt class="descname">DiffusionSpectrumModel</tt><big>(</big><em>gtab</em>, <em>qgrid_size=17</em>, <em>r_start=2.1</em>, <em>r_end=6.0</em>, <em>r_step=0.2</em>, <em>filter_width=32</em>, <em>normalize_peaks=False</em><big>)</big><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.odf.OdfModel" title="dipy.reconst.odf.OdfModel"><tt class="xref py py-class docutils literal"><span class="pre">dipy.reconst.odf.OdfModel</span></tt></a>, <a class="reference internal" href="#dipy.reconst.cache.Cache" title="dipy.reconst.cache.Cache"><tt class="xref py py-class docutils literal"><span class="pre">dipy.reconst.cache.Cache</span></tt></a></p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">cache_clear</span></tt>()</td>
<td>Clear the cache.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">cache_get</span></tt>(tag,&nbsp;key[,&nbsp;default])</td>
<td>Retrieve a value from the cache.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">cache_set</span></tt>(tag,&nbsp;key,&nbsp;value)</td>
<td>Store a value in the cache.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumModel.fit" title="dipy.reconst.dsi.DiffusionSpectrumModel.fit"><tt class="xref py py-obj docutils literal"><span class="pre">fit</span></tt></a>(data[,&nbsp;mask])</td>
<td>Fit method for every voxel in data</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.dsi.DiffusionSpectrumModel.__init__">
<tt class="descname">__init__</tt><big>(</big><em>gtab</em>, <em>qgrid_size=17</em>, <em>r_start=2.1</em>, <em>r_end=6.0</em>, <em>r_step=0.2</em>, <em>filter_width=32</em>, <em>normalize_peaks=False</em><big>)</big><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumModel.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Diffusion Spectrum Imaging</p>
<p>The theoretical idea underlying this method is that the diffusion
propagator <span class="math">P(\mathbf{r})</span> (probability density function of the average
spin displacements) can be estimated by applying 3D FFT to the signal
values <span class="math">S(\mathbf{q})</span></p>
<dl class="docutils">
<dt>..math::</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">nowrap:</th><td class="field-body"><dl class="first docutils">
<dt>begin{eqnarray}</dt>
<dd><p class="first last">P(mathbf{r}) &amp; = &amp; S_{0}^{-1}int S(mathbf{q})exp(-i2pimathbf{q}cdotmathbf{r})dmathbf{r}</p>
</dd>
</dl>
<p class="last">end{eqnarray}</p>
</td>
</tr>
</tbody>
</table>
</dd>
</dl>
<p>where <span class="math">\mathbf{r}</span> is the displacement vector and <span class="math">\mathbf{q}</span> is the
wavector which corresponds to different gradient directions. Method
used to calculate the ODFs. Here we implement the method proposed by
Wedeen et. al <a class="reference internal" href="#r115" id="id109">[R115]</a>.</p>
<p>The main assumption for this model is fast gradient switching and that
the acquisition gradients will sit on a keyhole Cartesian grid in
q_space <a class="reference internal" href="#r117" id="id110">[R117]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>gtab</strong> : GradientTable,</p>
<blockquote>
<div><p>Gradient directions and bvalues container class</p>
</div></blockquote>
<p><strong>qgrid_size</strong> : int,</p>
<blockquote>
<div><p>has to be an odd number. Sets the size of the q_space grid.
For example if qgrid_size is 17 then the shape of the grid will be
<tt class="docutils literal"><span class="pre">(17,</span> <span class="pre">17,</span> <span class="pre">17)</span></tt>.</p>
</div></blockquote>
<p><strong>r_start</strong> : float,</p>
<blockquote>
<div><p>ODF is sampled radially in the PDF. This parameters shows where the
sampling should start.</p>
</div></blockquote>
<p><strong>r_end</strong> : float,</p>
<blockquote>
<div><p>Radial endpoint of ODF sampling</p>
</div></blockquote>
<p><strong>r_step</strong> : float,</p>
<blockquote>
<div><p>Step size of the ODf sampling from r_start to r_end</p>
</div></blockquote>
<p><strong>filter_width</strong> : float,</p>
<blockquote class="last">
<div><p>Strength of the hanning filter</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-obj docutils literal"><span class="pre">dipy.reconst.gqi.GeneralizedQSampling</span></tt></p>
</div>
<p class="rubric">Notes</p>
<p>A. Have in mind that DSI expects gradients on both hemispheres. If your
gradients span only one hemisphere you need to duplicate the data and
project them to the other hemisphere before calling this class. The
function dipy.reconst.dsi.half_to_full_qspace can be used for this
purpose.</p>
<p>B. If you increase the size of the grid (parameter qgrid_size) you will
most likely also need to update the r_* parameters. This is because
the added zero padding from the increase of gqrid_size also introduces
a scaling of the PDF.</p>
<ol class="upperalpha simple" start="3">
<li>We assume that data only one b0 volume is provided.</li>
</ol>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r115" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R115]</td><td><em>(<a class="fn-backref" href="#id109">1</a>, <a class="fn-backref" href="#id111">2</a>)</em> Wedeen V.J et. al, &#8220;Mapping Complex Tissue Architecture With</td></tr>
</tbody>
</table>
<p>Diffusion Spectrum Magnetic Resonance Imaging&#8221;, MRM 2005.</p>
<table class="docutils citation" frame="void" id="r116" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id112">[R116]</a></td><td>Canales-Rodriguez E.J et. al, &#8220;Deconvolution in Diffusion</td></tr>
</tbody>
</table>
<p>Spectrum Imaging&#8221;, Neuroimage, 2010.</p>
<table class="docutils citation" frame="void" id="r117" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R117]</td><td><em>(<a class="fn-backref" href="#id110">1</a>, <a class="fn-backref" href="#id113">2</a>)</em> Garyfallidis E, &#8220;Towards an accurate brain tractography&#8221;, PhD</td></tr>
</tbody>
</table>
<p>thesis, University of Cambridge, 2012.</p>
<p class="rubric">Examples</p>
<p>In this example where we provide the data, a gradient table
and a reconstruction sphere, we calculate generalized FA for the first
voxel in the data with the reconstruction performed using DSI.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.data</span> <span class="kn">import</span> <span class="n">dsi_voxels</span><span class="p">,</span> <span class="n">get_sphere</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">,</span> <span class="n">gtab</span> <span class="o">=</span> <span class="n">dsi_voxels</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere</span> <span class="o">=</span> <span class="n">get_sphere</span><span class="p">(</span><span class="s">&#39;symmetric724&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.reconst.dsi</span> <span class="kn">import</span> <span class="n">DiffusionSpectrumModel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ds</span> <span class="o">=</span> <span class="n">DiffusionSpectrumModel</span><span class="p">(</span><span class="n">gtab</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsfit</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.reconst.odf</span> <span class="kn">import</span> <span class="n">gfa</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">gfa</span><span class="p">(</span><span class="n">dsfit</span><span class="o">.</span><span class="n">odf</span><span class="p">(</span><span class="n">sphere</span><span class="p">))[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">0.11</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dsi.DiffusionSpectrumModel.fit">
<tt class="descname">fit</tt><big>(</big><em>data</em>, <em>mask=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumModel.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="odffit">
<h3><a class="reference internal" href="#dipy.reconst.dsi.OdfFit" title="dipy.reconst.dsi.OdfFit"><tt class="xref py py-class docutils literal"><span class="pre">OdfFit</span></tt></a><a class="headerlink" href="#odffit" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.dsi.OdfFit">
<em class="property">class </em><tt class="descclassname">dipy.reconst.dsi.</tt><tt class="descname">OdfFit</tt><big>(</big><em>model</em>, <em>data</em><big>)</big><a class="headerlink" href="#dipy.reconst.dsi.OdfFit" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstFit" title="dipy.reconst.base.ReconstFit"><tt class="xref py py-class docutils literal"><span class="pre">dipy.reconst.base.ReconstFit</span></tt></a></p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dsi.OdfFit.odf" title="dipy.reconst.dsi.OdfFit.odf"><tt class="xref py py-obj docutils literal"><span class="pre">odf</span></tt></a>(sphere)</td>
<td>To be implemented but specific odf models</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.dsi.OdfFit.__init__">
<tt class="descname">__init__</tt><big>(</big><em>model</em>, <em>data</em><big>)</big><a class="headerlink" href="#dipy.reconst.dsi.OdfFit.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.reconst.dsi.OdfFit.odf">
<tt class="descname">odf</tt><big>(</big><em>sphere</em><big>)</big><a class="headerlink" href="#dipy.reconst.dsi.OdfFit.odf" title="Permalink to this definition">¶</a></dt>
<dd><p>To be implemented but specific odf models</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="odfmodel">
<h3><a class="reference internal" href="#dipy.reconst.dsi.OdfModel" title="dipy.reconst.dsi.OdfModel"><tt class="xref py py-class docutils literal"><span class="pre">OdfModel</span></tt></a><a class="headerlink" href="#odfmodel" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.dsi.OdfModel">
<em class="property">class </em><tt class="descclassname">dipy.reconst.dsi.</tt><tt class="descname">OdfModel</tt><big>(</big><em>gtab</em><big>)</big><a class="headerlink" href="#dipy.reconst.dsi.OdfModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><tt class="xref py py-class docutils literal"><span class="pre">dipy.reconst.base.ReconstModel</span></tt></a></p>
<p>An abstract class to be sub-classed by specific odf models</p>
<p>All odf models should provide a fit method which may take data as it&#8217;s
first and only argument.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dsi.OdfModel.fit" title="dipy.reconst.dsi.OdfModel.fit"><tt class="xref py py-obj docutils literal"><span class="pre">fit</span></tt></a>(data)</td>
<td>To be implemented by specific odf models</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.dsi.OdfModel.__init__">
<tt class="descname">__init__</tt><big>(</big><em>gtab</em><big>)</big><a class="headerlink" href="#dipy.reconst.dsi.OdfModel.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.reconst.dsi.OdfModel.fit">
<tt class="descname">fit</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#dipy.reconst.dsi.OdfModel.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>To be implemented by specific odf models</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="lr-deconv">
<h3>LR_deconv<a class="headerlink" href="#lr-deconv" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dsi.LR_deconv">
<tt class="descclassname">dipy.reconst.dsi.</tt><tt class="descname">LR_deconv</tt><big>(</big><em>prop</em>, <em>psf</em>, <em>numit=5</em>, <em>acc_factor=1</em><big>)</big><a class="headerlink" href="#dipy.reconst.dsi.LR_deconv" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform Lucy-Richardson deconvolution algorithm on a 3D array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>prop</strong> : 3-D ndarray of dtype float</p>
<blockquote>
<div><p>The 3D volume to be deconvolve</p>
</div></blockquote>
<p><strong>psf</strong> : 3-D ndarray of dtype float</p>
<blockquote>
<div><p>The filter that will be used for the deconvolution.</p>
</div></blockquote>
<p><strong>numit</strong> : int</p>
<blockquote>
<div><p>Number of Lucy-Richardson iteration to perform.</p>
</div></blockquote>
<p><strong>acc_factor</strong> : float</p>
<blockquote class="last">
<div><p>Exponential acceleration factor as in <a class="reference internal" href="#r118" id="id114">[R118]</a>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r118" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R118]</td><td><em>(<a class="fn-backref" href="#id114">1</a>, <a class="fn-backref" href="#id115">2</a>)</em> Biggs David S.C. et. al, &#8220;Acceleration of Iterative Image
Restoration Algorithms&#8221;, Applied Optics, vol. 36, No. 8, p. 1766-1775,
1997.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="create-qspace">
<h3>create_qspace<a class="headerlink" href="#create-qspace" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dsi.create_qspace">
<tt class="descclassname">dipy.reconst.dsi.</tt><tt class="descname">create_qspace</tt><big>(</big><em>gtab</em>, <em>origin</em><big>)</big><a class="headerlink" href="#dipy.reconst.dsi.create_qspace" title="Permalink to this definition">¶</a></dt>
<dd><p>create the 3D grid which holds the signal values (q-space)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>gtab</strong> : GradientTable</p>
<p><strong>origin</strong> : (3,) ndarray</p>
<blockquote>
<div><p>center of the qspace</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>qgrid</strong> : ndarray</p>
<blockquote class="last">
<div><p>qspace coordinates</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="create-qtable">
<h3>create_qtable<a class="headerlink" href="#create-qtable" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dsi.create_qtable">
<tt class="descclassname">dipy.reconst.dsi.</tt><tt class="descname">create_qtable</tt><big>(</big><em>gtab</em><big>)</big><a class="headerlink" href="#dipy.reconst.dsi.create_qtable" title="Permalink to this definition">¶</a></dt>
<dd><p>create a normalized version of gradients</p>
</dd></dl>

</div>
<div class="section" id="fftn">
<h3>fftn<a class="headerlink" href="#fftn" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dsi.fftn">
<tt class="descclassname">dipy.reconst.dsi.</tt><tt class="descname">fftn</tt><big>(</big><em>x</em>, <em>shape=None</em>, <em>axes=None</em>, <em>overwrite_x=0</em><big>)</big><a class="headerlink" href="#dipy.reconst.dsi.fftn" title="Permalink to this definition">¶</a></dt>
<dd><p>Return multidimensional discrete Fourier transform.</p>
<p>The returned array contains:</p>
<div class="highlight-python"><div class="highlight"><pre>y[j_1,..,j_d] = sum[k_1=0..n_1-1, ..., k_d=0..n_d-1]
   x[k_1,..,k_d] * prod[i=1..d] exp(-sqrt(-1)*2*pi/n_i * j_i * k_i)
</pre></div>
</div>
<p>where d = len(x.shape) and n = x.shape.
Note that <tt class="docutils literal"><span class="pre">y[...,</span> <span class="pre">-j_i,</span> <span class="pre">...]</span> <span class="pre">=</span> <span class="pre">y[...,</span> <span class="pre">n_i-j_i,</span> <span class="pre">...].conjugate()</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x</strong> : array_like</p>
<blockquote>
<div><p>The (n-dimensional) array to transform.</p>
</div></blockquote>
<p><strong>shape</strong> : tuple of ints, optional</p>
<blockquote>
<div><p>The shape of the result.  If both <cite>shape</cite> and <cite>axes</cite> (see below) are
None, <cite>shape</cite> is <tt class="docutils literal"><span class="pre">x.shape</span></tt>; if <cite>shape</cite> is None but <cite>axes</cite> is
not None, then <cite>shape</cite> is <tt class="docutils literal"><span class="pre">scipy.take(x.shape,</span> <span class="pre">axes,</span> <span class="pre">axis=0)</span></tt>.
If <tt class="docutils literal"><span class="pre">shape[i]</span> <span class="pre">&gt;</span> <span class="pre">x.shape[i]</span></tt>, the i-th dimension is padded with zeros.
If <tt class="docutils literal"><span class="pre">shape[i]</span> <span class="pre">&lt;</span> <span class="pre">x.shape[i]</span></tt>, the i-th dimension is truncated to
length <tt class="docutils literal"><span class="pre">shape[i]</span></tt>.</p>
</div></blockquote>
<p><strong>axes</strong> : array_like of ints, optional</p>
<blockquote>
<div><p>The axes of <cite>x</cite> (<cite>y</cite> if <cite>shape</cite> is not None) along which the
transform is applied.</p>
</div></blockquote>
<p><strong>overwrite_x</strong> : bool, optional</p>
<blockquote>
<div><p>If True, the contents of <cite>x</cite> can be destroyed.  Default is False.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>y</strong> : complex-valued n-dimensional numpy array</p>
<blockquote class="last">
<div><p>The (n-dimensional) DFT of the input array.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-obj docutils literal"><span class="pre">ifftn</span></tt></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="mi">8</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">fftn</span><span class="p">(</span><span class="n">ifftn</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="fftshift">
<h3>fftshift<a class="headerlink" href="#fftshift" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dsi.fftshift">
<tt class="descclassname">dipy.reconst.dsi.</tt><tt class="descname">fftshift</tt><big>(</big><em>x</em>, <em>axes=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.dsi.fftshift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift the zero-frequency component to the center of the spectrum.</p>
<p>This function swaps half-spaces for all axes listed (defaults to all).
Note that <tt class="docutils literal"><span class="pre">y[0]</span></tt> is the Nyquist component only if <tt class="docutils literal"><span class="pre">len(x)</span></tt> is even.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x</strong> : array_like</p>
<blockquote>
<div><p>Input array.</p>
</div></blockquote>
<p><strong>axes</strong> : int or shape tuple, optional</p>
<blockquote>
<div><p>Axes over which to shift.  Default is None, which shifts all axes.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>y</strong> : ndarray</p>
<blockquote class="last">
<div><p>The shifted array.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#dipy.reconst.dsi.ifftshift" title="dipy.reconst.dsi.ifftshift"><tt class="xref py py-obj docutils literal"><span class="pre">ifftshift</span></tt></a></dt>
<dd>The inverse of <cite>fftshift</cite>.</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freqs</span>
<span class="go">array([ 0.,  1.,  2.,  3.,  4., -5., -4., -3., -2., -1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">freqs</span><span class="p">)</span>
<span class="go">array([-5., -4., -3., -2., -1.,  0.,  1.,  2.,  3.,  4.])</span>
</pre></div>
</div>
<p>Shift the zero-frequency component only along the second axis:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freqs</span>
<span class="go">array([[ 0.,  1.,  2.],</span>
<span class="go">       [ 3.,  4., -4.],</span>
<span class="go">       [-3., -2., -1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,))</span>
<span class="go">array([[ 2.,  0.,  1.],</span>
<span class="go">       [-4.,  3.,  4.],</span>
<span class="go">       [-1., -3., -2.]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="gen-psf">
<h3>gen_PSF<a class="headerlink" href="#gen-psf" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dsi.gen_PSF">
<tt class="descclassname">dipy.reconst.dsi.</tt><tt class="descname">gen_PSF</tt><big>(</big><em>qgrid_sampling</em>, <em>siz_x</em>, <em>siz_y</em>, <em>siz_z</em><big>)</big><a class="headerlink" href="#dipy.reconst.dsi.gen_PSF" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a PSF for DSI Deconvolution by taking the ifft of the binary
q-space sampling mask and truncating it to keep only the center.</p>
</dd></dl>

</div>
<div class="section" id="gfa">
<h3>gfa<a class="headerlink" href="#gfa" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dsi.gfa">
<tt class="descclassname">dipy.reconst.dsi.</tt><tt class="descname">gfa</tt><big>(</big><em>samples</em><big>)</big><a class="headerlink" href="#dipy.reconst.dsi.gfa" title="Permalink to this definition">¶</a></dt>
<dd><p>The general fractional anisotropy of a function evaluated
on the unit sphere</p>
</dd></dl>

</div>
<div class="section" id="half-to-full-qspace">
<h3>half_to_full_qspace<a class="headerlink" href="#half-to-full-qspace" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dsi.half_to_full_qspace">
<tt class="descclassname">dipy.reconst.dsi.</tt><tt class="descname">half_to_full_qspace</tt><big>(</big><em>data</em>, <em>gtab</em><big>)</big><a class="headerlink" href="#dipy.reconst.dsi.half_to_full_qspace" title="Permalink to this definition">¶</a></dt>
<dd><p>Half to full Cartesian grid mapping</p>
<p>Useful when dMRI data are provided in one qspace hemisphere as
DiffusionSpectrum expects data to be in full qspace.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : array, shape (X, Y, Z, W)</p>
<blockquote>
<div><p>where (X, Y, Z) volume size and W number of gradient directions</p>
</div></blockquote>
<p><strong>gtab</strong> : GradientTable</p>
<blockquote>
<div><p>container for b-values and b-vectors (gradient directions)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>new_data</strong> : array, shape (X, Y, Z, 2 * W -1)</p>
<p class="last"><strong>new_gtab</strong> : GradientTable</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>We assume here that only on b0 is provided with the initial data. If that
is not the case then you will need to write your own preparation function
before providing the gradients and the data to the DiffusionSpectrumModel
class.</p>
</dd></dl>

</div>
<div class="section" id="hanning-filter">
<h3>hanning_filter<a class="headerlink" href="#hanning-filter" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dsi.hanning_filter">
<tt class="descclassname">dipy.reconst.dsi.</tt><tt class="descname">hanning_filter</tt><big>(</big><em>gtab</em>, <em>filter_width</em><big>)</big><a class="headerlink" href="#dipy.reconst.dsi.hanning_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>create a hanning window</p>
<p>The signal is premultiplied by a Hanning window before
Fourier transform in order to ensure a smooth attenuation
of the signal at high q values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>gtab</strong> : GradientTable</p>
<p><strong>filter_width</strong> : int</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>filter</strong> : (N,) ndarray</p>
<blockquote class="last">
<div><p>where N is the number of non-b0 gradient directions</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="ifftshift">
<h3>ifftshift<a class="headerlink" href="#ifftshift" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dsi.ifftshift">
<tt class="descclassname">dipy.reconst.dsi.</tt><tt class="descname">ifftshift</tt><big>(</big><em>x</em>, <em>axes=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.dsi.ifftshift" title="Permalink to this definition">¶</a></dt>
<dd><p>The inverse of fftshift.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x</strong> : array_like</p>
<blockquote>
<div><p>Input array.</p>
</div></blockquote>
<p><strong>axes</strong> : int or shape tuple, optional</p>
<blockquote>
<div><p>Axes over which to calculate.  Defaults to None, which shifts all axes.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>y</strong> : ndarray</p>
<blockquote class="last">
<div><p>The shifted array.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#dipy.reconst.dsi.fftshift" title="dipy.reconst.dsi.fftshift"><tt class="xref py py-obj docutils literal"><span class="pre">fftshift</span></tt></a></dt>
<dd>Shift zero-frequency component to the center of the spectrum.</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freqs</span>
<span class="go">array([[ 0.,  1.,  2.],</span>
<span class="go">       [ 3.,  4., -4.],</span>
<span class="go">       [-3., -2., -1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">freqs</span><span class="p">))</span>
<span class="go">array([[ 0.,  1.,  2.],</span>
<span class="go">       [ 3.,  4., -4.],</span>
<span class="go">       [-3., -2., -1.]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="id116">
<h3>local_maxima<a class="headerlink" href="#id116" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dsi.local_maxima">
<tt class="descclassname">dipy.reconst.dsi.</tt><tt class="descname">local_maxima</tt><big>(</big><em>odf</em>, <em>edges</em><big>)</big><a class="headerlink" href="#dipy.reconst.dsi.local_maxima" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the local maxima of a function evaluated on a discrete set of points.</p>
<p>If a function is evaluated on some set of points where each pair of
neighboring points is an edge in edges, find the local maxima.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>odf</strong> : array, 1d, dtype=double</p>
<blockquote>
<div><p>The function evaluated on a set of discrete points.</p>
</div></blockquote>
<p><strong>edges</strong> : array (N, 2)</p>
<blockquote>
<div><p>The set of neighbor relations between the points. Every edge, ie
<cite>edges[i, :]</cite>, is a pair of neighboring points.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>peak_values</strong> : ndarray</p>
<blockquote>
<div><p>Value of odf at a maximum point. Peak values is sorted in descending
order.</p>
</div></blockquote>
<p><strong>peak_indices</strong> : ndarray</p>
<blockquote class="last">
<div><p>Indices of maximum points. Sorted in the same order as <cite>peak_values</cite> so
<cite>odf[peak_indices[i]] == peak_values[i]</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="dipy.core.html#module-dipy.core.sphere" title="dipy.core.sphere"><tt class="xref py py-obj docutils literal"><span class="pre">dipy.core.sphere</span></tt></a></p>
</div>
</dd></dl>

</div>
<div class="section" id="map-coordinates">
<h3>map_coordinates<a class="headerlink" href="#map-coordinates" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dsi.map_coordinates">
<tt class="descclassname">dipy.reconst.dsi.</tt><tt class="descname">map_coordinates</tt><big>(</big><em>input</em>, <em>coordinates</em>, <em>output=None</em>, <em>order=3</em>, <em>mode='constant'</em>, <em>cval=0.0</em>, <em>prefilter=True</em><big>)</big><a class="headerlink" href="#dipy.reconst.dsi.map_coordinates" title="Permalink to this definition">¶</a></dt>
<dd><p>Map the input array to new coordinates by interpolation.</p>
<p>The array of coordinates is used to find, for each point in the output,
the corresponding coordinates in the input. The value of the input at
those coordinates is determined by spline interpolation of the
requested order.</p>
<p>The shape of the output is derived from that of the coordinate
array by dropping the first axis. The values of the array along
the first axis are the coordinates in the input array at which the
output value is found.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>input</strong> : ndarray</p>
<blockquote>
<div><p>The input array.</p>
</div></blockquote>
<p><strong>coordinates</strong> : array_like</p>
<blockquote>
<div><p>The coordinates at which <cite>input</cite> is evaluated.</p>
</div></blockquote>
<p><strong>output</strong> : ndarray or dtype, optional</p>
<blockquote>
<div><p>The array in which to place the output, or the dtype of the returned
array.</p>
</div></blockquote>
<p><strong>order</strong> : int, optional</p>
<blockquote>
<div><p>The order of the spline interpolation, default is 3.
The order has to be in the range 0-5.</p>
</div></blockquote>
<p><strong>mode</strong> : str, optional</p>
<blockquote>
<div><p>Points outside the boundaries of the input are filled according
to the given mode (&#8216;constant&#8217;, &#8216;nearest&#8217;, &#8216;reflect&#8217; or &#8216;wrap&#8217;).
Default is &#8216;constant&#8217;.</p>
</div></blockquote>
<p><strong>cval</strong> : scalar, optional</p>
<blockquote>
<div><p>Value used for points outside the boundaries of the input if
<tt class="docutils literal"><span class="pre">mode='constant'</span></tt>. Default is 0.0</p>
</div></blockquote>
<p><strong>prefilter</strong> : bool, optional</p>
<blockquote>
<div><p>The parameter prefilter determines if the input is pre-filtered with
<cite>spline_filter</cite> before interpolation (necessary for spline
interpolation of order &gt; 1).  If False, it is assumed that the input is
already filtered. Default is True.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>map_coordinates</strong> : ndarray</p>
<blockquote class="last">
<div><p>The result of transforming the input. The shape of the output is
derived from that of <cite>coordinates</cite> by dropping the first axis.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-obj docutils literal"><span class="pre">spline_filter</span></tt>, <tt class="xref py py-obj docutils literal"><span class="pre">geometric_transform</span></tt>, <tt class="xref py py-obj docutils literal"><span class="pre">scipy.interpolate</span></tt></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">ndimage</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">12.</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[  0.,   1.,   2.],</span>
<span class="go">       [  3.,   4.,   5.],</span>
<span class="go">       [  6.,   7.,   8.],</span>
<span class="go">       [  9.,  10.,  11.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ndimage</span><span class="o">.</span><span class="n">map_coordinates</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[ 2.  7.]</span>
</pre></div>
</div>
<p>Above, the interpolated value of a[0.5, 0.5] gives output[0], while
a[2, 1] is output[1].</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ndimage</span><span class="o">.</span><span class="n">map_coordinates</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">inds</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cval</span><span class="o">=-</span><span class="mf">33.3</span><span class="p">)</span>
<span class="go">array([  2. , -33.3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ndimage</span><span class="o">.</span><span class="n">map_coordinates</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">inds</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;nearest&#39;</span><span class="p">)</span>
<span class="go">array([ 2.,  8.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ndimage</span><span class="o">.</span><span class="n">map_coordinates</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">inds</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="go">array([ True, False], dtype=bool</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="id117">
<h3>multi_voxel_fit<a class="headerlink" href="#id117" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dsi.multi_voxel_fit">
<tt class="descclassname">dipy.reconst.dsi.</tt><tt class="descname">multi_voxel_fit</tt><big>(</big><em>single_voxel_fit</em><big>)</big><a class="headerlink" href="#dipy.reconst.dsi.multi_voxel_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Method decorator to turn a single voxel model fit
definition into a multi voxel model fit definition</p>
</dd></dl>

</div>
<div class="section" id="pdf-interp-coords">
<h3>pdf_interp_coords<a class="headerlink" href="#pdf-interp-coords" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dsi.pdf_interp_coords">
<tt class="descclassname">dipy.reconst.dsi.</tt><tt class="descname">pdf_interp_coords</tt><big>(</big><em>sphere</em>, <em>rradius</em>, <em>origin</em><big>)</big><a class="headerlink" href="#dipy.reconst.dsi.pdf_interp_coords" title="Permalink to this definition">¶</a></dt>
<dd><p>Precompute coordinates for ODF calculation from the PDF</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sphere</strong> : object,</p>
<blockquote>
<div><p>Sphere</p>
</div></blockquote>
<p><strong>rradius</strong> : array, shape (N,)</p>
<blockquote>
<div><p>line interpolation points</p>
</div></blockquote>
<p><strong>origin</strong> : array, shape (3,)</p>
<blockquote class="last">
<div><p>center of the grid</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="pdf-odf">
<h3>pdf_odf<a class="headerlink" href="#pdf-odf" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dsi.pdf_odf">
<tt class="descclassname">dipy.reconst.dsi.</tt><tt class="descname">pdf_odf</tt><big>(</big><em>Pr</em>, <em>rradius</em>, <em>interp_coords</em><big>)</big><a class="headerlink" href="#dipy.reconst.dsi.pdf_odf" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the real ODF from the diffusion propagator(PDF) Pr</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>Pr</strong> : array, shape (X, X, X)</p>
<blockquote>
<div><p>probability density function</p>
</div></blockquote>
<p><strong>rradius</strong> : array, shape (N,)</p>
<blockquote>
<div><p>interpolation range on the radius</p>
</div></blockquote>
<p><strong>interp_coords</strong> : array, shape (3, M, N)</p>
<blockquote class="last">
<div><p>coordinates in the pdf for interpolating the odf</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="project-hemisph-bvecs">
<h3>project_hemisph_bvecs<a class="headerlink" href="#project-hemisph-bvecs" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dsi.project_hemisph_bvecs">
<tt class="descclassname">dipy.reconst.dsi.</tt><tt class="descname">project_hemisph_bvecs</tt><big>(</big><em>gtab</em><big>)</big><a class="headerlink" href="#dipy.reconst.dsi.project_hemisph_bvecs" title="Permalink to this definition">¶</a></dt>
<dd><p>Project any near identical bvecs to the other hemisphere</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>gtab</strong> : object,</p>
<blockquote class="last">
<div><p>GradientTable</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Useful only when working with some types of dsi data.</p>
</dd></dl>

</div>
<div class="section" id="remove-similar-vertices">
<h3>remove_similar_vertices<a class="headerlink" href="#remove-similar-vertices" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dsi.remove_similar_vertices">
<tt class="descclassname">dipy.reconst.dsi.</tt><tt class="descname">remove_similar_vertices</tt><big>(</big><em>vertices</em>, <em>theta</em><big>)</big><a class="headerlink" href="#dipy.reconst.dsi.remove_similar_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns vertices that are separated by at least theta degrees from all
other vertices. Vertex v and -v are considered the same so if v and -v are
both in <cite>vertices</cite> only one is kept. Also if v and w are both in vertices,
w must be separated by theta degrees from both v and -v to be unique.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>vertices</strong> : (N, 3) ndarray</p>
<blockquote>
<div><p>N unit vectors</p>
</div></blockquote>
<p><strong>theta</strong> : float</p>
<blockquote>
<div><p>The minimum separation between vertices in degrees.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>unique_vertices</strong> : (M, 3) ndarray</p>
<blockquote>
<div><p>Vertices sufficiently separated from one another.</p>
</div></blockquote>
<p><strong>mapping</strong> : (N,) ndarray</p>
<blockquote class="last">
<div><p>Indices into unique_vertices. For each vertex in <cite>vertices</cite> the index
of a vertex in <cite>unique_vertices</cite> that is less than theta degrees away.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="threshold-propagator">
<h3>threshold_propagator<a class="headerlink" href="#threshold-propagator" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dsi.threshold_propagator">
<tt class="descclassname">dipy.reconst.dsi.</tt><tt class="descname">threshold_propagator</tt><big>(</big><em>P</em>, <em>estimated_snr=15.0</em><big>)</big><a class="headerlink" href="#dipy.reconst.dsi.threshold_propagator" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies hard threshold on the propagator to remove background noise for the
deconvolution.</p>
</dd></dl>

</div>
<div class="section" id="id118">
<h3><a class="reference internal" href="#dipy.reconst.dti.ReconstFit" title="dipy.reconst.dti.ReconstFit"><tt class="xref py py-class docutils literal"><span class="pre">ReconstFit</span></tt></a><a class="headerlink" href="#id118" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.dti.ReconstFit">
<em class="property">class </em><tt class="descclassname">dipy.reconst.dti.</tt><tt class="descname">ReconstFit</tt><big>(</big><em>model</em>, <em>data</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.ReconstFit" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></a></p>
<p>Abstract class which holds the fit result of ReconstModel</p>
<p>For example that could be holding FA or GFA etc.</p>
<dl class="method">
<dt id="dipy.reconst.dti.ReconstFit.__init__">
<tt class="descname">__init__</tt><big>(</big><em>model</em>, <em>data</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.ReconstFit.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="id119">
<h3><a class="reference internal" href="#dipy.reconst.dti.ReconstModel" title="dipy.reconst.dti.ReconstModel"><tt class="xref py py-class docutils literal"><span class="pre">ReconstModel</span></tt></a><a class="headerlink" href="#id119" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.dti.ReconstModel">
<em class="property">class </em><tt class="descclassname">dipy.reconst.dti.</tt><tt class="descname">ReconstModel</tt><big>(</big><em>gtab</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.ReconstModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></a></p>
<p>Abstract class for signal reconstruction models</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.ReconstModel.fit" title="dipy.reconst.dti.ReconstModel.fit"><tt class="xref py py-obj docutils literal"><span class="pre">fit</span></tt></a>(data[,&nbsp;mask])</td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.dti.ReconstModel.__init__">
<tt class="descname">__init__</tt><big>(</big><em>gtab</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.ReconstModel.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialization of the abstract class for signal reconstruction models</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>gtab</strong> : GradientTable class instance</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dti.ReconstModel.fit">
<tt class="descname">fit</tt><big>(</big><em>data</em>, <em>mask=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.ReconstModel.fit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="sphere">
<h3><a class="reference internal" href="#dipy.reconst.dti.Sphere" title="dipy.reconst.dti.Sphere"><tt class="xref py py-class docutils literal"><span class="pre">Sphere</span></tt></a><a class="headerlink" href="#sphere" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.dti.Sphere">
<em class="property">class </em><tt class="descclassname">dipy.reconst.dti.</tt><tt class="descname">Sphere</tt><big>(</big><em>x=None</em>, <em>y=None</em>, <em>z=None</em>, <em>theta=None</em>, <em>phi=None</em>, <em>xyz=None</em>, <em>faces=None</em>, <em>edges=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.Sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></a></p>
<p>Points on the unit sphere.</p>
<p>The sphere can be constructed using one of three conventions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Sphere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="n">Sphere</span><span class="p">(</span><span class="n">xyz</span><span class="o">=</span><span class="n">xyz</span><span class="p">)</span>
<span class="n">Sphere</span><span class="p">(</span><span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="o">=</span><span class="n">phi</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x, y, z</strong> : 1-D array_like</p>
<blockquote>
<div><p>Vertices as x-y-z coordinates.</p>
</div></blockquote>
<p><strong>theta, phi</strong> : 1-D array_like</p>
<blockquote>
<div><p>Vertices as spherical coordinates.  Theta and phi are the inclination
and azimuth angles respectively.</p>
</div></blockquote>
<p><strong>xyz</strong> : (N, 3) ndarray</p>
<blockquote>
<div><p>Vertices as x-y-z coordinates.</p>
</div></blockquote>
<p><strong>faces</strong> : (N, 3) ndarray</p>
<blockquote>
<div><p>Indices into vertices that form triangular faces.  If unspecified,
the faces are computed using a Delaunay triangulation.</p>
</div></blockquote>
<p><strong>edges</strong> : (N, 2) ndarray</p>
<blockquote class="last">
<div><p>Edges between vertices.  If unspecified, the edges are
derived from the faces.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.Sphere.edges" title="dipy.reconst.dti.Sphere.edges"><tt class="xref py py-obj docutils literal"><span class="pre">edges</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.Sphere.faces" title="dipy.reconst.dti.Sphere.faces"><tt class="xref py py-obj docutils literal"><span class="pre">faces</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.Sphere.find_closest" title="dipy.reconst.dti.Sphere.find_closest"><tt class="xref py py-obj docutils literal"><span class="pre">find_closest</span></tt></a>(xyz)</td>
<td>Find the index of the vertex in the Sphere closest to the input vector</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.Sphere.subdivide" title="dipy.reconst.dti.Sphere.subdivide"><tt class="xref py py-obj docutils literal"><span class="pre">subdivide</span></tt></a>([n])</td>
<td>Subdivides each face of the sphere into four new faces.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.Sphere.vertices" title="dipy.reconst.dti.Sphere.vertices"><tt class="xref py py-obj docutils literal"><span class="pre">vertices</span></tt></a>()</td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.dti.Sphere.__init__">
<tt class="descname">__init__</tt><big>(</big><em>x=None</em>, <em>y=None</em>, <em>z=None</em>, <em>theta=None</em>, <em>phi=None</em>, <em>xyz=None</em>, <em>faces=None</em>, <em>edges=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.Sphere.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="dipy.reconst.dti.Sphere.edges">
<em class="property">static </em><tt class="descname">edges</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.dti.Sphere.edges" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="dipy.reconst.dti.Sphere.faces">
<em class="property">static </em><tt class="descname">faces</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.dti.Sphere.faces" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.reconst.dti.Sphere.find_closest">
<tt class="descname">find_closest</tt><big>(</big><em>xyz</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.Sphere.find_closest" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the index of the vertex in the Sphere closest to the input vector</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>xyz</strong> : array-like, 3 elements</p>
<blockquote class="last">
<div><p>A unit vector</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dti.Sphere.subdivide">
<tt class="descname">subdivide</tt><big>(</big><em>n=1</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.Sphere.subdivide" title="Permalink to this definition">¶</a></dt>
<dd><p>Subdivides each face of the sphere into four new faces.</p>
<p>New vertices are created at a, b, and c. Then each face [x, y, z] is
divided into faces [x, a, c], [y, a, b], [z, b, c], and [a, b, c].</p>
<div class="highlight-python"><div class="highlight"><pre>   y
   /               /               a/____
/\    /            /  \  /             /____\/____          x      c     z
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>n</strong> : int, optional</p>
<blockquote>
<div><p>The number of subdivisions to preform.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>new_sphere</strong> : Sphere</p>
<blockquote class="last">
<div><p>The subdivided sphere.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="dipy.reconst.dti.Sphere.vertices">
<em class="property">static </em><tt class="descname">vertices</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.dti.Sphere.vertices" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.dti.Sphere.x">
<tt class="descname">x</tt><a class="headerlink" href="#dipy.reconst.dti.Sphere.x" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.dti.Sphere.y">
<tt class="descname">y</tt><a class="headerlink" href="#dipy.reconst.dti.Sphere.y" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.dti.Sphere.z">
<tt class="descname">z</tt><a class="headerlink" href="#dipy.reconst.dti.Sphere.z" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="tensorfit">
<h3><a class="reference internal" href="#dipy.reconst.dti.TensorFit" title="dipy.reconst.dti.TensorFit"><tt class="xref py py-class docutils literal"><span class="pre">TensorFit</span></tt></a><a class="headerlink" href="#tensorfit" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.dti.TensorFit">
<em class="property">class </em><tt class="descclassname">dipy.reconst.dti.</tt><tt class="descname">TensorFit</tt><big>(</big><em>model</em>, <em>model_params</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.TensorFit" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></a></p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.TensorFit.ad" title="dipy.reconst.dti.TensorFit.ad"><tt class="xref py py-obj docutils literal"><span class="pre">ad</span></tt></a>()</td>
<td>Axial diffusivity (AD) calculated from cached eigenvalues.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.TensorFit.adc" title="dipy.reconst.dti.TensorFit.adc"><tt class="xref py py-obj docutils literal"><span class="pre">adc</span></tt></a>(sphere)</td>
<td>Calculate the apparent diffusion coefficient (ADC) in each direction on</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.TensorFit.fa" title="dipy.reconst.dti.TensorFit.fa"><tt class="xref py py-obj docutils literal"><span class="pre">fa</span></tt></a>()</td>
<td>Fractional anisotropy (FA) calculated from cached eigenvalues.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.TensorFit.ga" title="dipy.reconst.dti.TensorFit.ga"><tt class="xref py py-obj docutils literal"><span class="pre">ga</span></tt></a>()</td>
<td>Geodesic anisotropy (GA) calculated from cached eigenvalues.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.TensorFit.linearity" title="dipy.reconst.dti.TensorFit.linearity"><tt class="xref py py-obj docutils literal"><span class="pre">linearity</span></tt></a>()</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.TensorFit.lower_triangular" title="dipy.reconst.dti.TensorFit.lower_triangular"><tt class="xref py py-obj docutils literal"><span class="pre">lower_triangular</span></tt></a>([b0])</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.TensorFit.md" title="dipy.reconst.dti.TensorFit.md"><tt class="xref py py-obj docutils literal"><span class="pre">md</span></tt></a>()</td>
<td>Mean diffusitivity (MD) calculated from cached eigenvalues.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.TensorFit.mode" title="dipy.reconst.dti.TensorFit.mode"><tt class="xref py py-obj docutils literal"><span class="pre">mode</span></tt></a>()</td>
<td>Tensor mode calculated from cached eigenvalues.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.TensorFit.odf" title="dipy.reconst.dti.TensorFit.odf"><tt class="xref py py-obj docutils literal"><span class="pre">odf</span></tt></a>(sphere)</td>
<td>The diffusion orientation distribution function (dODF).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.TensorFit.planarity" title="dipy.reconst.dti.TensorFit.planarity"><tt class="xref py py-obj docutils literal"><span class="pre">planarity</span></tt></a>()</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.TensorFit.predict" title="dipy.reconst.dti.TensorFit.predict"><tt class="xref py py-obj docutils literal"><span class="pre">predict</span></tt></a>(gtab[,&nbsp;S0])</td>
<td>Given a model fit, predict the signal on the vertices of a sphere</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.TensorFit.rd" title="dipy.reconst.dti.TensorFit.rd"><tt class="xref py py-obj docutils literal"><span class="pre">rd</span></tt></a>()</td>
<td>Radial diffusitivity (RD) calculated from cached eigenvalues.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.TensorFit.sphericity" title="dipy.reconst.dti.TensorFit.sphericity"><tt class="xref py py-obj docutils literal"><span class="pre">sphericity</span></tt></a>()</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.TensorFit.trace" title="dipy.reconst.dti.TensorFit.trace"><tt class="xref py py-obj docutils literal"><span class="pre">trace</span></tt></a>()</td>
<td>Trace of the tensor calculated from cached eigenvalues.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.dti.TensorFit.__init__">
<tt class="descname">__init__</tt><big>(</big><em>model</em>, <em>model_params</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.TensorFit.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a TensorFit class instance.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="dipy.reconst.dti.TensorFit.ad">
<em class="property">static </em><tt class="descname">ad</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.dti.TensorFit.ad" title="Permalink to this definition">¶</a></dt>
<dd><p>Axial diffusivity (AD) calculated from cached eigenvalues.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ad</strong> : array (V, 1)</p>
<blockquote class="last">
<div><p>Calculated AD.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>RD is calculated with the following equation:</p>
<div class="math">
<p><span class="math">AD = \lambda_1</span></p>
</div></dd></dl>

<dl class="method">
<dt id="dipy.reconst.dti.TensorFit.adc">
<tt class="descname">adc</tt><big>(</big><em>sphere</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.TensorFit.adc" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the apparent diffusion coefficient (ADC) in each direction on
the sphere for each voxel in the data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sphere</strong> : Sphere class instance</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>adc</strong> : ndarray</p>
<blockquote class="last">
<div><p>The estimates of the apparent diffusion coefficient in every
direction on the input sphere</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The calculation of ADC, relies on the following relationship:</p>
<div class="math">
<p><span class="math">ADC = \vec{b} Q \vec{b}^T</span></p>
</div><p>Where Q is the quadratic form of the tensor.</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.dti.TensorFit.directions">
<tt class="descname">directions</tt><a class="headerlink" href="#dipy.reconst.dti.TensorFit.directions" title="Permalink to this definition">¶</a></dt>
<dd><p>For tracking - return the primary direction in each voxel</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.dti.TensorFit.evals">
<tt class="descname">evals</tt><a class="headerlink" href="#dipy.reconst.dti.TensorFit.evals" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the eigenvalues of the tensor as an array</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.dti.TensorFit.evecs">
<tt class="descname">evecs</tt><a class="headerlink" href="#dipy.reconst.dti.TensorFit.evecs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the eigenvectors of the tensor as an array</p>
</dd></dl>

<dl class="staticmethod">
<dt id="dipy.reconst.dti.TensorFit.fa">
<em class="property">static </em><tt class="descname">fa</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.dti.TensorFit.fa" title="Permalink to this definition">¶</a></dt>
<dd><p>Fractional anisotropy (FA) calculated from cached eigenvalues.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="dipy.reconst.dti.TensorFit.ga">
<em class="property">static </em><tt class="descname">ga</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.dti.TensorFit.ga" title="Permalink to this definition">¶</a></dt>
<dd><p>Geodesic anisotropy (GA) calculated from cached eigenvalues.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="dipy.reconst.dti.TensorFit.linearity">
<em class="property">static </em><tt class="descname">linearity</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.dti.TensorFit.linearity" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>linearity</strong> : array</p>
<blockquote class="last">
<div><p>Calculated linearity of the diffusion tensor <a class="footnote-reference" href="#id162" id="id120">[1]</a>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<dl class="docutils">
<dt>[1] Westin C.-F., Peled S., Gubjartsson H., Kikinis R., Jolesz</dt>
<dd>F., &#8220;Geometrical diffusion measures for MRI from tensor basis
analysis&#8221; in Proc. 5th Annual ISMRM, 1997.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dti.TensorFit.lower_triangular">
<tt class="descname">lower_triangular</tt><big>(</big><em>b0=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.TensorFit.lower_triangular" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="dipy.reconst.dti.TensorFit.md">
<em class="property">static </em><tt class="descname">md</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.dti.TensorFit.md" title="Permalink to this definition">¶</a></dt>
<dd><p>Mean diffusitivity (MD) calculated from cached eigenvalues.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>md</strong> : array (V, 1)</p>
<blockquote class="last">
<div><p>Calculated MD.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>MD is calculated with the following equation:</p>
<div class="math">
<p><span class="math">MD = \frac{\lambda_1+\lambda_2+\lambda_3}{3}</span></p>
</div></dd></dl>

<dl class="staticmethod">
<dt id="dipy.reconst.dti.TensorFit.mode">
<em class="property">static </em><tt class="descname">mode</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.dti.TensorFit.mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Tensor mode calculated from cached eigenvalues.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dti.TensorFit.odf">
<tt class="descname">odf</tt><big>(</big><em>sphere</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.TensorFit.odf" title="Permalink to this definition">¶</a></dt>
<dd><p>The diffusion orientation distribution function (dODF). This is an
estimate of the diffusion distance in each direction</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sphere</strong> : Sphere class instance.</p>
<blockquote>
<div><p>The dODF is calculated in the vertices of this input.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>odf</strong> : ndarray</p>
<blockquote class="last">
<div><p>The diffusion distance in every direction of the sphere in every
voxel in the input data.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This is based on equation 3 in <a class="reference internal" href="#aganj2010" id="id121">[Aganj2010]</a>. To re-derive it from
scratch, follow steps in <a class="reference internal" href="#descoteaux2008" id="id122">[Descoteaux2008]</a>, Section 7.9 Equation
7.24 but with an <span class="math">r^2</span> term in the integral.</p>
<table class="docutils citation" frame="void" id="aganj2010" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id121">[Aganj2010]</a></td><td>Aganj, I., Lenglet, C., Sapiro, G., Yacoub, E., Ugurbil,
K., &amp; Harel, N. (2010). Reconstruction of the orientation
distribution function in single- and multiple-shell q-ball imaging
within constant solid angle. Magnetic Resonance in Medicine, 64(2),
554-566. doi:DOI: 10.1002/mrm.22365</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="descoteaux2008" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id122">[Descoteaux2008]</a></td><td>Descoteaux, M. (2008). PhD Thesis: High Angular
Resolution Diffusion MRI: from Local Estimation to Segmentation and
Tractography. <a class="reference external" href="ftp://ftp-sop.inria.fr/athena/Publications/PhDs/descoteaux_thesis.pdf">ftp://ftp-sop.inria.fr/athena/Publications/PhDs/descoteaux_thesis.pdf</a></td></tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="dipy.reconst.dti.TensorFit.planarity">
<em class="property">static </em><tt class="descname">planarity</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.dti.TensorFit.planarity" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>sphericity</strong> : array</p>
<blockquote class="last">
<div><p>Calculated sphericity of the diffusion tensor <a class="footnote-reference" href="#id162" id="id123">[1]</a>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<dl class="docutils">
<dt>[1] Westin C.-F., Peled S., Gubjartsson H., Kikinis R., Jolesz</dt>
<dd>F., &#8220;Geometrical diffusion measures for MRI from tensor basis
analysis&#8221; in Proc. 5th Annual ISMRM, 1997.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dti.TensorFit.predict">
<tt class="descname">predict</tt><big>(</big><em>gtab</em>, <em>S0=1</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.TensorFit.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a model fit, predict the signal on the vertices of a sphere</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>gtab</strong> : a GradientTable class instance</p>
<blockquote>
<div><p>This encodes the directions for which a prediction is made</p>
</div></blockquote>
<p><strong>S0</strong> : float array</p>
<blockquote class="last">
<div><p>The mean non-diffusion weighted signal in each voxel. Default: 1 in
all voxels.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The predicted signal is given by:</p>
<div class="math">
<p><span class="math">S(\theta, b) = S_0 * e^{-b ADC}</span></p>
</div><p>Where:
.. math</p>
<div class="highlight-python"><div class="highlight"><pre>ADC = \theta Q \theta^T
</pre></div>
</div>
<p><span class="math">\theta</span> is a unit vector pointing at any direction on the sphere for
which a signal is to be predicted and <span class="math">b</span> is the b value provided in
the GradientTable input for that direction</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.dti.TensorFit.quadratic_form">
<tt class="descname">quadratic_form</tt><a class="headerlink" href="#dipy.reconst.dti.TensorFit.quadratic_form" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the 3x3 diffusion tensor for each voxel</p>
</dd></dl>

<dl class="staticmethod">
<dt id="dipy.reconst.dti.TensorFit.rd">
<em class="property">static </em><tt class="descname">rd</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.dti.TensorFit.rd" title="Permalink to this definition">¶</a></dt>
<dd><p>Radial diffusitivity (RD) calculated from cached eigenvalues.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>rd</strong> : array (V, 1)</p>
<blockquote class="last">
<div><p>Calculated RD.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>RD is calculated with the following equation:</p>
<div class="math">
<p><span class="math">RD = \frac{\lambda_2 + \lambda_3}{2}</span></p>
</div></dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.dti.TensorFit.shape">
<tt class="descname">shape</tt><a class="headerlink" href="#dipy.reconst.dti.TensorFit.shape" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="dipy.reconst.dti.TensorFit.sphericity">
<em class="property">static </em><tt class="descname">sphericity</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.dti.TensorFit.sphericity" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>sphericity</strong> : array</p>
<blockquote class="last">
<div><p>Calculated sphericity of the diffusion tensor <a class="footnote-reference" href="#id162" id="id124">[1]</a>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<dl class="docutils">
<dt>[1] Westin C.-F., Peled S., Gubjartsson H., Kikinis R., Jolesz</dt>
<dd>F., &#8220;Geometrical diffusion measures for MRI from tensor basis
analysis&#8221; in Proc. 5th Annual ISMRM, 1997.</dd>
</dl>
</dd></dl>

<dl class="staticmethod">
<dt id="dipy.reconst.dti.TensorFit.trace">
<em class="property">static </em><tt class="descname">trace</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.dti.TensorFit.trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Trace of the tensor calculated from cached eigenvalues.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>trace</strong> : array (V, 1)</p>
<blockquote class="last">
<div><p>Calculated trace.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The trace is calculated with the following equation:</p>
<div class="math">
<p><span class="math">trace = \lambda_1 + \lambda_2 + \lambda_3</span></p>
</div></dd></dl>

</dd></dl>

</div>
<div class="section" id="id125">
<h3><a class="reference internal" href="#dipy.reconst.dti.TensorModel" title="dipy.reconst.dti.TensorModel"><tt class="xref py py-class docutils literal"><span class="pre">TensorModel</span></tt></a><a class="headerlink" href="#id125" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.dti.TensorModel">
<em class="property">class </em><tt class="descclassname">dipy.reconst.dti.</tt><tt class="descname">TensorModel</tt><big>(</big><em>gtab</em>, <em>fit_method='WLS'</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.TensorModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><tt class="xref py py-class docutils literal"><span class="pre">dipy.reconst.base.ReconstModel</span></tt></a></p>
<p>Diffusion Tensor</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.TensorModel.fit" title="dipy.reconst.dti.TensorModel.fit"><tt class="xref py py-obj docutils literal"><span class="pre">fit</span></tt></a>(data[,&nbsp;mask])</td>
<td>Fit method of the DTI model class</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.TensorModel.predict" title="dipy.reconst.dti.TensorModel.predict"><tt class="xref py py-obj docutils literal"><span class="pre">predict</span></tt></a>(dti_params[,&nbsp;S0])</td>
<td>Predict a signal for this TensorModel class instance given parameters.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.dti.TensorModel.__init__">
<tt class="descname">__init__</tt><big>(</big><em>gtab</em>, <em>fit_method='WLS'</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.TensorModel.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>A Diffusion Tensor Model <a class="reference internal" href="#r119" id="id126">[R119]</a>, <a class="reference internal" href="#r120" id="id127">[R120]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>gtab</strong> : GradientTable class instance</p>
<p><strong>fit_method</strong> : str or callable</p>
<blockquote>
<div><p>str can be one of the following:
&#8216;WLS&#8217; for weighted least squares</p>
<blockquote>
<div><p>dti.wls_fit_tensor</p>
</div></blockquote>
<dl class="docutils">
<dt>&#8216;LS&#8217; or &#8216;OLS&#8217; for ordinary least squares</dt>
<dd><p class="first last">dti.ols_fit_tensor</p>
</dd>
<dt>&#8216;NLLS&#8217; for non-linear least-squares</dt>
<dd><p class="first last">dti.nlls_fit_tensor</p>
</dd>
<dt>&#8216;RT&#8217; or &#8216;restore&#8217; or &#8216;RESTORE&#8217; for RESTORE robust tensor fitting <a class="reference internal" href="#r121" id="id128">[R121]</a></dt>
<dd><p class="first last">dti.restore_fit_tensor</p>
</dd>
<dt>callable has to have the signature:</dt>
<dd><p class="first last">fit_method(design_matrix, data, <a href="#id129"><span class="problematic" id="id130">*</span></a>args, <a href="#id131"><span class="problematic" id="id132">**</span></a>kwargs)</p>
</dd>
</dl>
</div></blockquote>
<p><strong>args, kwargs</strong> : arguments and key-word arguments passed to the</p>
<blockquote>
<div><p>fit_method. See dti.wls_fit_tensor, dti.ols_fit_tensor for details</p>
</div></blockquote>
<p><strong>min_signal</strong> : float</p>
<blockquote class="last">
<div><p>The minimum signal value. Needs to be a strictly positive
number. Default: minimal signal in the data provided to <cite>fit</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r119" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R119]</td><td><em>(<a class="fn-backref" href="#id126">1</a>, <a class="fn-backref" href="#id133">2</a>)</em> Basser, P.J., Mattiello, J., LeBihan, D., 1994. Estimation of
the effective self-diffusion tensor from the NMR spin echo. J Magn
Reson B 103, 247-254.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r120" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R120]</td><td><em>(<a class="fn-backref" href="#id127">1</a>, <a class="fn-backref" href="#id134">2</a>)</em> Basser, P., Pierpaoli, C., 1996. Microstructural and
physiological features of tissues elucidated by quantitative
diffusion-tensor MRI.  Journal of Magnetic Resonance 111, 209-219.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r121" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R121]</td><td><em>(<a class="fn-backref" href="#id128">1</a>, <a class="fn-backref" href="#id135">2</a>)</em> Lin-Ching C., Jones D.K., Pierpaoli, C. 2005. RESTORE: Robust
estimation of tensors by outlier rejection. MRM 53: 1088-1095</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dti.TensorModel.fit">
<tt class="descname">fit</tt><big>(</big><em>data</em>, <em>mask=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.TensorModel.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit method of the DTI model class</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : array</p>
<blockquote>
<div><p>The measured signal from one voxel.</p>
</div></blockquote>
<p><strong>mask</strong> : array</p>
<blockquote class="last">
<div><p>A boolean array used to mark the coordinates in the data that
should be analyzed that has the shape data.shape[:-1]</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dti.TensorModel.predict">
<tt class="descname">predict</tt><big>(</big><em>dti_params</em>, <em>S0=1</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.TensorModel.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict a signal for this TensorModel class instance given parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dti_params</strong> : ndarray</p>
<blockquote>
<div><p>The last dimension should have 12 tensor parameters: 3
eigenvalues, followed by the 3 eigenvectors</p>
</div></blockquote>
<p><strong>S0</strong> : float or ndarray</p>
<blockquote class="last">
<div><p>The non diffusion-weighted signal in every voxel, or across all
voxels. Default: 1</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id136">
<h3><a class="reference internal" href="#dipy.reconst.dti.range" title="dipy.reconst.dti.range"><tt class="xref py py-class docutils literal"><span class="pre">range</span></tt></a><a class="headerlink" href="#id136" title="Permalink to this headline">¶</a></h3>
<dl class="attribute">
<dt id="dipy.reconst.dti.range">
<tt class="descclassname">dipy.reconst.dti.</tt><tt class="descname">range</tt><a class="headerlink" href="#dipy.reconst.dti.range" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <tt class="xref py py-class docutils literal"><span class="pre">xrange</span></tt></p>
</dd></dl>

</div>
<div class="section" id="apparent-diffusion-coef">
<h3>apparent_diffusion_coef<a class="headerlink" href="#apparent-diffusion-coef" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.apparent_diffusion_coef">
<tt class="descclassname">dipy.reconst.dti.</tt><tt class="descname">apparent_diffusion_coef</tt><big>(</big><em>q_form</em>, <em>sphere</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.apparent_diffusion_coef" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the apparent diffusion coefficient (ADC) in each direction of a
sphere.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>q_form</strong> : ndarray</p>
<blockquote>
<div><p>The quadratic form of a tensor, or an array with quadratic forms of
tensors. Should be of shape (..., 3, 3)</p>
</div></blockquote>
<p><strong>sphere</strong> : a Sphere class instance</p>
<blockquote class="last">
<div><p>The ADC will be calculated for each of the vertices in the sphere</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The calculation of ADC, relies on the following relationship:</p>
<div class="math">
<p><span class="math">ADC = \vec{b} Q \vec{b}^T</span></p>
</div><p>Where Q is the quadratic form of the tensor.</p>
</dd></dl>

</div>
<div class="section" id="id137">
<h3>auto_attr<a class="headerlink" href="#id137" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.auto_attr">
<tt class="descclassname">dipy.reconst.dti.</tt><tt class="descname">auto_attr</tt><big>(</big><em>func</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.auto_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator to create OneTimeProperty attributes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>func</strong> : method</p>
<blockquote class="last">
<div><p>The method that will be called the first time to compute a value.
Afterwards, the method&#8217;s name will be a standard attribute holding the
value of this computation.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MagicProp</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nd">@auto_attr</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">a</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">99</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">MagicProp</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s">&#39;a&#39;</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">__dict__</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">a</span>
<span class="go">99</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s">&#39;a&#39;</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">__dict__</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="axial-diffusivity">
<h3>axial_diffusivity<a class="headerlink" href="#axial-diffusivity" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.axial_diffusivity">
<tt class="descclassname">dipy.reconst.dti.</tt><tt class="descname">axial_diffusivity</tt><big>(</big><em>evals</em>, <em>axis=-1</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.axial_diffusivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Axial Diffusivity (AD) of a diffusion tensor.
Also called parallel diffusivity.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>evals</strong> : array-like</p>
<blockquote>
<div><p>Eigenvalues of a diffusion tensor, must be sorted in descending order
along <cite>axis</cite>.</p>
</div></blockquote>
<p><strong>axis</strong> : int</p>
<blockquote>
<div><p>Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ad</strong> : array</p>
<blockquote class="last">
<div><p>Calculated AD.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>AD is calculated with the following equation:</p>
<div class="math">
<p><span class="math">AD = \lambda_1</span></p>
</div></dd></dl>

</div>
<div class="section" id="color-fa">
<h3>color_fa<a class="headerlink" href="#color-fa" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.color_fa">
<tt class="descclassname">dipy.reconst.dti.</tt><tt class="descname">color_fa</tt><big>(</big><em>fa</em>, <em>evecs</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.color_fa" title="Permalink to this definition">¶</a></dt>
<dd><p>Color fractional anisotropy of diffusion tensor</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fa</strong> : array-like</p>
<blockquote>
<div><p>Array of the fractional anisotropy (can be 1D, 2D or 3D)</p>
</div></blockquote>
<p><strong>evecs</strong> : array-like</p>
<blockquote>
<div><p>eigen vectors from the tensor model</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>rgb</strong> : Array with 3 channels for each color as the last dimension.</p>
<blockquote class="last">
<div><p>Colormap of the FA with red for the x value, y for the green
value and z for the blue value.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="decompose-tensor">
<h3>decompose_tensor<a class="headerlink" href="#decompose-tensor" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.decompose_tensor">
<tt class="descclassname">dipy.reconst.dti.</tt><tt class="descname">decompose_tensor</tt><big>(</big><em>tensor</em>, <em>min_diffusivity=0</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.decompose_tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns eigenvalues and eigenvectors given a diffusion tensor</p>
<p>Computes tensor eigen decomposition to calculate eigenvalues and
eigenvectors (Basser et al., 1994a).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>tensor</strong> : array (3, 3)</p>
<blockquote>
<div><p>Hermitian matrix representing a diffusion tensor.</p>
</div></blockquote>
<p><strong>min_diffusivity</strong> : float</p>
<blockquote>
<div><p>Because negative eigenvalues are not physical and small eigenvalues,
much smaller than the diffusion weighting, cause quite a lot of noise
in metrics such as fa, diffusivity values smaller than
<cite>min_diffusivity</cite> are replaced with <cite>min_diffusivity</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>eigvals</strong> : array (3,)</p>
<blockquote>
<div><p>Eigenvalues from eigen decomposition of the tensor. Negative
eigenvalues are replaced by zero. Sorted from largest to smallest.</p>
</div></blockquote>
<p><strong>eigvecs</strong> : array (3, 3)</p>
<blockquote class="last">
<div><p>Associated eigenvectors from eigen decomposition of the tensor.
Eigenvectors are columnar (e.g. eigvecs[:,j] is associated with
eigvals[j])</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="design-matrix">
<h3>design_matrix<a class="headerlink" href="#design-matrix" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.design_matrix">
<tt class="descclassname">dipy.reconst.dti.</tt><tt class="descname">design_matrix</tt><big>(</big><em>gtab</em>, <em>dtype=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.design_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs design matrix for DTI weighted least squares or
least squares fitting. (Basser et al., 1994a)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>gtab</strong> : A GradientTable class instance</p>
<p><strong>dtype</strong> : string</p>
<blockquote>
<div><p>Parameter to control the dtype of returned designed matrix</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>design_matrix</strong> : array (g,7)</p>
<blockquote class="last">
<div><p>Design matrix or B matrix assuming Gaussian distributed tensor model
design_matrix[j, :] = (Bxx, Byy, Bzz, Bxy, Bxz, Byz, dummy)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="determinant">
<h3>determinant<a class="headerlink" href="#determinant" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.determinant">
<tt class="descclassname">dipy.reconst.dti.</tt><tt class="descname">determinant</tt><big>(</big><em>q_form</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.determinant" title="Permalink to this definition">¶</a></dt>
<dd><p>The determinant of a tensor, given in quadratic form</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>q_form</strong> : ndarray</p>
<blockquote>
<div><p>The quadratic form of a tensor, or an array with quadratic forms of
tensors. Should be of shape (x, y, z, 3, 3) or (n, 3, 3) or (3, 3).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>det</strong> : array</p>
<blockquote class="last">
<div><p>The determinant of the tensor in each spatial coordinate</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="deviatoric">
<h3>deviatoric<a class="headerlink" href="#deviatoric" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.deviatoric">
<tt class="descclassname">dipy.reconst.dti.</tt><tt class="descname">deviatoric</tt><big>(</big><em>q_form</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.deviatoric" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the deviatoric (anisotropic) part of the tensor <a class="reference internal" href="#r122" id="id138">[R122]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>q_form</strong> : ndarray</p>
<blockquote>
<div><p>The quadratic form of a tensor, or an array with quadratic forms of
tensors. Should be of shape (x,y,z,3,3) or (n, 3, 3) or (3,3).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>A_squiggle</strong> : ndarray</p>
<blockquote class="last">
<div><p>The deviatoric part of the tensor in each spatial coordinate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The deviatoric part of the tensor is defined as (equations 3-5 in <a class="reference internal" href="#r122" id="id139">[R122]</a>):</p>
<div class="math">
<p><span class="math">\widetilde{A} = A - \bar{A}</span></p>
</div><p>Where <span class="math">A</span> is the tensor quadratic form and <span class="math">\bar{A}</span> is the anisotropic
part of the tensor.</p>
<table class="docutils citation" frame="void" id="r122" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R122]</td><td><em>(<a class="fn-backref" href="#id138">1</a>, <a class="fn-backref" href="#id139">2</a>)</em> Daniel B. Ennis and G. Kindlmann, &#8220;Orthogonal Tensor
Invariants and the Analysis of Diffusion Tensor Magnetic Resonance
Images&#8221;, Magnetic Resonance in Medicine, vol. 55, no. 1, pp. 136-146,
2006.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="eig-from-lo-tri">
<h3>eig_from_lo_tri<a class="headerlink" href="#eig-from-lo-tri" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.eig_from_lo_tri">
<tt class="descclassname">dipy.reconst.dti.</tt><tt class="descname">eig_from_lo_tri</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.eig_from_lo_tri" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates tensor eigenvalues/eigenvectors from an array containing the
lower diagonal form of the six unique tensor elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : array_like (..., 6)</p>
<blockquote>
<div><p>diffusion tensors elements stored in lower triangular order</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dti_params (..., 12)</strong> :</p>
<blockquote class="last">
<div><p>Eigen-values and eigen-vectors of the same array.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id140">
<h3>fractional_anisotropy<a class="headerlink" href="#id140" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.fractional_anisotropy">
<tt class="descclassname">dipy.reconst.dti.</tt><tt class="descname">fractional_anisotropy</tt><big>(</big><em>evals</em>, <em>axis=-1</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.fractional_anisotropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Fractional anisotropy (FA) of a diffusion tensor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>evals</strong> : array-like</p>
<blockquote>
<div><p>Eigenvalues of a diffusion tensor.</p>
</div></blockquote>
<p><strong>axis</strong> : int</p>
<blockquote>
<div><p>Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fa</strong> : array</p>
<blockquote class="last">
<div><p>Calculated FA. Range is 0 &lt;= FA &lt;= 1.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>FA is calculated using the following equation:</p>
<div class="math">
<p><span class="math">FA = \sqrt{\frac{1}{2}\frac{(\lambda_1-\lambda_2)^2+(\lambda_1-
            \lambda_3)^2+(\lambda_2-\lambda_3)^2}{\lambda_1^2+
            \lambda_2^2+\lambda_3^2}}</span></p>
</div></dd></dl>

</div>
<div class="section" id="from-lower-triangular">
<h3>from_lower_triangular<a class="headerlink" href="#from-lower-triangular" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.from_lower_triangular">
<tt class="descclassname">dipy.reconst.dti.</tt><tt class="descname">from_lower_triangular</tt><big>(</big><em>D</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.from_lower_triangular" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a tensor given the six unique tensor elements</p>
<p>Given the six unique tensor elments (in the order: Dxx, Dxy, Dyy, Dxz, Dyz,
Dzz) returns a 3 by 3 tensor. All elements after the sixth are ignored.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>D</strong> : array_like, (..., &gt;6)</p>
<blockquote>
<div><p>Unique elements of the tensors</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>tensor</strong> : ndarray (..., 3, 3)</p>
<blockquote class="last">
<div><p>3 by 3 tensors</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="geodesic-anisotropy">
<h3>geodesic_anisotropy<a class="headerlink" href="#geodesic-anisotropy" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.geodesic_anisotropy">
<tt class="descclassname">dipy.reconst.dti.</tt><tt class="descname">geodesic_anisotropy</tt><big>(</big><em>evals</em>, <em>axis=-1</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.geodesic_anisotropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Geodesic anisotropy (GA) of a diffusion tensor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>evals</strong> : array-like</p>
<blockquote>
<div><p>Eigenvalues of a diffusion tensor.</p>
</div></blockquote>
<p><strong>axis</strong> : int</p>
<blockquote>
<div><p>Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ga</strong> : array</p>
<blockquote class="last">
<div><p>Calculated GA. In the range 0 to +infinity</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>GA is calculated using the following equation given in <a class="reference internal" href="#r123" id="id141">[R123]</a>:</p>
<div class="math">
<p><span class="math">GA = \sqrt{\sum_{i=1}^3 \log^2{\left ( \lambda_i/&lt;\mathbf{D}&gt; \right )}}, 
\quad \textrm{where} \quad &lt;\mathbf{D}&gt; = (\lambda_1\lambda_2\lambda_3)^{1/3}</span></p>
</div><p>Note that the notation, <span class="math">&lt;D&gt;</span>, is often used as the mean diffusivity (MD) of the diffusion tensor 
and can lead to confusions in the literature (see <a class="reference internal" href="#r123" id="id142">[R123]</a> versus <a class="reference internal" href="#r124" id="id143">[R124]</a> versus <a class="reference internal" href="#r125" id="id144">[R125]</a> for example).    
Reference <a class="reference internal" href="#r124" id="id145">[R124]</a> defines geodesic anisotropy (GA) with <span class="math">&lt;D&gt;</span> as the MD in the denominator of the sum. 
This is wrong. The original paper <a class="reference internal" href="#r123" id="id146">[R123]</a> defines GA with <span class="math">&lt;D&gt; = det(D)^{1/3}</span>, as the 
isotropic part of the distance. This might be an explanation for the confusion.
The isotropic part of the diffusion tensor in Euclidean space is
the MD whereas the isotropic part of the tensor in log-Euclidean space is <span class="math">det(D)^{1/3}</span>. 
The Appendix of <a class="reference internal" href="#r123" id="id147">[R123]</a> and log-Euclidean derivations from <a class="reference internal" href="#r125" id="id148">[R125]</a> are clear on this.
Hence, all that to say that <span class="math">&lt;D&gt; = det(D)^{1/3}</span> here for the GA definition and not MD.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r123" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R123]</td><td><em>(<a class="fn-backref" href="#id141">1</a>, <a class="fn-backref" href="#id142">2</a>, <a class="fn-backref" href="#id146">3</a>, <a class="fn-backref" href="#id147">4</a>, <a class="fn-backref" href="#id149">5</a>)</em> P. G. Batchelor, M. Moakher, D. Atkinson, F. Calamante, A. Connelly, 
&#8220;A rigorous framework for diffusion tensor calculus&#8221;, Magnetic Resonance 
in Medicine, vol. 53, pp. 221-225, 2005.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r124" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R124]</td><td><em>(<a class="fn-backref" href="#id143">1</a>, <a class="fn-backref" href="#id145">2</a>, <a class="fn-backref" href="#id150">3</a>)</em> M. M. Correia, V. F. Newcombe, G.B. Williams.
&#8220;Contrast-to-noise ratios for indices of anisotropy obtained from diffusion MRI: 
a study with standard clinical b-values at 3T&#8221;. NeuroImage, vol. 57, pp. 1103-1115, 2011.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r125" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R125]</td><td><em>(<a class="fn-backref" href="#id144">1</a>, <a class="fn-backref" href="#id148">2</a>, <a class="fn-backref" href="#id151">3</a>)</em> A. D. Lee, etal, P. M. Thompson.  
&#8220;Comparison of fractional and geodesic anisotropy in diffusion tensor images 
of 90 monozygotic and dizygotic twins&#8221;. 5th IEEE International Symposium on 
Biomedical Imaging (ISBI), pp. 943-946, May 2008.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r126" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id152">[R126]</a></td><td>V. Arsigny, P. Fillard, X. Pennec, N. Ayache. 
&#8220;Log-Euclidean metrics for fast and simple calculus on diffusion tensors.&#8221;
Magnetic Resonance in Medecine, vol 56, pp. 411-421, 2006.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id153">
<h3>get_sphere<a class="headerlink" href="#id153" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.get_sphere">
<tt class="descclassname">dipy.reconst.dti.</tt><tt class="descname">get_sphere</tt><big>(</big><em>name='symmetric362'</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.get_sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>provide triangulated spheres</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>name</strong> : str</p>
<blockquote>
<div><p>which sphere - one of:
* &#8216;symmetric362&#8217;
* &#8216;symmetric642&#8217;
* &#8216;symmetric724&#8217;
* &#8216;repulsion724&#8217;
* &#8216;repulsion100&#8217;</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>sphere</strong> : a dipy.core.sphere.Sphere class instance</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.data</span> <span class="kn">import</span> <span class="n">get_sphere</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere</span> <span class="o">=</span> <span class="n">get_sphere</span><span class="p">(</span><span class="s">&#39;symmetric362&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span><span class="p">,</span> <span class="n">faces</span> <span class="o">=</span> <span class="n">sphere</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">sphere</span><span class="o">.</span><span class="n">faces</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(362, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">faces</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(720, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span><span class="p">,</span> <span class="n">faces</span> <span class="o">=</span> <span class="n">get_sphere</span><span class="p">(</span><span class="s">&#39;not a sphere name&#39;</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">DataError</span>: <span class="n">No sphere called &quot;not a sphere name&quot;</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="gradient-table">
<h3>gradient_table<a class="headerlink" href="#gradient-table" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.gradient_table">
<tt class="descclassname">dipy.reconst.dti.</tt><tt class="descname">gradient_table</tt><big>(</big><em>bvals</em>, <em>bvecs=None</em>, <em>big_delta=None</em>, <em>small_delta=None</em>, <em>b0_threshold=0</em>, <em>atol=0.01</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.gradient_table" title="Permalink to this definition">¶</a></dt>
<dd><p>A general function for creating diffusion MR gradients.</p>
<p>It reads, loads and prepares scanner parameters like the b-values and
b-vectors so that they can be useful during the reconstruction process.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>bvals</strong> : can be any of the four options</p>
<blockquote>
<div><ol class="arabic simple">
<li>an array of shape (N,) or (1, N) or (N, 1) with the b-values.</li>
<li>a path for the file which contains an array like the above (1).</li>
<li>an array of shape (N, 4) or (4, N). Then this parameter is
considered to be a b-table which contains both bvals and bvecs. In
this case the next parameter is skipped.</li>
<li>a path for the file which contains an array like the one at (3).</li>
</ol>
</div></blockquote>
<p><strong>bvecs</strong> : can be any of two options</p>
<blockquote>
<div><ol class="arabic simple">
<li>an array of shape (N, 3) or (3, N) with the b-vectors.</li>
<li>a path for the file which contains an array like the previous.</li>
</ol>
</div></blockquote>
<p><strong>big_delta</strong> : float</p>
<blockquote>
<div><p>acquisition timing duration (default None)</p>
</div></blockquote>
<p><strong>small_delta</strong> : float</p>
<blockquote>
<div><p>acquisition timing duration (default None)</p>
</div></blockquote>
<p><strong>b0_threshold</strong> : float</p>
<blockquote>
<div><p>All b-values with values less than or equal to <cite>bo_threshold</cite> are
considered as b0s i.e. without diffusion weighting.</p>
</div></blockquote>
<p><strong>atol</strong> : float</p>
<blockquote>
<div><p>All b-vectors need to be unit vectors up to a tolerance.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>gradients</strong> : GradientTable</p>
<blockquote class="last">
<div><p>A GradientTable with all the gradient information.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<ol class="arabic simple">
<li>Often b0s (b-values which correspond to images without diffusion
weighting) have 0 values however in some cases the scanner cannot
provide b0s of an exact 0 value and it gives a bit higher values
e.g. 6 or 12. This is the purpose of the b0_threshold in the __init__.</li>
<li>We assume that the minimum number of b-values is 7.</li>
<li>B-vectors should be unit vectors.</li>
</ol>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.core.gradients</span> <span class="kn">import</span> <span class="n">gradient_table</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bvals</span><span class="o">=</span><span class="mi">1500</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bvals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sq2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bvecs</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                <span class="p">[</span><span class="n">sq2</span><span class="p">,</span> <span class="n">sq2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                <span class="p">[</span><span class="n">sq2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sq2</span><span class="p">],</span>
<span class="gp">... </span>                <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">sq2</span><span class="p">,</span> <span class="n">sq2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span> <span class="o">=</span> <span class="n">gradient_table</span><span class="p">(</span><span class="n">bvals</span><span class="p">,</span> <span class="n">bvecs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">bvecs</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">bvecs</span><span class="o">.</span><span class="n">shape</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span> <span class="o">=</span> <span class="n">gradient_table</span><span class="p">(</span><span class="n">bvals</span><span class="p">,</span> <span class="n">bvecs</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">bvecs</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">bvecs</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">shape</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="isotropic">
<h3>isotropic<a class="headerlink" href="#isotropic" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.isotropic">
<tt class="descclassname">dipy.reconst.dti.</tt><tt class="descname">isotropic</tt><big>(</big><em>q_form</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.isotropic" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the isotropic part of the tensor <a class="reference internal" href="#r127" id="id154">[R127]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>q_form</strong> : ndarray</p>
<blockquote>
<div><p>The quadratic form of a tensor, or an array with quadratic forms of
tensors. Should be of shape (x,y,z,3,3) or (n, 3, 3) or (3,3).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>A_hat: ndarray</strong> :</p>
<blockquote class="last">
<div><p>The isotropic part of the tensor in each spatial coordinate</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The isotropic part of a tensor is defined as (equations 3-5 of <a class="reference internal" href="#r127" id="id155">[R127]</a>):</p>
<div class="math">
<p><span class="math">\bar{A} = \frac{1}{2} tr(A) I</span></p>
</div><table class="docutils citation" frame="void" id="r127" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R127]</td><td><em>(<a class="fn-backref" href="#id154">1</a>, <a class="fn-backref" href="#id155">2</a>)</em> Daniel B. Ennis and G. Kindlmann, &#8220;Orthogonal Tensor
Invariants and the Analysis of Diffusion Tensor Magnetic Resonance
Images&#8221;, Magnetic Resonance in Medicine, vol. 55, no. 1, pp. 136-146,
2006.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="linearity">
<h3>linearity<a class="headerlink" href="#linearity" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.linearity">
<tt class="descclassname">dipy.reconst.dti.</tt><tt class="descname">linearity</tt><big>(</big><em>evals</em>, <em>axis=-1</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.linearity" title="Permalink to this definition">¶</a></dt>
<dd><p>The linearity of the tensor <a class="footnote-reference" href="#id162" id="id156">[1]</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>evals</strong> : array-like</p>
<blockquote>
<div><p>Eigenvalues of a diffusion tensor.</p>
</div></blockquote>
<p><strong>axis</strong> : int</p>
<blockquote>
<div><p>Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>linearity</strong> : array</p>
<blockquote class="last">
<div><p>Calculated linearity of the diffusion tensor.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<dl class="docutils">
<dt>[1] Westin C.-F., Peled S., Gubjartsson H., Kikinis R., Jolesz F.,</dt>
<dd>&#8220;Geometrical diffusion measures for MRI from tensor basis analysis&#8221; in
Proc. 5th Annual ISMRM, 1997.</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="lower-triangular">
<h3>lower_triangular<a class="headerlink" href="#lower-triangular" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.lower_triangular">
<tt class="descclassname">dipy.reconst.dti.</tt><tt class="descname">lower_triangular</tt><big>(</big><em>tensor</em>, <em>b0=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.lower_triangular" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the six lower triangular values of the tensor and a dummy variable
if b0 is not None</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>tensor</strong> : array_like (..., 3, 3)</p>
<blockquote>
<div><p>a collection of 3, 3 diffusion tensors</p>
</div></blockquote>
<p><strong>b0</strong> : float</p>
<blockquote>
<div><p>if b0 is not none log(b0) is returned as the dummy variable</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>D</strong> : ndarray</p>
<blockquote class="last">
<div><p>If b0 is none, then the shape will be (..., 6) otherwise (..., 7)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="mean-diffusivity">
<h3>mean_diffusivity<a class="headerlink" href="#mean-diffusivity" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.mean_diffusivity">
<tt class="descclassname">dipy.reconst.dti.</tt><tt class="descname">mean_diffusivity</tt><big>(</big><em>evals</em>, <em>axis=-1</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.mean_diffusivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Mean Diffusivity (MD) of a diffusion tensor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>evals</strong> : array-like</p>
<blockquote>
<div><p>Eigenvalues of a diffusion tensor.</p>
</div></blockquote>
<p><strong>axis</strong> : int</p>
<blockquote>
<div><p>Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>md</strong> : array</p>
<blockquote class="last">
<div><p>Calculated MD.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>MD is calculated with the following equation:</p>
<div class="math">
<p><span class="math">MD = \frac{\lambda_1 + \lambda_2 + \lambda_3}{3}</span></p>
</div></dd></dl>

</div>
<div class="section" id="mode">
<h3>mode<a class="headerlink" href="#mode" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.mode">
<tt class="descclassname">dipy.reconst.dti.</tt><tt class="descname">mode</tt><big>(</big><em>q_form</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Mode (MO) of a diffusion tensor <a class="reference internal" href="#r128" id="id157">[R128]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>q_form</strong> : ndarray</p>
<blockquote>
<div><p>The quadratic form of a tensor, or an array with quadratic forms of
tensors. Should be of shape (x, y, z, 3, 3) or (n, 3, 3) or (3, 3).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>mode</strong> : array</p>
<blockquote class="last">
<div><p>Calculated tensor mode in each spatial coordinate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Mode ranges between -1 (linear anisotropy) and +1 (planar anisotropy)
with 0 representing orthotropy. Mode is calculated with the
following equation (equation 9 in <a class="reference internal" href="#r128" id="id158">[R128]</a>):</p>
<div class="math">
<p><span class="math">Mode = 3*\sqrt{6}*det(\widetilde{A}/norm(\widetilde{A}))</span></p>
</div><p>Where <span class="math">\widetilde{A}</span> is the deviatoric part of the tensor quadratic form.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r128" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R128]</td><td><em>(<a class="fn-backref" href="#id157">1</a>, <a class="fn-backref" href="#id158">2</a>, <a class="fn-backref" href="#id159">3</a>)</em> Daniel B. Ennis and G. Kindlmann, &#8220;Orthogonal Tensor
Invariants and the Analysis of Diffusion Tensor Magnetic Resonance
Images&#8221;, Magnetic Resonance in Medicine, vol. 55, no. 1, pp. 136-146,
2006.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="nlls-fit-tensor">
<h3>nlls_fit_tensor<a class="headerlink" href="#nlls-fit-tensor" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.nlls_fit_tensor">
<tt class="descclassname">dipy.reconst.dti.</tt><tt class="descname">nlls_fit_tensor</tt><big>(</big><em>design_matrix</em>, <em>data</em>, <em>weighting=None</em>, <em>sigma=None</em>, <em>jac=True</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.nlls_fit_tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit the tensor params using non-linear least-squares.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>design_matrix</strong> : array (g, 7)</p>
<blockquote>
<div><p>Design matrix holding the covariants used to solve for the regression
coefficients.</p>
</div></blockquote>
<p><strong>data</strong> : array ([X, Y, Z, ...], g)</p>
<blockquote>
<div><p>Data or response variables holding the data. Note that the last
dimension should contain the data. It makes no copies of data.</p>
</div></blockquote>
<p><strong>weighting: str</strong> :</p>
<blockquote>
<div><p>the weighting scheme to use in considering the
squared-error. Default behavior is to use uniform weighting. Other
options: &#8216;sigma&#8217; &#8216;gmm&#8217;</p>
</div></blockquote>
<p><strong>sigma: float</strong> :</p>
<blockquote>
<div><p>If the &#8216;sigma&#8217; weighting scheme is used, a value of sigma needs to be
provided here. According to [Chang2005], a good value to use is
1.5267 * std(background_noise), where background_noise is estimated
from some part of the image known to contain no signal (only noise).</p>
</div></blockquote>
<p><strong>jac</strong> : bool</p>
<blockquote>
<div><p>Use the Jacobian? Default: True</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>nlls_params: the eigen-values and eigen-vectors of the tensor in each voxel.</strong> :</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="norm">
<h3>norm<a class="headerlink" href="#norm" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.norm">
<tt class="descclassname">dipy.reconst.dti.</tt><tt class="descname">norm</tt><big>(</big><em>q_form</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the Frobenius norm of a tensor quadratic form</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>q_form: ndarray</strong> :</p>
<blockquote>
<div><p>The quadratic form of a tensor, or an array with quadratic forms of
tensors. Should be of shape (x,y,z,3,3) or (n, 3, 3) or (3,3).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>norm</strong> : ndarray</p>
<blockquote class="last">
<div><p>The Frobenius norm of the 3,3 tensor q_form in each spatial
coordinate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-obj docutils literal"><span class="pre">np.linalg.norm</span></tt></p>
</div>
<p class="rubric">Notes</p>
<p>The Frobenius norm is defined as:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Math:</th><td class="field-body">||A||_F = [sum_{i,j} abs(a_{i,j})^2]^{1/2}</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="ols-fit-tensor">
<h3>ols_fit_tensor<a class="headerlink" href="#ols-fit-tensor" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.ols_fit_tensor">
<tt class="descclassname">dipy.reconst.dti.</tt><tt class="descname">ols_fit_tensor</tt><big>(</big><em>design_matrix</em>, <em>data</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.ols_fit_tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes ordinary least squares (OLS) fit to calculate self-diffusion
tensor using a linear regression model <a class="footnote-reference" href="#id162" id="id161">[1]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>design_matrix</strong> : array (g, 7)</p>
<blockquote>
<div><p>Design matrix holding the covariants used to solve for the regression
coefficients.</p>
</div></blockquote>
<p><strong>data</strong> : array ([X, Y, Z, ...], g)</p>
<blockquote>
<div><p>Data or response variables holding the data. Note that the last
dimension should contain the data. It makes no copies of data.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>eigvals</strong> : array (..., 3)</p>
<blockquote>
<div><p>Eigenvalues from eigen decomposition of the tensor.</p>
</div></blockquote>
<p><strong>eigvecs</strong> : array (..., 3, 3)</p>
<blockquote class="last">
<div><p>Associated eigenvectors from eigen decomposition of the tensor.
Eigenvectors are columnar (e.g. eigvecs[:,j] is associated with
eigvals[j])</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-obj docutils literal"><span class="pre">WLS_fit_tensor</span></tt>, <a class="reference internal" href="#dipy.reconst.dti.decompose_tensor" title="dipy.reconst.dti.decompose_tensor"><tt class="xref py py-obj docutils literal"><span class="pre">decompose_tensor</span></tt></a>, <a class="reference internal" href="#dipy.reconst.dti.design_matrix" title="dipy.reconst.dti.design_matrix"><tt class="xref py py-obj docutils literal"><span class="pre">design_matrix</span></tt></a></p>
</div>
<p class="rubric">Notes</p>
<div class="math">
<p><span class="math">y = \mathrm{data} \\
X = \mathrm{design matrix} \\

\hat{\beta}_\mathrm{OLS} = (X^T X)^{-1} X^T y</span></p>
</div><p class="rubric">References</p>
<table class="docutils footnote" frame="void" id="id162" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id7">1</a>, <a class="fn-backref" href="#id9">2</a>, <a class="fn-backref" href="#id10">3</a>, <a class="fn-backref" href="#id12">4</a>, <a class="fn-backref" href="#id120">5</a>, <a class="fn-backref" href="#id123">6</a>, <a class="fn-backref" href="#id124">7</a>, <a class="fn-backref" href="#id156">8</a>, <a class="fn-backref" href="#id161">9</a>, <a class="fn-backref" href="#id163">10</a>, <a class="fn-backref" href="#id166">11</a>)</em> Chung, SW., Lu, Y., Henry, R.G., 2006. Comparison of bootstrap
approaches for estimation of uncertainties of DTI parameters.
NeuroImage 33, 531-541.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="planarity">
<h3>planarity<a class="headerlink" href="#planarity" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.planarity">
<tt class="descclassname">dipy.reconst.dti.</tt><tt class="descname">planarity</tt><big>(</big><em>evals</em>, <em>axis=-1</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.planarity" title="Permalink to this definition">¶</a></dt>
<dd><p>The planarity of the tensor <a class="footnote-reference" href="#id162" id="id163">[1]</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>evals</strong> : array-like</p>
<blockquote>
<div><p>Eigenvalues of a diffusion tensor.</p>
</div></blockquote>
<p><strong>axis</strong> : int</p>
<blockquote>
<div><p>Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>linearity</strong> : array</p>
<blockquote class="last">
<div><p>Calculated linearity of the diffusion tensor.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<dl class="docutils">
<dt>[1] Westin C.-F., Peled S., Gubjartsson H., Kikinis R., Jolesz F.,</dt>
<dd>&#8220;Geometrical diffusion measures for MRI from tensor basis analysis&#8221; in
Proc. 5th Annual ISMRM, 1997.</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="quantize-evecs">
<h3>quantize_evecs<a class="headerlink" href="#quantize-evecs" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.quantize_evecs">
<tt class="descclassname">dipy.reconst.dti.</tt><tt class="descname">quantize_evecs</tt><big>(</big><em>evecs</em>, <em>odf_vertices=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.quantize_evecs" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the closest orientation of an evenly distributed sphere</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>evecs</strong> : ndarray</p>
<p><strong>odf_vertices</strong> : None or ndarray</p>
<blockquote>
<div><p>If None, then set vertices from symmetric362 sphere.  Otherwise use
passed ndarray as vertices</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>IN</strong> : ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="radial-diffusivity">
<h3>radial_diffusivity<a class="headerlink" href="#radial-diffusivity" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.radial_diffusivity">
<tt class="descclassname">dipy.reconst.dti.</tt><tt class="descname">radial_diffusivity</tt><big>(</big><em>evals</em>, <em>axis=-1</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.radial_diffusivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Radial Diffusivity (RD) of a diffusion tensor.
Also called perpendicular diffusivity.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>evals</strong> : array-like</p>
<blockquote>
<div><p>Eigenvalues of a diffusion tensor, must be sorted in descending order
along <cite>axis</cite>.</p>
</div></blockquote>
<p><strong>axis</strong> : int</p>
<blockquote>
<div><p>Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>rd</strong> : array</p>
<blockquote class="last">
<div><p>Calculated RD.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>RD is calculated with the following equation:</p>
<div class="math">
<p><span class="math">RD = \frac{\lambda_2 + \lambda_3}{2}</span></p>
</div></dd></dl>

</div>
<div class="section" id="restore-fit-tensor">
<h3>restore_fit_tensor<a class="headerlink" href="#restore-fit-tensor" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.restore_fit_tensor">
<tt class="descclassname">dipy.reconst.dti.</tt><tt class="descname">restore_fit_tensor</tt><big>(</big><em>design_matrix</em>, <em>data</em>, <em>sigma=None</em>, <em>jac=True</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.restore_fit_tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Use the RESTORE algorithm [Chang2005] to calculate a robust tensor fit</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>design_matrix</strong> : array of shape (g, 7)</p>
<blockquote>
<div><p>Design matrix holding the covariants used to solve for the regression
coefficients.</p>
</div></blockquote>
<p><strong>data</strong> : array of shape ([X, Y, Z, n_directions], g)</p>
<blockquote>
<div><p>Data or response variables holding the data. Note that the last
dimension should contain the data. It makes no copies of data.</p>
</div></blockquote>
<p><strong>sigma</strong> : float</p>
<blockquote>
<div><p>An estimate of the variance. [Chang2005] recommend to use
1.5267 * std(background_noise), where background_noise is estimated
from some part of the image known to contain no signal (only noise).</p>
</div></blockquote>
<p><strong>jac</strong> : bool, optional</p>
<blockquote>
<div><p>Whether to use the Jacobian of the tensor to speed the non-linear
optimization procedure used to fit the tensor paramters (see also
<a class="reference internal" href="#dipy.reconst.dti.nlls_fit_tensor" title="dipy.reconst.dti.nlls_fit_tensor"><tt class="xref py py-func docutils literal"><span class="pre">nlls_fit_tensor()</span></tt></a>). Default: True</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>restore_params</strong> : an estimate of the tensor parameters in each voxel.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="sphericity">
<h3>sphericity<a class="headerlink" href="#sphericity" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.sphericity">
<tt class="descclassname">dipy.reconst.dti.</tt><tt class="descname">sphericity</tt><big>(</big><em>evals</em>, <em>axis=-1</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.sphericity" title="Permalink to this definition">¶</a></dt>
<dd><p>The sphericity of the tensor <a class="footnote-reference" href="#id162" id="id166">[1]</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>evals</strong> : array-like</p>
<blockquote>
<div><p>Eigenvalues of a diffusion tensor.</p>
</div></blockquote>
<p><strong>axis</strong> : int</p>
<blockquote>
<div><p>Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>sphericity</strong> : array</p>
<blockquote class="last">
<div><p>Calculated sphericity of the diffusion tensor.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<dl class="docutils">
<dt>[1] Westin C.-F., Peled S., Gubjartsson H., Kikinis R., Jolesz F.,</dt>
<dd>&#8220;Geometrical diffusion measures for MRI from tensor basis analysis&#8221; in
Proc. 5th Annual ISMRM, 1997.</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="tensor-prediction">
<h3>tensor_prediction<a class="headerlink" href="#tensor-prediction" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.tensor_prediction">
<tt class="descclassname">dipy.reconst.dti.</tt><tt class="descname">tensor_prediction</tt><big>(</big><em>dti_params</em>, <em>gtab</em>, <em>S0</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.tensor_prediction" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict a signal given tensor parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dti_params</strong> : ndarray</p>
<blockquote>
<div><p>Tensor parameters. The last dimension should have 12 tensor parameters: 3
eigenvalues, followed by the 3 corresponding eigenvectors</p>
</div></blockquote>
<p><strong>gtab</strong> : a GradientTable class instance</p>
<blockquote>
<div><p>The gradient table for this prediction</p>
</div></blockquote>
<p><strong>S0</strong> : float or ndarray</p>
<blockquote class="last">
<div><p>The non diffusion-weighted signal in every voxel, or across all
voxels. Default: 1</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The predicted signal is given by: <span class="math">S(       heta, b) = S_0 * e^{-b ADC}</span>, where
<span class="math">ADC =      heta Q  heta^T</span>, :math:`      heta` is a unit vector pointing at any
direction on the sphere for which a signal is to be predicted, <span class="math">b</span> is the b
value provided in the GradientTable input for that direction, <span class="math">Q</span> is the
quadratic form of the tensor determined by the input parameters.</p>
</dd></dl>

</div>
<div class="section" id="trace">
<h3>trace<a class="headerlink" href="#trace" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.trace">
<tt class="descclassname">dipy.reconst.dti.</tt><tt class="descname">trace</tt><big>(</big><em>evals</em>, <em>axis=-1</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Trace of a diffusion tensor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>evals</strong> : array-like</p>
<blockquote>
<div><p>Eigenvalues of a diffusion tensor.</p>
</div></blockquote>
<p><strong>axis</strong> : int</p>
<blockquote>
<div><p>Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>trace</strong> : array</p>
<blockquote class="last">
<div><p>Calculated trace of the diffusion tensor.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Trace is calculated with the following equation:</p>
<div class="math">
<p><span class="math">Trace = \lambda_1 + \lambda_2 + \lambda_3</span></p>
</div></dd></dl>

</div>
<div class="section" id="id167">
<h3>vec_val_vect<a class="headerlink" href="#id167" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.vec_val_vect">
<tt class="descclassname">dipy.reconst.dti.</tt><tt class="descname">vec_val_vect</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.dti.vec_val_vect" title="Permalink to this definition">¶</a></dt>
<dd><p>Vectorize <cite>vecs</cite>.diag(<cite>vals</cite>).`vecs`.T for last 2 dimensions of <cite>vecs</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>vecs</strong> : shape (..., M, N) array</p>
<blockquote>
<div><p>containing tensor in last two dimensions; M, N usually equal to (3, 3)</p>
</div></blockquote>
<p><strong>vals</strong> : shape (..., N) array</p>
<blockquote>
<div><p>diagonal values carried in last dimension, <tt class="docutils literal"><span class="pre">...</span></tt> shape above must
match that for <cite>vecs</cite></p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>res</strong> : shape (..., M, M) array</p>
<blockquote>
<div><p>For all the dimensions ellided by <tt class="docutils literal"><span class="pre">...</span></tt>, loops to get (M, N) <tt class="docutils literal"><span class="pre">vec</span></tt>
matrix, and (N,) <tt class="docutils literal"><span class="pre">vals</span></tt> vector, and calculates
<tt class="docutils literal"><span class="pre">vec.dot(np.diag(val).dot(vec.T)</span></tt>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>ValueError</strong> : non-matching <tt class="docutils literal"><span class="pre">...</span></tt> dimensions of <cite>vecs</cite>, <cite>vals</cite></p>
<p class="last"><strong>ValueError</strong> : non-matching <tt class="docutils literal"><span class="pre">N</span></tt> dimensions of <cite>vecs</cite>, <cite>vals</cite></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Make a 3D array where the first dimension is only 1</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">vecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vec_val_vect</span><span class="p">(</span><span class="n">vecs</span><span class="p">,</span> <span class="n">vals</span><span class="p">)</span>
<span class="go">array([[[   9.,   24.,   39.],</span>
<span class="go">        [  24.,   66.,  108.],</span>
<span class="go">        [  39.,  108.,  177.]]])</span>
</pre></div>
</div>
<p>That&#8217;s the same as the 2D case (apart from the float casting):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">vecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vecs</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">vals</span><span class="p">),</span> <span class="n">vecs</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
<span class="go">array([[  9,  24,  39],</span>
<span class="go">       [ 24,  66, 108],</span>
<span class="go">       [ 39, 108, 177]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="vector-norm">
<h3>vector_norm<a class="headerlink" href="#vector-norm" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.vector_norm">
<tt class="descclassname">dipy.reconst.dti.</tt><tt class="descname">vector_norm</tt><big>(</big><em>vec</em>, <em>axis=-1</em>, <em>keepdims=False</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.vector_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Return vector Euclidean (L2) norm</p>
<p>See <a class="reference internal" href="../glossary.html#term-unit-vector"><em class="xref std std-term">unit vector</em></a> and <a class="reference internal" href="../glossary.html#term-euclidean-norm"><em class="xref std std-term">Euclidean norm</em></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>vec</strong> : array_like</p>
<blockquote>
<div><p>Vectors to norm.</p>
</div></blockquote>
<p><strong>axis</strong> : int</p>
<blockquote>
<div><p>Axis over which to norm. By default norm over last axis. If <cite>axis</cite> is
None, <cite>vec</cite> is flattened then normed.</p>
</div></blockquote>
<p><strong>keepdims</strong> : bool</p>
<blockquote>
<div><p>If True, the output will have the same number of dimensions as <cite>vec</cite>,
with shape 1 on <cite>axis</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>norm</strong> : array</p>
<blockquote class="last">
<div><p>Euclidean norms of vectors.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vec</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="mi">77</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vector_norm</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
<span class="go">array([ 17.,  85.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vector_norm</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">array([[ 17.],</span>
<span class="go">       [ 85.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vector_norm</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([  8.,  39.,  77.])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="wls-fit-tensor">
<h3>wls_fit_tensor<a class="headerlink" href="#wls-fit-tensor" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.wls_fit_tensor">
<tt class="descclassname">dipy.reconst.dti.</tt><tt class="descname">wls_fit_tensor</tt><big>(</big><em>design_matrix</em>, <em>data</em><big>)</big><a class="headerlink" href="#dipy.reconst.dti.wls_fit_tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes weighted least squares (WLS) fit to calculate self-diffusion
tensor using a linear regression model <a class="reference internal" href="#r129" id="id168">[R129]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>design_matrix</strong> : array (g, 7)</p>
<blockquote>
<div><p>Design matrix holding the covariants used to solve for the regression
coefficients.</p>
</div></blockquote>
<p><strong>data</strong> : array ([X, Y, Z, ...], g)</p>
<blockquote>
<div><p>Data or response variables holding the data. Note that the last
dimension should contain the data. It makes no copies of data.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>eigvals</strong> : array (..., 3)</p>
<blockquote>
<div><p>Eigenvalues from eigen decomposition of the tensor.</p>
</div></blockquote>
<p><strong>eigvecs</strong> : array (..., 3, 3)</p>
<blockquote class="last">
<div><p>Associated eigenvectors from eigen decomposition of the tensor.
Eigenvectors are columnar (e.g. eigvecs[:,j] is associated with
eigvals[j])</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#dipy.reconst.dti.decompose_tensor" title="dipy.reconst.dti.decompose_tensor"><tt class="xref py py-obj docutils literal"><span class="pre">decompose_tensor</span></tt></a></p>
</div>
<p class="rubric">Notes</p>
<p>In Chung, et al. 2006, the regression of the WLS fit needed an unbiased
preliminary estimate of the weights and therefore the ordinary least
squares (OLS) estimates were used. A &#8220;two pass&#8221; method was implemented:</p>
<blockquote>
<div><ol class="arabic simple">
<li>calculate OLS estimates of the data</li>
<li>apply the OLS estimates as weights to the WLS fit of the data</li>
</ol>
</div></blockquote>
<p>This ensured heteroscadasticity could be properly modeled for various
types of bootstrap resampling (namely residual bootstrap).</p>
<div class="math">
<p><span class="math">y = \mathrm{data} \\
X = \mathrm{design matrix} \\
\hat{\beta}_\mathrm{WLS} = \mathrm{desired regression coefficients (e.g. tensor)}\\
\\
\hat{\beta}_\mathrm{WLS} = (X^T W X)^{-1} X^T W y \\
\\
W = \mathrm{diag}((X \hat{\beta}_\mathrm{OLS})^2),
\mathrm{where} \hat{\beta}_\mathrm{OLS} = (X^T X)^{-1} X^T y</span></p>
</div><p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r129" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R129]</td><td><em>(<a class="fn-backref" href="#id168">1</a>, <a class="fn-backref" href="#id169">2</a>)</em> Chung, SW., Lu, Y., Henry, R.G., 2006. Comparison of bootstrap
approaches for estimation of uncertainties of DTI parameters.
NeuroImage 33, 531-541.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id170">
<h3><a class="reference internal" href="#dipy.reconst.gqi.Cache" title="dipy.reconst.gqi.Cache"><tt class="xref py py-class docutils literal"><span class="pre">Cache</span></tt></a><a class="headerlink" href="#id170" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.gqi.Cache">
<em class="property">class </em><tt class="descclassname">dipy.reconst.gqi.</tt><tt class="descname">Cache</tt><a class="headerlink" href="#dipy.reconst.gqi.Cache" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></a></p>
<p>Cache values based on a key object (such as a sphere or gradient table).</p>
<p class="rubric">Notes</p>
<p>This class is meant to be used as a mix-in:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MyModel</span><span class="p">(</span><span class="n">Model</span><span class="p">,</span> <span class="n">Cache</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">MyModelFit</span><span class="p">(</span><span class="n">Fit</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>Inside a method on the fit, typical usage would be:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">odf</span><span class="p">(</span><span class="n">sphere</span><span class="p">):</span>
    <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">cache_get</span><span class="p">(</span><span class="s">&#39;odf_basis_matrix&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sphere</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">M</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_basis_matrix</span><span class="p">(</span><span class="n">sphere</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">cache_set</span><span class="p">(</span><span class="s">&#39;odf_basis_matrix&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sphere</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">M</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.gqi.Cache.cache_clear" title="dipy.reconst.gqi.Cache.cache_clear"><tt class="xref py py-obj docutils literal"><span class="pre">cache_clear</span></tt></a>()</td>
<td>Clear the cache.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.gqi.Cache.cache_get" title="dipy.reconst.gqi.Cache.cache_get"><tt class="xref py py-obj docutils literal"><span class="pre">cache_get</span></tt></a>(tag,&nbsp;key[,&nbsp;default])</td>
<td>Retrieve a value from the cache.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.gqi.Cache.cache_set" title="dipy.reconst.gqi.Cache.cache_set"><tt class="xref py py-obj docutils literal"><span class="pre">cache_set</span></tt></a>(tag,&nbsp;key,&nbsp;value)</td>
<td>Store a value in the cache.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.gqi.Cache.__init__">
<tt class="descname">__init__</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.gqi.Cache.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.gqi.Cache.cache_clear">
<tt class="descname">cache_clear</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.gqi.Cache.cache_clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear the cache.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.gqi.Cache.cache_get">
<tt class="descname">cache_get</tt><big>(</big><em>tag</em>, <em>key</em>, <em>default=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.gqi.Cache.cache_get" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a value from the cache.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>tag</strong> : str</p>
<blockquote>
<div><p>Description of the cached value.</p>
</div></blockquote>
<p><strong>key</strong> : object</p>
<blockquote>
<div><p>Key object used to look up the cached value.</p>
</div></blockquote>
<p><strong>default</strong> : object</p>
<blockquote>
<div><p>Value to be returned if no cached entry is found.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>v</strong> : object</p>
<blockquote class="last">
<div><p>Value from the cache associated with <tt class="docutils literal"><span class="pre">(tag,</span> <span class="pre">key)</span></tt>.  Returns
<cite>default</cite> if no cached entry is found.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.gqi.Cache.cache_set">
<tt class="descname">cache_set</tt><big>(</big><em>tag</em>, <em>key</em>, <em>value</em><big>)</big><a class="headerlink" href="#dipy.reconst.gqi.Cache.cache_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Store a value in the cache.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>tag</strong> : str</p>
<blockquote>
<div><p>Description of the cached value.</p>
</div></blockquote>
<p><strong>key</strong> : object</p>
<blockquote>
<div><p>Key object used to look up the cached value.</p>
</div></blockquote>
<p><strong>value</strong> : object</p>
<blockquote class="last">
<div><p>Value stored in the cache for each unique combination
of <tt class="docutils literal"><span class="pre">(tag,</span> <span class="pre">key)</span></tt>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">compute_expensive_matrix</span><span class="p">(</span><span class="n">parameters</span><span class="p">):</span>
<span class="gp">... </span>    <span class="c"># Imagine the following computation is very expensive</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Cache</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">parameters</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X1</span> <span class="o">=</span> <span class="n">compute_expensive_matrix</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">cache_set</span><span class="p">(</span><span class="s">&#39;expensive_matrix&#39;</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">X1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X2</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">cache_get</span><span class="p">(</span><span class="s">&#39;expensive_matrix&#39;</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">X1</span> <span class="ow">is</span> <span class="n">X2</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="generalizedqsamplingfit">
<h3><a class="reference internal" href="#dipy.reconst.gqi.GeneralizedQSamplingFit" title="dipy.reconst.gqi.GeneralizedQSamplingFit"><tt class="xref py py-class docutils literal"><span class="pre">GeneralizedQSamplingFit</span></tt></a><a class="headerlink" href="#generalizedqsamplingfit" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.gqi.GeneralizedQSamplingFit">
<em class="property">class </em><tt class="descclassname">dipy.reconst.gqi.</tt><tt class="descname">GeneralizedQSamplingFit</tt><big>(</big><em>model</em>, <em>data</em><big>)</big><a class="headerlink" href="#dipy.reconst.gqi.GeneralizedQSamplingFit" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.odf.OdfFit" title="dipy.reconst.odf.OdfFit"><tt class="xref py py-class docutils literal"><span class="pre">dipy.reconst.odf.OdfFit</span></tt></a></p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.gqi.GeneralizedQSamplingFit.odf" title="dipy.reconst.gqi.GeneralizedQSamplingFit.odf"><tt class="xref py py-obj docutils literal"><span class="pre">odf</span></tt></a>(sphere)</td>
<td>Calculates the discrete ODF for a given discrete sphere.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.gqi.GeneralizedQSamplingFit.__init__">
<tt class="descname">__init__</tt><big>(</big><em>model</em>, <em>data</em><big>)</big><a class="headerlink" href="#dipy.reconst.gqi.GeneralizedQSamplingFit.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates PDF and ODF for a single voxel</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>model</strong> : object,</p>
<blockquote>
<div><p>DiffusionSpectrumModel</p>
</div></blockquote>
<p><strong>data</strong> : 1d ndarray,</p>
<blockquote class="last">
<div><p>signal values</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.gqi.GeneralizedQSamplingFit.odf">
<tt class="descname">odf</tt><big>(</big><em>sphere</em><big>)</big><a class="headerlink" href="#dipy.reconst.gqi.GeneralizedQSamplingFit.odf" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the discrete ODF for a given discrete sphere.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="generalizedqsamplingmodel">
<h3><a class="reference internal" href="#dipy.reconst.gqi.GeneralizedQSamplingModel" title="dipy.reconst.gqi.GeneralizedQSamplingModel"><tt class="xref py py-class docutils literal"><span class="pre">GeneralizedQSamplingModel</span></tt></a><a class="headerlink" href="#generalizedqsamplingmodel" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.gqi.GeneralizedQSamplingModel">
<em class="property">class </em><tt class="descclassname">dipy.reconst.gqi.</tt><tt class="descname">GeneralizedQSamplingModel</tt><big>(</big><em>gtab</em>, <em>method='gqi2'</em>, <em>sampling_length=1.2</em>, <em>normalize_peaks=False</em><big>)</big><a class="headerlink" href="#dipy.reconst.gqi.GeneralizedQSamplingModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.odf.OdfModel" title="dipy.reconst.odf.OdfModel"><tt class="xref py py-class docutils literal"><span class="pre">dipy.reconst.odf.OdfModel</span></tt></a>, <a class="reference internal" href="#dipy.reconst.cache.Cache" title="dipy.reconst.cache.Cache"><tt class="xref py py-class docutils literal"><span class="pre">dipy.reconst.cache.Cache</span></tt></a></p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">cache_clear</span></tt>()</td>
<td>Clear the cache.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">cache_get</span></tt>(tag,&nbsp;key[,&nbsp;default])</td>
<td>Retrieve a value from the cache.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">cache_set</span></tt>(tag,&nbsp;key,&nbsp;value)</td>
<td>Store a value in the cache.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.gqi.GeneralizedQSamplingModel.fit" title="dipy.reconst.gqi.GeneralizedQSamplingModel.fit"><tt class="xref py py-obj docutils literal"><span class="pre">fit</span></tt></a>(data[,&nbsp;mask])</td>
<td>Fit method for every voxel in data</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.gqi.GeneralizedQSamplingModel.__init__">
<tt class="descname">__init__</tt><big>(</big><em>gtab</em>, <em>method='gqi2'</em>, <em>sampling_length=1.2</em>, <em>normalize_peaks=False</em><big>)</big><a class="headerlink" href="#dipy.reconst.gqi.GeneralizedQSamplingModel.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Generalized Q-Sampling Imaging <a class="reference internal" href="#r130" id="id171">[R130]</a></p>
<p>This model has the same assumptions as the DSI method i.e. Cartesian
grid sampling in q-space and fast gradient switching.</p>
<p>Implements equations 2.14 from <a class="reference internal" href="#r131" id="id172">[R131]</a> for standard GQI and equation 2.16
from <a class="reference internal" href="#r131" id="id173">[R131]</a> for GQI2. You can think of GQI2 as an analytical solution of
the DSI ODF.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>gtab</strong> : object,</p>
<blockquote>
<div><p>GradientTable</p>
</div></blockquote>
<p><strong>method</strong> : str,</p>
<blockquote>
<div><p>&#8216;standard&#8217; or &#8216;gqi2&#8217;</p>
</div></blockquote>
<p><strong>sampling_length</strong> : float,</p>
<blockquote class="last">
<div><p>diffusion sampling length (lambda in eq. 2.14 and 2.16)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumModel" title="dipy.reconst.dsi.DiffusionSpectrumModel"><tt class="xref py py-obj docutils literal"><span class="pre">dipy.reconst.dsi.DiffusionSpectrumModel</span></tt></a></p>
</div>
<p class="rubric">Notes</p>
<p>As of version 0.9, range of the sampling length in GQI2 has changed
to match the same scale used in the &#8216;standard&#8217; method <a class="reference internal" href="#r130" id="id174">[R130]</a>. This 
means that the value of <cite>sampling_length</cite> should be approximately 
1 - 1.3 (see <a class="reference internal" href="#r130" id="id175">[R130]</a>, pg. 1628).</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r130" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R130]</td><td><em>(<a class="fn-backref" href="#id171">1</a>, <a class="fn-backref" href="#id174">2</a>, <a class="fn-backref" href="#id175">3</a>, <a class="fn-backref" href="#id176">4</a>)</em> Yeh F-C et. al, &#8220;Generalized Q-Sampling Imaging&#8221;, IEEE TMI, 2010</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r131" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R131]</td><td><em>(<a class="fn-backref" href="#id172">1</a>, <a class="fn-backref" href="#id173">2</a>, <a class="fn-backref" href="#id177">3</a>)</em> Garyfallidis E, &#8220;Towards an accurate brain tractography&#8221;, PhD</td></tr>
</tbody>
</table>
<p>thesis, University of Cambridge, 2012.</p>
<p class="rubric">Examples</p>
<p>Here we create an example where we provide the data, a gradient table
and a reconstruction sphere and calculate the ODF for the first
voxel in the data.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.data</span> <span class="kn">import</span> <span class="n">dsi_voxels</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">,</span> <span class="n">gtab</span> <span class="o">=</span> <span class="n">dsi_voxels</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.core.subdivide_octahedron</span> <span class="kn">import</span> <span class="n">create_unit_sphere</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere</span> <span class="o">=</span> <span class="n">create_unit_sphere</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.reconst.gqi</span> <span class="kn">import</span> <span class="n">GeneralizedQSamplingModel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gq</span> <span class="o">=</span> <span class="n">GeneralizedQSamplingModel</span><span class="p">(</span><span class="n">gtab</span><span class="p">,</span> <span class="s">&#39;gqi2&#39;</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">voxel_signal</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">odf</span> <span class="o">=</span> <span class="n">gq</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">voxel_signal</span><span class="p">)</span><span class="o">.</span><span class="n">odf</span><span class="p">(</span><span class="n">sphere</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.gqi.GeneralizedQSamplingModel.fit">
<tt class="descname">fit</tt><big>(</big><em>data</em>, <em>mask=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.gqi.GeneralizedQSamplingModel.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id178">
<h3><a class="reference internal" href="#dipy.reconst.gqi.OdfFit" title="dipy.reconst.gqi.OdfFit"><tt class="xref py py-class docutils literal"><span class="pre">OdfFit</span></tt></a><a class="headerlink" href="#id178" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.gqi.OdfFit">
<em class="property">class </em><tt class="descclassname">dipy.reconst.gqi.</tt><tt class="descname">OdfFit</tt><big>(</big><em>model</em>, <em>data</em><big>)</big><a class="headerlink" href="#dipy.reconst.gqi.OdfFit" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstFit" title="dipy.reconst.base.ReconstFit"><tt class="xref py py-class docutils literal"><span class="pre">dipy.reconst.base.ReconstFit</span></tt></a></p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.gqi.OdfFit.odf" title="dipy.reconst.gqi.OdfFit.odf"><tt class="xref py py-obj docutils literal"><span class="pre">odf</span></tt></a>(sphere)</td>
<td>To be implemented but specific odf models</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.gqi.OdfFit.__init__">
<tt class="descname">__init__</tt><big>(</big><em>model</em>, <em>data</em><big>)</big><a class="headerlink" href="#dipy.reconst.gqi.OdfFit.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.reconst.gqi.OdfFit.odf">
<tt class="descname">odf</tt><big>(</big><em>sphere</em><big>)</big><a class="headerlink" href="#dipy.reconst.gqi.OdfFit.odf" title="Permalink to this definition">¶</a></dt>
<dd><p>To be implemented but specific odf models</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id179">
<h3><a class="reference internal" href="#dipy.reconst.gqi.OdfModel" title="dipy.reconst.gqi.OdfModel"><tt class="xref py py-class docutils literal"><span class="pre">OdfModel</span></tt></a><a class="headerlink" href="#id179" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.gqi.OdfModel">
<em class="property">class </em><tt class="descclassname">dipy.reconst.gqi.</tt><tt class="descname">OdfModel</tt><big>(</big><em>gtab</em><big>)</big><a class="headerlink" href="#dipy.reconst.gqi.OdfModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><tt class="xref py py-class docutils literal"><span class="pre">dipy.reconst.base.ReconstModel</span></tt></a></p>
<p>An abstract class to be sub-classed by specific odf models</p>
<p>All odf models should provide a fit method which may take data as it&#8217;s
first and only argument.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.gqi.OdfModel.fit" title="dipy.reconst.gqi.OdfModel.fit"><tt class="xref py py-obj docutils literal"><span class="pre">fit</span></tt></a>(data)</td>
<td>To be implemented by specific odf models</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.gqi.OdfModel.__init__">
<tt class="descname">__init__</tt><big>(</big><em>gtab</em><big>)</big><a class="headerlink" href="#dipy.reconst.gqi.OdfModel.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.reconst.gqi.OdfModel.fit">
<tt class="descname">fit</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#dipy.reconst.gqi.OdfModel.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>To be implemented by specific odf models</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="equatorial-maximum">
<h3>equatorial_maximum<a class="headerlink" href="#equatorial-maximum" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.gqi.equatorial_maximum">
<tt class="descclassname">dipy.reconst.gqi.</tt><tt class="descname">equatorial_maximum</tt><big>(</big><em>vertices</em>, <em>odf</em>, <em>pole</em>, <em>width</em><big>)</big><a class="headerlink" href="#dipy.reconst.gqi.equatorial_maximum" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="equatorial-zone-vertices">
<h3>equatorial_zone_vertices<a class="headerlink" href="#equatorial-zone-vertices" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.gqi.equatorial_zone_vertices">
<tt class="descclassname">dipy.reconst.gqi.</tt><tt class="descname">equatorial_zone_vertices</tt><big>(</big><em>vertices</em>, <em>pole</em>, <em>width=5</em><big>)</big><a class="headerlink" href="#dipy.reconst.gqi.equatorial_zone_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>finds the &#8216;vertices&#8217; in the equatorial zone conjugate
to &#8216;pole&#8217; with width half &#8216;width&#8217; degrees</p>
</dd></dl>

</div>
<div class="section" id="id180">
<h3>gfa<a class="headerlink" href="#id180" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.gqi.gfa">
<tt class="descclassname">dipy.reconst.gqi.</tt><tt class="descname">gfa</tt><big>(</big><em>samples</em><big>)</big><a class="headerlink" href="#dipy.reconst.gqi.gfa" title="Permalink to this definition">¶</a></dt>
<dd><p>The general fractional anisotropy of a function evaluated
on the unit sphere</p>
</dd></dl>

</div>
<div class="section" id="id181">
<h3>local_maxima<a class="headerlink" href="#id181" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.gqi.local_maxima">
<tt class="descclassname">dipy.reconst.gqi.</tt><tt class="descname">local_maxima</tt><big>(</big><em>odf</em>, <em>edges</em><big>)</big><a class="headerlink" href="#dipy.reconst.gqi.local_maxima" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the local maxima of a function evaluated on a discrete set of points.</p>
<p>If a function is evaluated on some set of points where each pair of
neighboring points is an edge in edges, find the local maxima.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>odf</strong> : array, 1d, dtype=double</p>
<blockquote>
<div><p>The function evaluated on a set of discrete points.</p>
</div></blockquote>
<p><strong>edges</strong> : array (N, 2)</p>
<blockquote>
<div><p>The set of neighbor relations between the points. Every edge, ie
<cite>edges[i, :]</cite>, is a pair of neighboring points.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>peak_values</strong> : ndarray</p>
<blockquote>
<div><p>Value of odf at a maximum point. Peak values is sorted in descending
order.</p>
</div></blockquote>
<p><strong>peak_indices</strong> : ndarray</p>
<blockquote class="last">
<div><p>Indices of maximum points. Sorted in the same order as <cite>peak_values</cite> so
<cite>odf[peak_indices[i]] == peak_values[i]</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="dipy.core.html#module-dipy.core.sphere" title="dipy.core.sphere"><tt class="xref py py-obj docutils literal"><span class="pre">dipy.core.sphere</span></tt></a></p>
</div>
</dd></dl>

</div>
<div class="section" id="id182">
<h3>multi_voxel_fit<a class="headerlink" href="#id182" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.gqi.multi_voxel_fit">
<tt class="descclassname">dipy.reconst.gqi.</tt><tt class="descname">multi_voxel_fit</tt><big>(</big><em>single_voxel_fit</em><big>)</big><a class="headerlink" href="#dipy.reconst.gqi.multi_voxel_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Method decorator to turn a single voxel model fit
definition into a multi voxel model fit definition</p>
</dd></dl>

</div>
<div class="section" id="normalize-qa">
<h3>normalize_qa<a class="headerlink" href="#normalize-qa" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.gqi.normalize_qa">
<tt class="descclassname">dipy.reconst.gqi.</tt><tt class="descname">normalize_qa</tt><big>(</big><em>qa</em>, <em>max_qa=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.gqi.normalize_qa" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalize quantitative anisotropy.</p>
<p>Used mostly with GQI rather than GQI2.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>qa</strong> : array, shape (X, Y, Z, N)</p>
<blockquote>
<div><p>where N is the maximum number of peaks stored</p>
</div></blockquote>
<p><strong>max_qa</strong> : float,</p>
<blockquote>
<div><p>maximum qa value. Usually found in the CSF (corticospinal fluid).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>nqa</strong> : array, shape (x, Y, Z, N)</p>
<blockquote class="last">
<div><p>normalized quantitative anisotropy</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Normalized quantitative anisotropy has the very useful property
to be very small near gray matter and background areas. Therefore, 
it can be used to mask out white matter areas.</p>
</dd></dl>

</div>
<div class="section" id="npa">
<h3>npa<a class="headerlink" href="#npa" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.gqi.npa">
<tt class="descclassname">dipy.reconst.gqi.</tt><tt class="descname">npa</tt><big>(</big><em>self</em>, <em>odf</em>, <em>width=5</em><big>)</big><a class="headerlink" href="#dipy.reconst.gqi.npa" title="Permalink to this definition">¶</a></dt>
<dd><p>non-parametric anisotropy</p>
<p>Nimmo-Smith et. al  ISMRM 2011</p>
</dd></dl>

</div>
<div class="section" id="odf-sum">
<h3>odf_sum<a class="headerlink" href="#odf-sum" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.gqi.odf_sum">
<tt class="descclassname">dipy.reconst.gqi.</tt><tt class="descname">odf_sum</tt><big>(</big><em>odf</em><big>)</big><a class="headerlink" href="#dipy.reconst.gqi.odf_sum" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="patch-maximum">
<h3>patch_maximum<a class="headerlink" href="#patch-maximum" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.gqi.patch_maximum">
<tt class="descclassname">dipy.reconst.gqi.</tt><tt class="descname">patch_maximum</tt><big>(</big><em>vertices</em>, <em>odf</em>, <em>pole</em>, <em>width</em><big>)</big><a class="headerlink" href="#dipy.reconst.gqi.patch_maximum" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="patch-sum">
<h3>patch_sum<a class="headerlink" href="#patch-sum" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.gqi.patch_sum">
<tt class="descclassname">dipy.reconst.gqi.</tt><tt class="descname">patch_sum</tt><big>(</big><em>vertices</em>, <em>odf</em>, <em>pole</em>, <em>width</em><big>)</big><a class="headerlink" href="#dipy.reconst.gqi.patch_sum" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="patch-vertices">
<h3>patch_vertices<a class="headerlink" href="#patch-vertices" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.gqi.patch_vertices">
<tt class="descclassname">dipy.reconst.gqi.</tt><tt class="descname">patch_vertices</tt><big>(</big><em>vertices</em>, <em>pole</em>, <em>width</em><big>)</big><a class="headerlink" href="#dipy.reconst.gqi.patch_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>find &#8216;vertices&#8217; within the cone of &#8216;width&#8217; degrees around &#8216;pole&#8217;</p>
</dd></dl>

</div>
<div class="section" id="polar-zone-vertices">
<h3>polar_zone_vertices<a class="headerlink" href="#polar-zone-vertices" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.gqi.polar_zone_vertices">
<tt class="descclassname">dipy.reconst.gqi.</tt><tt class="descname">polar_zone_vertices</tt><big>(</big><em>vertices</em>, <em>pole</em>, <em>width=5</em><big>)</big><a class="headerlink" href="#dipy.reconst.gqi.polar_zone_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>finds the &#8216;vertices&#8217; in the equatorial band around
the &#8216;pole&#8217; of radius &#8216;width&#8217; degrees</p>
</dd></dl>

</div>
<div class="section" id="id183">
<h3>remove_similar_vertices<a class="headerlink" href="#id183" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.gqi.remove_similar_vertices">
<tt class="descclassname">dipy.reconst.gqi.</tt><tt class="descname">remove_similar_vertices</tt><big>(</big><em>vertices</em>, <em>theta</em><big>)</big><a class="headerlink" href="#dipy.reconst.gqi.remove_similar_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns vertices that are separated by at least theta degrees from all
other vertices. Vertex v and -v are considered the same so if v and -v are
both in <cite>vertices</cite> only one is kept. Also if v and w are both in vertices,
w must be separated by theta degrees from both v and -v to be unique.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>vertices</strong> : (N, 3) ndarray</p>
<blockquote>
<div><p>N unit vectors</p>
</div></blockquote>
<p><strong>theta</strong> : float</p>
<blockquote>
<div><p>The minimum separation between vertices in degrees.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>unique_vertices</strong> : (M, 3) ndarray</p>
<blockquote>
<div><p>Vertices sufficiently separated from one another.</p>
</div></blockquote>
<p><strong>mapping</strong> : (N,) ndarray</p>
<blockquote class="last">
<div><p>Indices into unique_vertices. For each vertex in <cite>vertices</cite> the index
of a vertex in <cite>unique_vertices</cite> that is less than theta degrees away.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="squared-radial-component">
<h3>squared_radial_component<a class="headerlink" href="#squared-radial-component" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.gqi.squared_radial_component">
<tt class="descclassname">dipy.reconst.gqi.</tt><tt class="descname">squared_radial_component</tt><big>(</big><em>x</em>, <em>tol=0.01</em><big>)</big><a class="headerlink" href="#dipy.reconst.gqi.squared_radial_component" title="Permalink to this definition">¶</a></dt>
<dd><p>Part of the GQI2 integral</p>
<p>Eq.8 in the referenced paper by Yeh et al. 2010</p>
</dd></dl>

</div>
<div class="section" id="triple-odf-maxima">
<h3>triple_odf_maxima<a class="headerlink" href="#triple-odf-maxima" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.gqi.triple_odf_maxima">
<tt class="descclassname">dipy.reconst.gqi.</tt><tt class="descname">triple_odf_maxima</tt><big>(</big><em>vertices</em>, <em>odf</em>, <em>width</em><big>)</big><a class="headerlink" href="#dipy.reconst.gqi.triple_odf_maxima" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="upper-hemi-map">
<h3>upper_hemi_map<a class="headerlink" href="#upper-hemi-map" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.gqi.upper_hemi_map">
<tt class="descclassname">dipy.reconst.gqi.</tt><tt class="descname">upper_hemi_map</tt><big>(</big><em>v</em><big>)</big><a class="headerlink" href="#dipy.reconst.gqi.upper_hemi_map" title="Permalink to this definition">¶</a></dt>
<dd><p>maps a 3-vector into the z-upper hemisphere</p>
</dd></dl>

</div>
<div class="section" id="interpolator">
<h3><a class="reference internal" href="#dipy.reconst.interpolate.Interpolator" title="dipy.reconst.interpolate.Interpolator"><tt class="xref py py-class docutils literal"><span class="pre">Interpolator</span></tt></a><a class="headerlink" href="#interpolator" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.interpolate.Interpolator">
<em class="property">class </em><tt class="descclassname">dipy.reconst.interpolate.</tt><tt class="descname">Interpolator</tt><big>(</big><em>data</em>, <em>voxel_size</em><big>)</big><a class="headerlink" href="#dipy.reconst.interpolate.Interpolator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></a></p>
<p>Class to be subclassed by different interpolator types</p>
<dl class="method">
<dt id="dipy.reconst.interpolate.Interpolator.__init__">
<tt class="descname">__init__</tt><big>(</big><em>data</em>, <em>voxel_size</em><big>)</big><a class="headerlink" href="#dipy.reconst.interpolate.Interpolator.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="nearestneighborinterpolator">
<h3><a class="reference internal" href="#dipy.reconst.interpolate.NearestNeighborInterpolator" title="dipy.reconst.interpolate.NearestNeighborInterpolator"><tt class="xref py py-class docutils literal"><span class="pre">NearestNeighborInterpolator</span></tt></a><a class="headerlink" href="#nearestneighborinterpolator" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.interpolate.NearestNeighborInterpolator">
<em class="property">class </em><tt class="descclassname">dipy.reconst.interpolate.</tt><tt class="descname">NearestNeighborInterpolator</tt><big>(</big><em>data</em>, <em>voxel_size</em><big>)</big><a class="headerlink" href="#dipy.reconst.interpolate.NearestNeighborInterpolator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.interpolate.Interpolator" title="dipy.reconst.interpolate.Interpolator"><tt class="xref py py-class docutils literal"><span class="pre">dipy.reconst.interpolate.Interpolator</span></tt></a></p>
<p>Interpolates data using nearest neighbor interpolation</p>
<dl class="method">
<dt id="dipy.reconst.interpolate.NearestNeighborInterpolator.__init__">
<tt class="descname">__init__</tt><big>(</big><em>data</em>, <em>voxel_size</em><big>)</big><a class="headerlink" href="#dipy.reconst.interpolate.NearestNeighborInterpolator.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="outsideimage">
<h3><a class="reference internal" href="#dipy.reconst.interpolate.OutsideImage" title="dipy.reconst.interpolate.OutsideImage"><tt class="xref py py-class docutils literal"><span class="pre">OutsideImage</span></tt></a><a class="headerlink" href="#outsideimage" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.interpolate.OutsideImage">
<em class="property">class </em><tt class="descclassname">dipy.reconst.interpolate.</tt><tt class="descname">OutsideImage</tt><a class="headerlink" href="#dipy.reconst.interpolate.OutsideImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/library/exceptions.html#exceptions.Exception" title="(in Python v2.7)"><tt class="xref py py-class docutils literal"><span class="pre">exceptions.Exception</span></tt></a></p>
<dl class="method">
<dt id="dipy.reconst.interpolate.OutsideImage.__init__">
<tt class="descname">__init__</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.interpolate.OutsideImage.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="trilinearinterpolator">
<h3><a class="reference internal" href="#dipy.reconst.interpolate.TriLinearInterpolator" title="dipy.reconst.interpolate.TriLinearInterpolator"><tt class="xref py py-class docutils literal"><span class="pre">TriLinearInterpolator</span></tt></a><a class="headerlink" href="#trilinearinterpolator" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.interpolate.TriLinearInterpolator">
<em class="property">class </em><tt class="descclassname">dipy.reconst.interpolate.</tt><tt class="descname">TriLinearInterpolator</tt><big>(</big><em>data</em>, <em>voxel_size</em><big>)</big><a class="headerlink" href="#dipy.reconst.interpolate.TriLinearInterpolator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.interpolate.Interpolator" title="dipy.reconst.interpolate.Interpolator"><tt class="xref py py-class docutils literal"><span class="pre">dipy.reconst.interpolate.Interpolator</span></tt></a></p>
<p>Interpolates data using trilinear interpolation</p>
<p>interpolate 4d diffusion volume using 3 indices, ie data[x, y, z]</p>
<dl class="method">
<dt id="dipy.reconst.interpolate.TriLinearInterpolator.__init__">
<tt class="descname">__init__</tt><big>(</big><em>data</em>, <em>voxel_size</em><big>)</big><a class="headerlink" href="#dipy.reconst.interpolate.TriLinearInterpolator.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="array">
<h3>array<a class="headerlink" href="#array" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.interpolate.array">
<tt class="descclassname">dipy.reconst.interpolate.</tt><tt class="descname">array</tt><big>(</big><em>object</em>, <em>dtype=None</em>, <em>copy=True</em>, <em>order=None</em>, <em>subok=False</em>, <em>ndmin=0</em><big>)</big><a class="headerlink" href="#dipy.reconst.interpolate.array" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>object</strong> : array_like</p>
<blockquote>
<div><p>An array, any object exposing the array interface, an
object whose __array__ method returns an array, or any
(nested) sequence.</p>
</div></blockquote>
<p><strong>dtype</strong> : data-type, optional</p>
<blockquote>
<div><p>The desired data-type for the array.  If not given, then
the type will be determined as the minimum type required
to hold the objects in the sequence.  This argument can only
be used to &#8216;upcast&#8217; the array.  For downcasting, use the
.astype(t) method.</p>
</div></blockquote>
<p><strong>copy</strong> : bool, optional</p>
<blockquote>
<div><p>If true (default), then the object is copied.  Otherwise, a copy
will only be made if __array__ returns a copy, if obj is a
nested sequence, or if a copy is needed to satisfy any of the other
requirements (<cite>dtype</cite>, <cite>order</cite>, etc.).</p>
</div></blockquote>
<p><strong>order</strong> : {&#8216;C&#8217;, &#8216;F&#8217;, &#8216;A&#8217;}, optional</p>
<blockquote>
<div><p>Specify the order of the array.  If order is &#8216;C&#8217; (default), then the
array will be in C-contiguous order (last-index varies the
fastest).  If order is &#8216;F&#8217;, then the returned array
will be in Fortran-contiguous order (first-index varies the
fastest).  If order is &#8216;A&#8217;, then the returned array may
be in any order (either C-, Fortran-contiguous, or even
discontiguous).</p>
</div></blockquote>
<p><strong>subok</strong> : bool, optional</p>
<blockquote>
<div><p>If True, then sub-classes will be passed-through, otherwise
the returned array will be forced to be a base-class array (default).</p>
</div></blockquote>
<p><strong>ndmin</strong> : int, optional</p>
<blockquote>
<div><p>Specifies the minimum number of dimensions that the resulting
array should have.  Ones will be pre-pended to the shape as
needed to meet this requirement.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> : ndarray</p>
<blockquote class="last">
<div><p>An array object satisfying the specified requirements.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-obj docutils literal"><span class="pre">empty</span></tt>, <tt class="xref py py-obj docutils literal"><span class="pre">empty_like</span></tt>, <tt class="xref py py-obj docutils literal"><span class="pre">zeros</span></tt>, <tt class="xref py py-obj docutils literal"><span class="pre">zeros_like</span></tt>, <tt class="xref py py-obj docutils literal"><span class="pre">ones</span></tt>, <tt class="xref py py-obj docutils literal"><span class="pre">ones_like</span></tt>, <tt class="xref py py-obj docutils literal"><span class="pre">fill</span></tt></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">array([1, 2, 3])</span>
</pre></div>
</div>
<p>Upcasting:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">])</span>
<span class="go">array([ 1.,  2.,  3.])</span>
</pre></div>
</div>
<p>More than one dimension:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4]])</span>
</pre></div>
</div>
<p>Minimum dimensions 2:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">array([[1, 2, 3]])</span>
</pre></div>
</div>
<p>Type provided:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="go">array([ 1.+0.j,  2.+0.j,  3.+0.j])</span>
</pre></div>
</div>
<p>Data-type consisting of more than one element:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)],</span><span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s">&#39;a&#39;</span><span class="p">,</span><span class="s">&#39;&lt;i4&#39;</span><span class="p">),(</span><span class="s">&#39;b&#39;</span><span class="p">,</span><span class="s">&#39;&lt;i4&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">]</span>
<span class="go">array([1, 3])</span>
</pre></div>
</div>
<p>Creating an array from sub-classes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mat</span><span class="p">(</span><span class="s">&#39;1 2; 3 4&#39;</span><span class="p">))</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4]])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mat</span><span class="p">(</span><span class="s">&#39;1 2; 3 4&#39;</span><span class="p">),</span> <span class="n">subok</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">matrix([[1, 2],</span>
<span class="go">        [3, 4]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="trilinear-interp">
<h3>trilinear_interp<a class="headerlink" href="#trilinear-interp" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.interpolate.trilinear_interp">
<tt class="descclassname">dipy.reconst.interpolate.</tt><tt class="descname">trilinear_interp</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.interpolate.trilinear_interp" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolates data at index</p>
<p>Interpolates data from a 4d volume, first 3 dimensions are x, y, z the
last dimension holds data.</p>
</dd></dl>

</div>
<div class="section" id="callablearray">
<h3><a class="reference internal" href="#dipy.reconst.multi_voxel.CallableArray" title="dipy.reconst.multi_voxel.CallableArray"><tt class="xref py py-class docutils literal"><span class="pre">CallableArray</span></tt></a><a class="headerlink" href="#callablearray" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.multi_voxel.CallableArray">
<em class="property">class </em><tt class="descclassname">dipy.reconst.multi_voxel.</tt><tt class="descname">CallableArray</tt><a class="headerlink" href="#dipy.reconst.multi_voxel.CallableArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></tt></p>
<p>An array which can be called like a function</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">__call__</span></tt>(*args,&nbsp;**kwargs)</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">all</span></tt>([axis,&nbsp;out])</td>
<td>Returns True if all elements evaluate to True.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">any</span></tt>([axis,&nbsp;out])</td>
<td>Returns True if any of the elements of <cite>a</cite> evaluate to True.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">argmax</span></tt>([axis,&nbsp;out])</td>
<td>Return indices of the maximum values along the given axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">argmin</span></tt>([axis,&nbsp;out])</td>
<td>Return indices of the minimum values along the given axis of <cite>a</cite>.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">argpartition</span></tt>(kth[,&nbsp;axis,&nbsp;kind,&nbsp;order])</td>
<td>Returns the indices that would partition this array.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">argsort</span></tt>([axis,&nbsp;kind,&nbsp;order])</td>
<td>Returns the indices that would sort this array.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">astype</span></tt>(dtype[,&nbsp;order,&nbsp;casting,&nbsp;subok,&nbsp;copy])</td>
<td>Copy of the array, cast to a specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">byteswap</span></tt>(inplace)</td>
<td>Swap the bytes of the array elements</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">choose</span></tt>(choices[,&nbsp;out,&nbsp;mode])</td>
<td>Use an index array to construct a new array from a set of choices.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">clip</span></tt>(a_min,&nbsp;a_max[,&nbsp;out])</td>
<td>Return an array whose values are limited to <tt class="docutils literal"><span class="pre">[a_min,</span> <span class="pre">a_max]</span></tt>.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">compress</span></tt>(condition[,&nbsp;axis,&nbsp;out])</td>
<td>Return selected slices of this array along given axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">conj</span></tt>()</td>
<td>Complex-conjugate all elements.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">conjugate</span></tt>()</td>
<td>Return the complex conjugate, element-wise.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">copy</span></tt>([order])</td>
<td>Return a copy of the array.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">cumprod</span></tt>([axis,&nbsp;dtype,&nbsp;out])</td>
<td>Return the cumulative product of the elements along the given axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">cumsum</span></tt>([axis,&nbsp;dtype,&nbsp;out])</td>
<td>Return the cumulative sum of the elements along the given axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">diagonal</span></tt>([offset,&nbsp;axis1,&nbsp;axis2])</td>
<td>Return specified diagonals.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">dot</span></tt>(b[,&nbsp;out])</td>
<td>Dot product of two arrays.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">dump</span></tt>(file)</td>
<td>Dump a pickle of the array to the specified file.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">dumps</span></tt>()</td>
<td>Returns the pickle of the array as a string.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">fill</span></tt>(value)</td>
<td>Fill the array with a scalar value.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">flatten</span></tt>([order])</td>
<td>Return a copy of the array collapsed into one dimension.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">getfield</span></tt>(dtype[,&nbsp;offset])</td>
<td>Returns a field of the given array as a certain type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">item</span></tt>(*args)</td>
<td>Copy an element of an array to a standard Python scalar and return it.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">itemset</span></tt>(*args)</td>
<td>Insert scalar into an array (scalar is cast to array&#8217;s dtype, if possible)</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">max</span></tt>([axis,&nbsp;out])</td>
<td>Return the maximum along a given axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">mean</span></tt>([axis,&nbsp;dtype,&nbsp;out])</td>
<td>Returns the average of the array elements along given axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">min</span></tt>([axis,&nbsp;out])</td>
<td>Return the minimum along a given axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">newbyteorder</span></tt>([new_order])</td>
<td>Return the array with the same data viewed with a different byte order.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">nonzero</span></tt>()</td>
<td>Return the indices of the elements that are non-zero.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">partition</span></tt>(kth[,&nbsp;axis,&nbsp;kind,&nbsp;order])</td>
<td>Rearranges the elements in the array in such a way that value of the element in kth position is in the position it would be in a sorted array.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">prod</span></tt>([axis,&nbsp;dtype,&nbsp;out])</td>
<td>Return the product of the array elements over the given axis</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">ptp</span></tt>([axis,&nbsp;out])</td>
<td>Peak to peak (maximum - minimum) value along a given axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">put</span></tt>(indices,&nbsp;values[,&nbsp;mode])</td>
<td>Set <tt class="docutils literal"><span class="pre">a.flat[n]</span> <span class="pre">=</span> <span class="pre">values[n]</span></tt> for all <cite>n</cite> in indices.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">ravel</span></tt>([order])</td>
<td>Return a flattened array.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">repeat</span></tt>(repeats[,&nbsp;axis])</td>
<td>Repeat elements of an array.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">reshape</span></tt>(shape[,&nbsp;order])</td>
<td>Returns an array containing the same data with a new shape.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">resize</span></tt>(new_shape[,&nbsp;refcheck])</td>
<td>Change shape and size of array in-place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">round</span></tt>([decimals,&nbsp;out])</td>
<td>Return <cite>a</cite> with each element rounded to the given number of decimals.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">searchsorted</span></tt>(v[,&nbsp;side,&nbsp;sorter])</td>
<td>Find indices where elements of v should be inserted in a to maintain order.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">setfield</span></tt>(val,&nbsp;dtype[,&nbsp;offset])</td>
<td>Put a value into a specified place in a field defined by a data-type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">setflags</span></tt>([write,&nbsp;align,&nbsp;uic])</td>
<td>Set array flags WRITEABLE, ALIGNED, and UPDATEIFCOPY, respectively.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">sort</span></tt>([axis,&nbsp;kind,&nbsp;order])</td>
<td>Sort an array, in-place.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">squeeze</span></tt>([axis])</td>
<td>Remove single-dimensional entries from the shape of <cite>a</cite>.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">std</span></tt>([axis,&nbsp;dtype,&nbsp;out,&nbsp;ddof])</td>
<td>Returns the standard deviation of the array elements along given axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">sum</span></tt>([axis,&nbsp;dtype,&nbsp;out])</td>
<td>Return the sum of the array elements over the given axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">swapaxes</span></tt>(axis1,&nbsp;axis2)</td>
<td>Return a view of the array with <cite>axis1</cite> and <cite>axis2</cite> interchanged.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">take</span></tt>(indices[,&nbsp;axis,&nbsp;out,&nbsp;mode])</td>
<td>Return an array formed from the elements of <cite>a</cite> at the given indices.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">tofile</span></tt>(fid[,&nbsp;sep,&nbsp;format])</td>
<td>Write array to a file as text or binary (default).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">tolist</span></tt>()</td>
<td>Return the array as a (possibly nested) list.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">tostring</span></tt>([order])</td>
<td>Construct a Python string containing the raw data bytes in the array.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">trace</span></tt>([offset,&nbsp;axis1,&nbsp;axis2,&nbsp;dtype,&nbsp;out])</td>
<td>Return the sum along diagonals of the array.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">transpose</span></tt>(*axes)</td>
<td>Returns a view of the array with axes transposed.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">var</span></tt>([axis,&nbsp;dtype,&nbsp;out,&nbsp;ddof])</td>
<td>Returns the variance of the array elements, along given axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">view</span></tt>([dtype,&nbsp;type])</td>
<td>New view of array with the same data.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.multi_voxel.CallableArray.__init__">
<tt class="descname">__init__</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.multi_voxel.CallableArray.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="multivoxelfit">
<h3><a class="reference internal" href="#dipy.reconst.multi_voxel.MultiVoxelFit" title="dipy.reconst.multi_voxel.MultiVoxelFit"><tt class="xref py py-class docutils literal"><span class="pre">MultiVoxelFit</span></tt></a><a class="headerlink" href="#multivoxelfit" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.multi_voxel.MultiVoxelFit">
<em class="property">class </em><tt class="descclassname">dipy.reconst.multi_voxel.</tt><tt class="descname">MultiVoxelFit</tt><big>(</big><em>model</em>, <em>fit_array</em>, <em>mask</em><big>)</big><a class="headerlink" href="#dipy.reconst.multi_voxel.MultiVoxelFit" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstFit" title="dipy.reconst.base.ReconstFit"><tt class="xref py py-class docutils literal"><span class="pre">dipy.reconst.base.ReconstFit</span></tt></a></p>
<p>Holds an array of fits and allows access to their attributes and
methods</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.multi_voxel.MultiVoxelFit.predict" title="dipy.reconst.multi_voxel.MultiVoxelFit.predict"><tt class="xref py py-obj docutils literal"><span class="pre">predict</span></tt></a>(*args,&nbsp;**kwargs)</td>
<td>Predict for the multi-voxel object using each single-object&#8217;s prediction API, with S0 provided from an array.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.multi_voxel.MultiVoxelFit.__init__">
<tt class="descname">__init__</tt><big>(</big><em>model</em>, <em>fit_array</em>, <em>mask</em><big>)</big><a class="headerlink" href="#dipy.reconst.multi_voxel.MultiVoxelFit.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.reconst.multi_voxel.MultiVoxelFit.predict">
<tt class="descname">predict</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#dipy.reconst.multi_voxel.MultiVoxelFit.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict for the multi-voxel object using each single-object&#8217;s
prediction API, with S0 provided from an array.</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.multi_voxel.MultiVoxelFit.shape">
<tt class="descname">shape</tt><a class="headerlink" href="#dipy.reconst.multi_voxel.MultiVoxelFit.shape" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="id184">
<h3><a class="reference internal" href="#dipy.reconst.multi_voxel.ReconstFit" title="dipy.reconst.multi_voxel.ReconstFit"><tt class="xref py py-class docutils literal"><span class="pre">ReconstFit</span></tt></a><a class="headerlink" href="#id184" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.multi_voxel.ReconstFit">
<em class="property">class </em><tt class="descclassname">dipy.reconst.multi_voxel.</tt><tt class="descname">ReconstFit</tt><big>(</big><em>model</em>, <em>data</em><big>)</big><a class="headerlink" href="#dipy.reconst.multi_voxel.ReconstFit" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></a></p>
<p>Abstract class which holds the fit result of ReconstModel</p>
<p>For example that could be holding FA or GFA etc.</p>
<dl class="method">
<dt id="dipy.reconst.multi_voxel.ReconstFit.__init__">
<tt class="descname">__init__</tt><big>(</big><em>model</em>, <em>data</em><big>)</big><a class="headerlink" href="#dipy.reconst.multi_voxel.ReconstFit.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="id185">
<h3><a class="reference internal" href="#dipy.reconst.multi_voxel.ReconstModel" title="dipy.reconst.multi_voxel.ReconstModel"><tt class="xref py py-class docutils literal"><span class="pre">ReconstModel</span></tt></a><a class="headerlink" href="#id185" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.multi_voxel.ReconstModel">
<em class="property">class </em><tt class="descclassname">dipy.reconst.multi_voxel.</tt><tt class="descname">ReconstModel</tt><big>(</big><em>gtab</em><big>)</big><a class="headerlink" href="#dipy.reconst.multi_voxel.ReconstModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></a></p>
<p>Abstract class for signal reconstruction models</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.multi_voxel.ReconstModel.fit" title="dipy.reconst.multi_voxel.ReconstModel.fit"><tt class="xref py py-obj docutils literal"><span class="pre">fit</span></tt></a>(data[,&nbsp;mask])</td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.multi_voxel.ReconstModel.__init__">
<tt class="descname">__init__</tt><big>(</big><em>gtab</em><big>)</big><a class="headerlink" href="#dipy.reconst.multi_voxel.ReconstModel.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialization of the abstract class for signal reconstruction models</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>gtab</strong> : GradientTable class instance</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.multi_voxel.ReconstModel.fit">
<tt class="descname">fit</tt><big>(</big><em>data</em>, <em>mask=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#dipy.reconst.multi_voxel.ReconstModel.fit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="as-strided">
<h3>as_strided<a class="headerlink" href="#as-strided" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.multi_voxel.as_strided">
<tt class="descclassname">dipy.reconst.multi_voxel.</tt><tt class="descname">as_strided</tt><big>(</big><em>x</em>, <em>shape=None</em>, <em>strides=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.multi_voxel.as_strided" title="Permalink to this definition">¶</a></dt>
<dd><p>Make an ndarray from the given array with the given shape and strides.</p>
</dd></dl>

</div>
<div class="section" id="id186">
<h3>multi_voxel_fit<a class="headerlink" href="#id186" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.multi_voxel.multi_voxel_fit">
<tt class="descclassname">dipy.reconst.multi_voxel.</tt><tt class="descname">multi_voxel_fit</tt><big>(</big><em>single_voxel_fit</em><big>)</big><a class="headerlink" href="#dipy.reconst.multi_voxel.multi_voxel_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Method decorator to turn a single voxel model fit
definition into a multi voxel model fit definition</p>
</dd></dl>

</div>
<div class="section" id="id187">
<h3>ndindex<a class="headerlink" href="#id187" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.multi_voxel.ndindex">
<tt class="descclassname">dipy.reconst.multi_voxel.</tt><tt class="descname">ndindex</tt><big>(</big><em>shape</em><big>)</big><a class="headerlink" href="#dipy.reconst.multi_voxel.ndindex" title="Permalink to this definition">¶</a></dt>
<dd><p>An N-dimensional iterator object to index arrays.</p>
<p>Given the shape of an array, an <cite>ndindex</cite> instance iterates over
the N-dimensional index of the array. At each iteration a tuple
of indices is returned; the last dimension is iterated over first.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>shape</strong> : tuple of ints</p>
<blockquote class="last">
<div><p>The dimensions of the array.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.core.ndindex</span> <span class="kn">import</span> <span class="n">ndindex</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
<span class="go">(0, 0, 0)</span>
<span class="go">(0, 1, 0)</span>
<span class="go">(1, 0, 0)</span>
<span class="go">(1, 1, 0)</span>
<span class="go">(2, 0, 0)</span>
<span class="go">(2, 1, 0)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="id188">
<h3><a class="reference internal" href="#dipy.reconst.odf.OdfFit" title="dipy.reconst.odf.OdfFit"><tt class="xref py py-class docutils literal"><span class="pre">OdfFit</span></tt></a><a class="headerlink" href="#id188" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.odf.OdfFit">
<em class="property">class </em><tt class="descclassname">dipy.reconst.odf.</tt><tt class="descname">OdfFit</tt><big>(</big><em>model</em>, <em>data</em><big>)</big><a class="headerlink" href="#dipy.reconst.odf.OdfFit" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstFit" title="dipy.reconst.base.ReconstFit"><tt class="xref py py-class docutils literal"><span class="pre">dipy.reconst.base.ReconstFit</span></tt></a></p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.odf.OdfFit.odf" title="dipy.reconst.odf.OdfFit.odf"><tt class="xref py py-obj docutils literal"><span class="pre">odf</span></tt></a>(sphere)</td>
<td>To be implemented but specific odf models</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.odf.OdfFit.__init__">
<tt class="descname">__init__</tt><big>(</big><em>model</em>, <em>data</em><big>)</big><a class="headerlink" href="#dipy.reconst.odf.OdfFit.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.reconst.odf.OdfFit.odf">
<tt class="descname">odf</tt><big>(</big><em>sphere</em><big>)</big><a class="headerlink" href="#dipy.reconst.odf.OdfFit.odf" title="Permalink to this definition">¶</a></dt>
<dd><p>To be implemented but specific odf models</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id189">
<h3><a class="reference internal" href="#dipy.reconst.odf.OdfModel" title="dipy.reconst.odf.OdfModel"><tt class="xref py py-class docutils literal"><span class="pre">OdfModel</span></tt></a><a class="headerlink" href="#id189" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.odf.OdfModel">
<em class="property">class </em><tt class="descclassname">dipy.reconst.odf.</tt><tt class="descname">OdfModel</tt><big>(</big><em>gtab</em><big>)</big><a class="headerlink" href="#dipy.reconst.odf.OdfModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><tt class="xref py py-class docutils literal"><span class="pre">dipy.reconst.base.ReconstModel</span></tt></a></p>
<p>An abstract class to be sub-classed by specific odf models</p>
<p>All odf models should provide a fit method which may take data as it&#8217;s
first and only argument.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.odf.OdfModel.fit" title="dipy.reconst.odf.OdfModel.fit"><tt class="xref py py-obj docutils literal"><span class="pre">fit</span></tt></a>(data)</td>
<td>To be implemented by specific odf models</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.odf.OdfModel.__init__">
<tt class="descname">__init__</tt><big>(</big><em>gtab</em><big>)</big><a class="headerlink" href="#dipy.reconst.odf.OdfModel.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.reconst.odf.OdfModel.fit">
<tt class="descname">fit</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#dipy.reconst.odf.OdfModel.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>To be implemented by specific odf models</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id190">
<h3><a class="reference internal" href="#dipy.reconst.odf.ReconstFit" title="dipy.reconst.odf.ReconstFit"><tt class="xref py py-class docutils literal"><span class="pre">ReconstFit</span></tt></a><a class="headerlink" href="#id190" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.odf.ReconstFit">
<em class="property">class </em><tt class="descclassname">dipy.reconst.odf.</tt><tt class="descname">ReconstFit</tt><big>(</big><em>model</em>, <em>data</em><big>)</big><a class="headerlink" href="#dipy.reconst.odf.ReconstFit" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></a></p>
<p>Abstract class which holds the fit result of ReconstModel</p>
<p>For example that could be holding FA or GFA etc.</p>
<dl class="method">
<dt id="dipy.reconst.odf.ReconstFit.__init__">
<tt class="descname">__init__</tt><big>(</big><em>model</em>, <em>data</em><big>)</big><a class="headerlink" href="#dipy.reconst.odf.ReconstFit.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="id191">
<h3><a class="reference internal" href="#dipy.reconst.odf.ReconstModel" title="dipy.reconst.odf.ReconstModel"><tt class="xref py py-class docutils literal"><span class="pre">ReconstModel</span></tt></a><a class="headerlink" href="#id191" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.odf.ReconstModel">
<em class="property">class </em><tt class="descclassname">dipy.reconst.odf.</tt><tt class="descname">ReconstModel</tt><big>(</big><em>gtab</em><big>)</big><a class="headerlink" href="#dipy.reconst.odf.ReconstModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></a></p>
<p>Abstract class for signal reconstruction models</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.odf.ReconstModel.fit" title="dipy.reconst.odf.ReconstModel.fit"><tt class="xref py py-obj docutils literal"><span class="pre">fit</span></tt></a>(data[,&nbsp;mask])</td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.odf.ReconstModel.__init__">
<tt class="descname">__init__</tt><big>(</big><em>gtab</em><big>)</big><a class="headerlink" href="#dipy.reconst.odf.ReconstModel.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialization of the abstract class for signal reconstruction models</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>gtab</strong> : GradientTable class instance</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.odf.ReconstModel.fit">
<tt class="descname">fit</tt><big>(</big><em>data</em>, <em>mask=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#dipy.reconst.odf.ReconstModel.fit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="id192">
<h3>gfa<a class="headerlink" href="#id192" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.odf.gfa">
<tt class="descclassname">dipy.reconst.odf.</tt><tt class="descname">gfa</tt><big>(</big><em>samples</em><big>)</big><a class="headerlink" href="#dipy.reconst.odf.gfa" title="Permalink to this definition">¶</a></dt>
<dd><p>The general fractional anisotropy of a function evaluated
on the unit sphere</p>
</dd></dl>

</div>
<div class="section" id="minmax-normalize">
<h3>minmax_normalize<a class="headerlink" href="#minmax-normalize" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.odf.minmax_normalize">
<tt class="descclassname">dipy.reconst.odf.</tt><tt class="descname">minmax_normalize</tt><big>(</big><em>samples</em>, <em>out=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.odf.minmax_normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Min-max normalization of a function evaluated on the unit sphere</p>
<p>Normalizes samples to <tt class="docutils literal"><span class="pre">(samples</span> <span class="pre">-</span> <span class="pre">min(samples))</span> <span class="pre">/</span> <span class="pre">(max(samples)</span> <span class="pre">-</span>
<span class="pre">min(samples))</span></tt> for each unit sphere.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>samples</strong> : ndarray (..., N)</p>
<blockquote>
<div><p>N samples on a unit sphere for each point, stored along the last axis
of the array.</p>
</div></blockquote>
<p><strong>out</strong> : ndrray (..., N), optional</p>
<blockquote>
<div><p>An array to store the normalized samples.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> : ndarray, (..., N)</p>
<blockquote class="last">
<div><p>Normalized samples.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="hemisphere">
<h3><a class="reference internal" href="#dipy.reconst.peaks.HemiSphere" title="dipy.reconst.peaks.HemiSphere"><tt class="xref py py-class docutils literal"><span class="pre">HemiSphere</span></tt></a><a class="headerlink" href="#hemisphere" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.peaks.HemiSphere">
<em class="property">class </em><tt class="descclassname">dipy.reconst.peaks.</tt><tt class="descname">HemiSphere</tt><big>(</big><em>x=None</em>, <em>y=None</em>, <em>z=None</em>, <em>theta=None</em>, <em>phi=None</em>, <em>xyz=None</em>, <em>faces=None</em>, <em>edges=None</em>, <em>tol=1e-05</em><big>)</big><a class="headerlink" href="#dipy.reconst.peaks.HemiSphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="dipy.core.html#dipy.core.sphere.Sphere" title="dipy.core.sphere.Sphere"><tt class="xref py py-class docutils literal"><span class="pre">dipy.core.sphere.Sphere</span></tt></a></p>
<p>Points on the unit sphere.</p>
<p>A HemiSphere is similar to a Sphere but it takes antipodal symmetry into
account. Antipodal symmetry means that point v on a HemiSphere is the same
as the point -v. Duplicate points are discarded when constructing a
HemiSphere (including antipodal duplicates). <cite>edges</cite> and <cite>faces</cite> are
remapped to the remaining points as closely as possible.</p>
<p>The HemiSphere can be constructed using one of three conventions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">HemiSphere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="n">HemiSphere</span><span class="p">(</span><span class="n">xyz</span><span class="o">=</span><span class="n">xyz</span><span class="p">)</span>
<span class="n">HemiSphere</span><span class="p">(</span><span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="o">=</span><span class="n">phi</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x, y, z</strong> : 1-D array_like</p>
<blockquote>
<div><p>Vertices as x-y-z coordinates.</p>
</div></blockquote>
<p><strong>theta, phi</strong> : 1-D array_like</p>
<blockquote>
<div><p>Vertices as spherical coordinates.  Theta and phi are the inclination
and azimuth angles respectively.</p>
</div></blockquote>
<p><strong>xyz</strong> : (N, 3) ndarray</p>
<blockquote>
<div><p>Vertices as x-y-z coordinates.</p>
</div></blockquote>
<p><strong>faces</strong> : (N, 3) ndarray</p>
<blockquote>
<div><p>Indices into vertices that form triangular faces.  If unspecified,
the faces are computed using a Delaunay triangulation.</p>
</div></blockquote>
<p><strong>edges</strong> : (N, 2) ndarray</p>
<blockquote>
<div><p>Edges between vertices.  If unspecified, the edges are
derived from the faces.</p>
</div></blockquote>
<p><strong>tol</strong> : float</p>
<blockquote class="last">
<div><p>Angle in degrees. Vertices that are less than tol degrees apart are
treated as duplicates.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#dipy.reconst.peaks.Sphere" title="dipy.reconst.peaks.Sphere"><tt class="xref py py-obj docutils literal"><span class="pre">Sphere</span></tt></a></p>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">edges</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.peaks.HemiSphere.faces" title="dipy.reconst.peaks.HemiSphere.faces"><tt class="xref py py-obj docutils literal"><span class="pre">faces</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.peaks.HemiSphere.find_closest" title="dipy.reconst.peaks.HemiSphere.find_closest"><tt class="xref py py-obj docutils literal"><span class="pre">find_closest</span></tt></a>(xyz)</td>
<td>Find the index of the vertex in the Sphere closest to the input vector,</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.peaks.HemiSphere.from_sphere" title="dipy.reconst.peaks.HemiSphere.from_sphere"><tt class="xref py py-obj docutils literal"><span class="pre">from_sphere</span></tt></a>(klass,&nbsp;sphere[,&nbsp;tol])</td>
<td>Create instance from a Sphere</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.peaks.HemiSphere.mirror" title="dipy.reconst.peaks.HemiSphere.mirror"><tt class="xref py py-obj docutils literal"><span class="pre">mirror</span></tt></a>()</td>
<td>Create a full Sphere from a HemiSphere</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.peaks.HemiSphere.subdivide" title="dipy.reconst.peaks.HemiSphere.subdivide"><tt class="xref py py-obj docutils literal"><span class="pre">subdivide</span></tt></a>([n])</td>
<td>Create a more subdivided HemiSphere</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">vertices</span></tt>()</td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.peaks.HemiSphere.__init__">
<tt class="descname">__init__</tt><big>(</big><em>x=None</em>, <em>y=None</em>, <em>z=None</em>, <em>theta=None</em>, <em>phi=None</em>, <em>xyz=None</em>, <em>faces=None</em>, <em>edges=None</em>, <em>tol=1e-05</em><big>)</big><a class="headerlink" href="#dipy.reconst.peaks.HemiSphere.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a HemiSphere from points</p>
</dd></dl>

<dl class="staticmethod">
<dt id="dipy.reconst.peaks.HemiSphere.faces">
<em class="property">static </em><tt class="descname">faces</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.peaks.HemiSphere.faces" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.reconst.peaks.HemiSphere.find_closest">
<tt class="descname">find_closest</tt><big>(</big><em>xyz</em><big>)</big><a class="headerlink" href="#dipy.reconst.peaks.HemiSphere.find_closest" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the index of the vertex in the Sphere closest to the input vector,
taking into account antipodal symmetry</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>xyz</strong> : array-like, 3 elements</p>
<blockquote class="last">
<div><p>A unit vector</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="dipy.reconst.peaks.HemiSphere.from_sphere">
<em class="property">classmethod </em><tt class="descname">from_sphere</tt><big>(</big><em>klass</em>, <em>sphere</em>, <em>tol=1e-05</em><big>)</big><a class="headerlink" href="#dipy.reconst.peaks.HemiSphere.from_sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Create instance from a Sphere</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.peaks.HemiSphere.mirror">
<tt class="descname">mirror</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.peaks.HemiSphere.mirror" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a full Sphere from a HemiSphere</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.peaks.HemiSphere.subdivide">
<tt class="descname">subdivide</tt><big>(</big><em>n=1</em><big>)</big><a class="headerlink" href="#dipy.reconst.peaks.HemiSphere.subdivide" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a more subdivided HemiSphere</p>
<p>See Sphere.subdivide for full documentation.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="intemporarydirectory">
<h3><a class="reference internal" href="#dipy.reconst.peaks.InTemporaryDirectory" title="dipy.reconst.peaks.InTemporaryDirectory"><tt class="xref py py-class docutils literal"><span class="pre">InTemporaryDirectory</span></tt></a><a class="headerlink" href="#intemporarydirectory" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.peaks.InTemporaryDirectory">
<em class="property">class </em><tt class="descclassname">dipy.reconst.peaks.</tt><tt class="descname">InTemporaryDirectory</tt><big>(</big><em>suffix=''</em>, <em>prefix='tmp'</em>, <em>dir=None</em>, <em>chdir=False</em><big>)</big><a class="headerlink" href="#dipy.reconst.peaks.InTemporaryDirectory" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">nibabel.tmpdirs.TemporaryDirectory</span></tt></p>
<p>Create, return, and change directory to a temporary directory</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_cwd</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">InTemporaryDirectory</span><span class="p">()</span> <span class="k">as</span> <span class="n">tmpdir</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">_</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;test.txt&#39;</span><span class="p">,</span> <span class="s">&#39;wt&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;some text&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="s">&#39;test.txt&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">,</span> <span class="s">&#39;test.txt&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span> <span class="o">==</span> <span class="n">my_cwd</span>
<span class="go">True</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">cleanup</span></tt>()</td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.peaks.InTemporaryDirectory.__init__">
<tt class="descname">__init__</tt><big>(</big><em>suffix=''</em>, <em>prefix='tmp'</em>, <em>dir=None</em>, <em>chdir=False</em><big>)</big><a class="headerlink" href="#dipy.reconst.peaks.InTemporaryDirectory.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="peaksandmetrics">
<h3><a class="reference internal" href="#dipy.reconst.peaks.PeaksAndMetrics" title="dipy.reconst.peaks.PeaksAndMetrics"><tt class="xref py py-class docutils literal"><span class="pre">PeaksAndMetrics</span></tt></a><a class="headerlink" href="#peaksandmetrics" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.peaks.PeaksAndMetrics">
<em class="property">class </em><tt class="descclassname">dipy.reconst.peaks.</tt><tt class="descname">PeaksAndMetrics</tt><a class="headerlink" href="#dipy.reconst.peaks.PeaksAndMetrics" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">dipy.reconst.peak_direction_getter.PeaksAndMetricsDirectionGetter</span></tt></p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_direction</span></tt></td>
<td>Interpolate closest peaks to direction from voxels neighboring point</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initial_direction</span></tt></td>
<td>The best starting directions for fiber tracking from point</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.peaks.PeaksAndMetrics.__init__">
<tt class="descname">__init__</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.peaks.PeaksAndMetrics.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="peaksandmetricsdirectiongetter">
<h3><a class="reference internal" href="#dipy.reconst.peaks.PeaksAndMetricsDirectionGetter" title="dipy.reconst.peaks.PeaksAndMetricsDirectionGetter"><tt class="xref py py-class docutils literal"><span class="pre">PeaksAndMetricsDirectionGetter</span></tt></a><a class="headerlink" href="#peaksandmetricsdirectiongetter" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.peaks.PeaksAndMetricsDirectionGetter">
<em class="property">class </em><tt class="descclassname">dipy.reconst.peaks.</tt><tt class="descname">PeaksAndMetricsDirectionGetter</tt><a class="headerlink" href="#dipy.reconst.peaks.PeaksAndMetricsDirectionGetter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">dipy.tracking.local.direction_getter.DirectionGetter</span></tt></p>
<p>Deterministic Direction Getter based on peak directions.</p>
<p>This class contains the cython portion of the code for PeaksAndMetrics and
is not meant to be used on its own.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.peaks.PeaksAndMetricsDirectionGetter.get_direction" title="dipy.reconst.peaks.PeaksAndMetricsDirectionGetter.get_direction"><tt class="xref py py-obj docutils literal"><span class="pre">get_direction</span></tt></a></td>
<td>Interpolate closest peaks to direction from voxels neighboring point</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.peaks.PeaksAndMetricsDirectionGetter.initial_direction" title="dipy.reconst.peaks.PeaksAndMetricsDirectionGetter.initial_direction"><tt class="xref py py-obj docutils literal"><span class="pre">initial_direction</span></tt></a></td>
<td>The best starting directions for fiber tracking from point</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.peaks.PeaksAndMetricsDirectionGetter.__init__">
<tt class="descname">__init__</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.peaks.PeaksAndMetricsDirectionGetter.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.peaks.PeaksAndMetricsDirectionGetter.ang_thr">
<tt class="descname">ang_thr</tt><a class="headerlink" href="#dipy.reconst.peaks.PeaksAndMetricsDirectionGetter.ang_thr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.reconst.peaks.PeaksAndMetricsDirectionGetter.get_direction">
<tt class="descname">get_direction</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.peaks.PeaksAndMetricsDirectionGetter.get_direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate closest peaks to direction from voxels neighboring point</p>
<p>Update direction and return 0 if successful. If no tracking direction
could be found, return 1.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.peaks.PeaksAndMetricsDirectionGetter.initial_direction">
<tt class="descname">initial_direction</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.peaks.PeaksAndMetricsDirectionGetter.initial_direction" title="Permalink to this definition">¶</a></dt>
<dd><p>The best starting directions for fiber tracking from point</p>
<p>All the valid peaks in the voxel closest to point are returned as
initial directions.</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.peaks.PeaksAndMetricsDirectionGetter.qa_thr">
<tt class="descname">qa_thr</tt><a class="headerlink" href="#dipy.reconst.peaks.PeaksAndMetricsDirectionGetter.qa_thr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.peaks.PeaksAndMetricsDirectionGetter.total_weight">
<tt class="descname">total_weight</tt><a class="headerlink" href="#dipy.reconst.peaks.PeaksAndMetricsDirectionGetter.total_weight" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="id193">
<h3><a class="reference internal" href="#dipy.reconst.peaks.Sphere" title="dipy.reconst.peaks.Sphere"><tt class="xref py py-class docutils literal"><span class="pre">Sphere</span></tt></a><a class="headerlink" href="#id193" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.peaks.Sphere">
<em class="property">class </em><tt class="descclassname">dipy.reconst.peaks.</tt><tt class="descname">Sphere</tt><big>(</big><em>x=None</em>, <em>y=None</em>, <em>z=None</em>, <em>theta=None</em>, <em>phi=None</em>, <em>xyz=None</em>, <em>faces=None</em>, <em>edges=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.peaks.Sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></a></p>
<p>Points on the unit sphere.</p>
<p>The sphere can be constructed using one of three conventions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Sphere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="n">Sphere</span><span class="p">(</span><span class="n">xyz</span><span class="o">=</span><span class="n">xyz</span><span class="p">)</span>
<span class="n">Sphere</span><span class="p">(</span><span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="o">=</span><span class="n">phi</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x, y, z</strong> : 1-D array_like</p>
<blockquote>
<div><p>Vertices as x-y-z coordinates.</p>
</div></blockquote>
<p><strong>theta, phi</strong> : 1-D array_like</p>
<blockquote>
<div><p>Vertices as spherical coordinates.  Theta and phi are the inclination
and azimuth angles respectively.</p>
</div></blockquote>
<p><strong>xyz</strong> : (N, 3) ndarray</p>
<blockquote>
<div><p>Vertices as x-y-z coordinates.</p>
</div></blockquote>
<p><strong>faces</strong> : (N, 3) ndarray</p>
<blockquote>
<div><p>Indices into vertices that form triangular faces.  If unspecified,
the faces are computed using a Delaunay triangulation.</p>
</div></blockquote>
<p><strong>edges</strong> : (N, 2) ndarray</p>
<blockquote class="last">
<div><p>Edges between vertices.  If unspecified, the edges are
derived from the faces.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.peaks.Sphere.edges" title="dipy.reconst.peaks.Sphere.edges"><tt class="xref py py-obj docutils literal"><span class="pre">edges</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.peaks.Sphere.faces" title="dipy.reconst.peaks.Sphere.faces"><tt class="xref py py-obj docutils literal"><span class="pre">faces</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.peaks.Sphere.find_closest" title="dipy.reconst.peaks.Sphere.find_closest"><tt class="xref py py-obj docutils literal"><span class="pre">find_closest</span></tt></a>(xyz)</td>
<td>Find the index of the vertex in the Sphere closest to the input vector</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.peaks.Sphere.subdivide" title="dipy.reconst.peaks.Sphere.subdivide"><tt class="xref py py-obj docutils literal"><span class="pre">subdivide</span></tt></a>([n])</td>
<td>Subdivides each face of the sphere into four new faces.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.peaks.Sphere.vertices" title="dipy.reconst.peaks.Sphere.vertices"><tt class="xref py py-obj docutils literal"><span class="pre">vertices</span></tt></a>()</td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.peaks.Sphere.__init__">
<tt class="descname">__init__</tt><big>(</big><em>x=None</em>, <em>y=None</em>, <em>z=None</em>, <em>theta=None</em>, <em>phi=None</em>, <em>xyz=None</em>, <em>faces=None</em>, <em>edges=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.peaks.Sphere.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="dipy.reconst.peaks.Sphere.edges">
<em class="property">static </em><tt class="descname">edges</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.peaks.Sphere.edges" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="dipy.reconst.peaks.Sphere.faces">
<em class="property">static </em><tt class="descname">faces</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.peaks.Sphere.faces" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.reconst.peaks.Sphere.find_closest">
<tt class="descname">find_closest</tt><big>(</big><em>xyz</em><big>)</big><a class="headerlink" href="#dipy.reconst.peaks.Sphere.find_closest" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the index of the vertex in the Sphere closest to the input vector</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>xyz</strong> : array-like, 3 elements</p>
<blockquote class="last">
<div><p>A unit vector</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.peaks.Sphere.subdivide">
<tt class="descname">subdivide</tt><big>(</big><em>n=1</em><big>)</big><a class="headerlink" href="#dipy.reconst.peaks.Sphere.subdivide" title="Permalink to this definition">¶</a></dt>
<dd><p>Subdivides each face of the sphere into four new faces.</p>
<p>New vertices are created at a, b, and c. Then each face [x, y, z] is
divided into faces [x, a, c], [y, a, b], [z, b, c], and [a, b, c].</p>
<div class="highlight-python"><div class="highlight"><pre>   y
   /               /               a/____
/\    /            /  \  /             /____\/____          x      c     z
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>n</strong> : int, optional</p>
<blockquote>
<div><p>The number of subdivisions to preform.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>new_sphere</strong> : Sphere</p>
<blockquote class="last">
<div><p>The subdivided sphere.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="dipy.reconst.peaks.Sphere.vertices">
<em class="property">static </em><tt class="descname">vertices</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.peaks.Sphere.vertices" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.peaks.Sphere.x">
<tt class="descname">x</tt><a class="headerlink" href="#dipy.reconst.peaks.Sphere.x" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.peaks.Sphere.y">
<tt class="descname">y</tt><a class="headerlink" href="#dipy.reconst.peaks.Sphere.y" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.peaks.Sphere.z">
<tt class="descname">z</tt><a class="headerlink" href="#dipy.reconst.peaks.Sphere.z" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="repeat">
<h3><a class="reference internal" href="#dipy.reconst.peaks.repeat" title="dipy.reconst.peaks.repeat"><tt class="xref py py-class docutils literal"><span class="pre">repeat</span></tt></a><a class="headerlink" href="#repeat" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.peaks.repeat">
<em class="property">class </em><tt class="descclassname">dipy.reconst.peaks.</tt><tt class="descname">repeat</tt><a class="headerlink" href="#dipy.reconst.peaks.repeat" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></a></p>
<p>repeat(object [,times]) -&gt; create an iterator which returns the object
for the specified number of times.  If not specified, returns the object
endlessly.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.peaks.repeat.next" title="dipy.reconst.peaks.repeat.next"><tt class="xref py py-obj docutils literal"><span class="pre">next</span></tt></a></td>
<td>x.next() -&gt; the next value, or raise StopIteration</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.peaks.repeat.__init__">
<tt class="descname">__init__</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.peaks.repeat.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.peaks.repeat.next">
<tt class="descname">next</tt><a class="headerlink" href="#dipy.reconst.peaks.repeat.next" title="Permalink to this definition">¶</a></dt>
<dd><p>x.next() -&gt; the next value, or raise StopIteration</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="xrange">
<h3><a class="reference internal" href="#dipy.reconst.peaks.xrange" title="dipy.reconst.peaks.xrange"><tt class="xref py py-class docutils literal"><span class="pre">xrange</span></tt></a><a class="headerlink" href="#xrange" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.peaks.xrange">
<em class="property">class </em><tt class="descclassname">dipy.reconst.peaks.</tt><tt class="descname">xrange</tt><a class="headerlink" href="#dipy.reconst.peaks.xrange" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></a></p>
<p>xrange(stop) -&gt; xrange object
xrange(start, stop[, step]) -&gt; xrange object</p>
<p>Like range(), but instead of returning a list, returns an object that
generates the numbers in the range on demand.  For looping, this is 
slightly faster than range() and more memory efficient.</p>
<dl class="method">
<dt id="dipy.reconst.peaks.xrange.__init__">
<tt class="descname">__init__</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.peaks.xrange.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="pool">
<h3>Pool<a class="headerlink" href="#pool" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.peaks.Pool">
<tt class="descclassname">dipy.reconst.peaks.</tt><tt class="descname">Pool</tt><big>(</big><em>processes=None</em>, <em>initializer=None</em>, <em>initargs=()</em>, <em>maxtasksperchild=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.peaks.Pool" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a process pool object</p>
</dd></dl>

</div>
<div class="section" id="cpu-count">
<h3>cpu_count<a class="headerlink" href="#cpu-count" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.peaks.cpu_count">
<tt class="descclassname">dipy.reconst.peaks.</tt><tt class="descname">cpu_count</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.peaks.cpu_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of CPUs in the system</p>
</dd></dl>

</div>
<div class="section" id="id194">
<h3>gfa<a class="headerlink" href="#id194" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.peaks.gfa">
<tt class="descclassname">dipy.reconst.peaks.</tt><tt class="descname">gfa</tt><big>(</big><em>samples</em><big>)</big><a class="headerlink" href="#dipy.reconst.peaks.gfa" title="Permalink to this definition">¶</a></dt>
<dd><p>The general fractional anisotropy of a function evaluated
on the unit sphere</p>
</dd></dl>

</div>
<div class="section" id="id195">
<h3>local_maxima<a class="headerlink" href="#id195" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.peaks.local_maxima">
<tt class="descclassname">dipy.reconst.peaks.</tt><tt class="descname">local_maxima</tt><big>(</big><em>odf</em>, <em>edges</em><big>)</big><a class="headerlink" href="#dipy.reconst.peaks.local_maxima" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the local maxima of a function evaluated on a discrete set of points.</p>
<p>If a function is evaluated on some set of points where each pair of
neighboring points is an edge in edges, find the local maxima.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>odf</strong> : array, 1d, dtype=double</p>
<blockquote>
<div><p>The function evaluated on a set of discrete points.</p>
</div></blockquote>
<p><strong>edges</strong> : array (N, 2)</p>
<blockquote>
<div><p>The set of neighbor relations between the points. Every edge, ie
<cite>edges[i, :]</cite>, is a pair of neighboring points.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>peak_values</strong> : ndarray</p>
<blockquote>
<div><p>Value of odf at a maximum point. Peak values is sorted in descending
order.</p>
</div></blockquote>
<p><strong>peak_indices</strong> : ndarray</p>
<blockquote class="last">
<div><p>Indices of maximum points. Sorted in the same order as <cite>peak_values</cite> so
<cite>odf[peak_indices[i]] == peak_values[i]</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="dipy.core.html#module-dipy.core.sphere" title="dipy.core.sphere"><tt class="xref py py-obj docutils literal"><span class="pre">dipy.core.sphere</span></tt></a></p>
</div>
</dd></dl>

</div>
<div class="section" id="id196">
<h3>ndindex<a class="headerlink" href="#id196" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.peaks.ndindex">
<tt class="descclassname">dipy.reconst.peaks.</tt><tt class="descname">ndindex</tt><big>(</big><em>shape</em><big>)</big><a class="headerlink" href="#dipy.reconst.peaks.ndindex" title="Permalink to this definition">¶</a></dt>
<dd><p>An N-dimensional iterator object to index arrays.</p>
<p>Given the shape of an array, an <cite>ndindex</cite> instance iterates over
the N-dimensional index of the array. At each iteration a tuple
of indices is returned; the last dimension is iterated over first.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>shape</strong> : tuple of ints</p>
<blockquote class="last">
<div><p>The dimensions of the array.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.core.ndindex</span> <span class="kn">import</span> <span class="n">ndindex</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
<span class="go">(0, 0, 0)</span>
<span class="go">(0, 1, 0)</span>
<span class="go">(1, 0, 0)</span>
<span class="go">(1, 1, 0)</span>
<span class="go">(2, 0, 0)</span>
<span class="go">(2, 1, 0)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="peak-directions">
<h3>peak_directions<a class="headerlink" href="#peak-directions" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.peaks.peak_directions">
<tt class="descclassname">dipy.reconst.peaks.</tt><tt class="descname">peak_directions</tt><big>(</big><em>odf</em>, <em>sphere</em>, <em>relative_peak_threshold=0.5</em>, <em>min_separation_angle=25</em>, <em>minmax_norm=True</em><big>)</big><a class="headerlink" href="#dipy.reconst.peaks.peak_directions" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the directions of odf peaks</p>
<p>Peaks are defined as points on the odf that are greater than at least one
neighbor and greater than or equal to all neighbors. Peaks are sorted in
descending order by their values then filtered based on their relative size
and spacing on the sphere. An odf may have 0 peaks, for example if the odf
is perfectly isotropic.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>odf</strong> : 1d ndarray</p>
<blockquote>
<div><p>The odf function evaluated on the vertices of <cite>sphere</cite></p>
</div></blockquote>
<p><strong>sphere</strong> : Sphere</p>
<blockquote>
<div><p>The Sphere providing discrete directions for evaluation.</p>
</div></blockquote>
<p><strong>relative_peak_threshold</strong> : float in [0., 1.]</p>
<blockquote>
<div><p>Only peaks greater than <tt class="docutils literal"><span class="pre">min</span> <span class="pre">+</span> <span class="pre">relative_peak_threshold</span> <span class="pre">*</span> <span class="pre">scale</span></tt> are
kept, where <tt class="docutils literal"><span class="pre">min</span> <span class="pre">=</span> <span class="pre">max(0,</span> <span class="pre">odf.min())</span></tt> and
<tt class="docutils literal"><span class="pre">scale</span> <span class="pre">=</span> <span class="pre">odf.max()</span> <span class="pre">-</span> <span class="pre">min</span></tt>.</p>
</div></blockquote>
<p><strong>min_separation_angle</strong> : float in [0, 90]</p>
<blockquote>
<div><p>The minimum distance between directions. If two peaks are too close
only the larger of the two is returned.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>directions</strong> : (N, 3) ndarray</p>
<blockquote>
<div><p>N vertices for sphere, one for each peak</p>
</div></blockquote>
<p><strong>values</strong> : (N,) ndarray</p>
<blockquote>
<div><p>peak values</p>
</div></blockquote>
<p><strong>indices</strong> : (N,) ndarray</p>
<blockquote class="last">
<div><p>peak indices of the directions on the sphere</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>If the odf has any negative values, they will be clipped to zeros.</p>
</dd></dl>

</div>
<div class="section" id="peak-directions-nl">
<h3>peak_directions_nl<a class="headerlink" href="#peak-directions-nl" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.peaks.peak_directions_nl">
<tt class="descclassname">dipy.reconst.peaks.</tt><tt class="descname">peak_directions_nl</tt><big>(</big><em>sphere_eval</em>, <em>relative_peak_threshold=0.25</em>, <em>min_separation_angle=25</em>, <em>sphere=&lt;dipy.core.sphere.HemiSphere object at 0x2abac40027d0&gt;</em>, <em>xtol=1e-07</em><big>)</big><a class="headerlink" href="#dipy.reconst.peaks.peak_directions_nl" title="Permalink to this definition">¶</a></dt>
<dd><p>Non Linear Direction Finder</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sphere_eval</strong> : callable</p>
<blockquote>
<div><p>A function which can be evaluated on a sphere.</p>
</div></blockquote>
<p><strong>relative_peak_threshold</strong> : float</p>
<blockquote>
<div><p>Only return peaks greater than <tt class="docutils literal"><span class="pre">relative_peak_threshold</span> <span class="pre">*</span> <span class="pre">m</span></tt> where m
is the largest peak.</p>
</div></blockquote>
<p><strong>min_separation_angle</strong> : float in [0, 90]</p>
<blockquote>
<div><p>The minimum distance between directions. If two peaks are too close
only the larger of the two is returned.</p>
</div></blockquote>
<p><strong>sphere</strong> : Sphere</p>
<blockquote>
<div><p>A discrete Sphere. The points on the sphere will be used for initial
estimate of maximums.</p>
</div></blockquote>
<p><strong>xtol</strong> : float</p>
<blockquote>
<div><p>Relative tolerance for optimization.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>directions</strong> : array (N, 3)</p>
<blockquote>
<div><p>Points on the sphere corresponding to N local maxima on the sphere.</p>
</div></blockquote>
<p><strong>values</strong> : array (N,)</p>
<blockquote class="last">
<div><p>Value of sphere_eval at each point on directions.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id197">
<h3>peaks_from_model<a class="headerlink" href="#id197" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.peaks.peaks_from_model">
<tt class="descclassname">dipy.reconst.peaks.</tt><tt class="descname">peaks_from_model</tt><big>(</big><em>model</em>, <em>data</em>, <em>sphere</em>, <em>relative_peak_threshold</em>, <em>min_separation_angle</em>, <em>mask=None</em>, <em>return_odf=False</em>, <em>return_sh=True</em>, <em>gfa_thr=0</em>, <em>normalize_peaks=False</em>, <em>sh_order=8</em>, <em>sh_basis_type=None</em>, <em>npeaks=5</em>, <em>B=None</em>, <em>invB=None</em>, <em>parallel=False</em>, <em>nbr_processes=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.peaks.peaks_from_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Fits the model to data and computes peaks and metrics</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>model</strong> : a model instance</p>
<blockquote>
<div><p><cite>model</cite> will be used to fit the data.</p>
</div></blockquote>
<p><strong>sphere</strong> : Sphere</p>
<blockquote>
<div><p>The Sphere providing discrete directions for evaluation.</p>
</div></blockquote>
<p><strong>relative_peak_threshold</strong> : float</p>
<blockquote>
<div><p>Only return peaks greater than <tt class="docutils literal"><span class="pre">relative_peak_threshold</span> <span class="pre">*</span> <span class="pre">m</span></tt> where m
is the largest peak.</p>
</div></blockquote>
<p><strong>min_separation_angle</strong> : float in [0, 90] The minimum distance between</p>
<blockquote>
<div><p>directions. If two peaks are too close only the larger of the two is
returned.</p>
</div></blockquote>
<p><strong>mask</strong> : array, optional</p>
<blockquote>
<div><p>If <cite>mask</cite> is provided, voxels that are False in <cite>mask</cite> are skipped and
no peaks are returned.</p>
</div></blockquote>
<p><strong>return_odf</strong> : bool</p>
<blockquote>
<div><p>If True, the odfs are returned.</p>
</div></blockquote>
<p><strong>return_sh</strong> : bool</p>
<blockquote>
<div><p>If True, the odf as spherical harmonics coefficients is returned</p>
</div></blockquote>
<p><strong>gfa_thr</strong> : float</p>
<blockquote>
<div><p>Voxels with gfa less than <cite>gfa_thr</cite> are skipped, no peaks are returned.</p>
</div></blockquote>
<p><strong>normalize_peaks</strong> : bool</p>
<blockquote>
<div><p>If true, all peak values are calculated relative to <cite>max(odf)</cite>.</p>
</div></blockquote>
<p><strong>sh_order</strong> : int, optional</p>
<blockquote>
<div><p>Maximum SH order in the SH fit.  For <cite>sh_order</cite>, there will be
<tt class="docutils literal"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">*</span> <span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">2)</span> <span class="pre">/</span> <span class="pre">2</span></tt> SH coefficients (default 8).</p>
</div></blockquote>
<p><strong>sh_basis_type</strong> : {None, &#8216;mrtrix&#8217;, &#8216;fibernav&#8217;}</p>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">None</span></tt> for the default dipy basis which is the fibernav basis,
<tt class="docutils literal"><span class="pre">mrtrix</span></tt> for the MRtrix basis, and
<tt class="docutils literal"><span class="pre">fibernav</span></tt> for the FiberNavigator basis</p>
</div></blockquote>
<p><strong>sh_smooth</strong> : float, optional</p>
<blockquote>
<div><p>Lambda-regularization in the SH fit (default 0.0).</p>
</div></blockquote>
<p><strong>npeaks</strong> : int</p>
<blockquote>
<div><p>Maximum number of peaks found (default 5 peaks).</p>
</div></blockquote>
<p><strong>B</strong> : ndarray, optional</p>
<blockquote>
<div><p>Matrix that transforms spherical harmonics to spherical function
<tt class="docutils literal"><span class="pre">sf</span> <span class="pre">=</span> <span class="pre">np.dot(sh,</span> <span class="pre">B)</span></tt>.</p>
</div></blockquote>
<p><strong>invB</strong> : ndarray, optional</p>
<blockquote>
<div><p>Inverse of B.</p>
</div></blockquote>
<p><strong>parallel: bool</strong> :</p>
<blockquote>
<div><p>If True, use multiprocessing to compute peaks and metric
(default False). Temporary files are saved in the default temporary
directory of the system. It can be changed using <tt class="docutils literal"><span class="pre">import</span> <span class="pre">tempfile</span></tt>
and <tt class="docutils literal"><span class="pre">tempfile.tempdir</span> <span class="pre">=</span> <span class="pre">'/path/to/tempdir'</span></tt>.</p>
</div></blockquote>
<p><strong>nbr_processes: int</strong> :</p>
<blockquote>
<div><p>If <cite>parallel</cite> is True, the number of subprocesses to use
(default multiprocessing.cpu_count()).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>pam</strong> : PeaksAndMetrics</p>
<blockquote class="last">
<div><p>An object with <tt class="docutils literal"><span class="pre">gfa</span></tt>, <tt class="docutils literal"><span class="pre">peak_directions</span></tt>, <tt class="docutils literal"><span class="pre">peak_values</span></tt>,
<tt class="docutils literal"><span class="pre">peak_indices</span></tt>, <tt class="docutils literal"><span class="pre">odf</span></tt>, <tt class="docutils literal"><span class="pre">shm_coeffs</span></tt> as attributes</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id198">
<h3>remove_similar_vertices<a class="headerlink" href="#id198" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.peaks.remove_similar_vertices">
<tt class="descclassname">dipy.reconst.peaks.</tt><tt class="descname">remove_similar_vertices</tt><big>(</big><em>vertices</em>, <em>theta</em><big>)</big><a class="headerlink" href="#dipy.reconst.peaks.remove_similar_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns vertices that are separated by at least theta degrees from all
other vertices. Vertex v and -v are considered the same so if v and -v are
both in <cite>vertices</cite> only one is kept. Also if v and w are both in vertices,
w must be separated by theta degrees from both v and -v to be unique.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>vertices</strong> : (N, 3) ndarray</p>
<blockquote>
<div><p>N unit vectors</p>
</div></blockquote>
<p><strong>theta</strong> : float</p>
<blockquote>
<div><p>The minimum separation between vertices in degrees.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>unique_vertices</strong> : (M, 3) ndarray</p>
<blockquote>
<div><p>Vertices sufficiently separated from one another.</p>
</div></blockquote>
<p><strong>mapping</strong> : (N,) ndarray</p>
<blockquote class="last">
<div><p>Indices into unique_vertices. For each vertex in <cite>vertices</cite> the index
of a vertex in <cite>unique_vertices</cite> that is less than theta degrees away.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="reshape-peaks-for-visualization">
<h3>reshape_peaks_for_visualization<a class="headerlink" href="#reshape-peaks-for-visualization" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.peaks.reshape_peaks_for_visualization">
<tt class="descclassname">dipy.reconst.peaks.</tt><tt class="descname">reshape_peaks_for_visualization</tt><big>(</big><em>peaks</em><big>)</big><a class="headerlink" href="#dipy.reconst.peaks.reshape_peaks_for_visualization" title="Permalink to this definition">¶</a></dt>
<dd><p>Reshape peaks for visualization.</p>
<p>Reshape and convert to float32 a set of peaks for visualisation with mrtrix
or the fibernavigator.</p>
</dd></dl>

</div>
<div class="section" id="search-descending">
<h3>search_descending<a class="headerlink" href="#search-descending" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.peaks.search_descending">
<tt class="descclassname">dipy.reconst.peaks.</tt><tt class="descname">search_descending</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.peaks.search_descending" title="Permalink to this definition">¶</a></dt>
<dd><p>Searches a descending array for the first element smaller than some
threshold</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a</strong> : ndarray, ndim=1, c-contiguous</p>
<blockquote>
<div><p>Array to be searched.</p>
</div></blockquote>
<p><strong>relative_threshold</strong> : float</p>
<blockquote>
<div><p>Threshold relative to <cite>a[0]</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>i</strong> : int</p>
<blockquote class="last">
<div><p>The greatest index such that <tt class="docutils literal"><span class="pre">all(a[:i]</span> <span class="pre">&gt;=</span> <span class="pre">relative_threshold</span> <span class="pre">*</span>
<span class="pre">a[0])</span></tt>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="sh-to-sf-matrix">
<h3>sh_to_sf_matrix<a class="headerlink" href="#sh-to-sf-matrix" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.peaks.sh_to_sf_matrix">
<tt class="descclassname">dipy.reconst.peaks.</tt><tt class="descname">sh_to_sf_matrix</tt><big>(</big><em>sphere</em>, <em>sh_order</em>, <em>basis_type=None</em>, <em>return_inv=True</em>, <em>smooth=0</em><big>)</big><a class="headerlink" href="#dipy.reconst.peaks.sh_to_sf_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Matrix that transforms Spherical harmonics (SH) to spherical
function (SF).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sphere</strong> : Sphere</p>
<blockquote>
<div><p>The points on which to sample the spherical function.</p>
</div></blockquote>
<p><strong>sh_order</strong> : int, optional</p>
<blockquote>
<div><p>Maximum SH order in the SH fit.  For <cite>sh_order</cite>, there will be
<tt class="docutils literal"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">*</span> <span class="pre">(sh_order_2)</span> <span class="pre">/</span> <span class="pre">2</span></tt> SH coefficients (default 4).</p>
</div></blockquote>
<p><strong>basis_type</strong> : {None, &#8216;mrtrix&#8217;, &#8216;fibernav&#8217;}</p>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">None</span></tt> for the default dipy basis,
<tt class="docutils literal"><span class="pre">mrtrix</span></tt> for the MRtrix basis, and
<tt class="docutils literal"><span class="pre">fibernav</span></tt> for the FiberNavigator basis
(default <tt class="docutils literal"><span class="pre">None</span></tt>).</p>
</div></blockquote>
<p><strong>return_inv</strong> : bool</p>
<blockquote>
<div><p>If True then the inverse of the matrix is also returned</p>
</div></blockquote>
<p><strong>smooth</strong> : float, optional</p>
<blockquote>
<div><p>Lambda-regularization in the SH fit (default 0.0).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>B</strong> : ndarray</p>
<blockquote>
<div><p>Matrix that transforms spherical harmonics to spherical function
<tt class="docutils literal"><span class="pre">sf</span> <span class="pre">=</span> <span class="pre">np.dot(sh,</span> <span class="pre">B)</span></tt>.</p>
</div></blockquote>
<p><strong>invB</strong> : ndarray</p>
<blockquote class="last">
<div><p>Inverse of B.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="warn">
<h3>warn<a class="headerlink" href="#warn" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.peaks.warn">
<tt class="descclassname">dipy.reconst.peaks.</tt><tt class="descname">warn</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.peaks.warn" title="Permalink to this definition">¶</a></dt>
<dd><p>Issue a warning, or maybe ignore it or raise an exception.</p>
</dd></dl>

</div>
<div class="section" id="id199">
<h3><a class="reference internal" href="#dipy.reconst.sfm.Cache" title="dipy.reconst.sfm.Cache"><tt class="xref py py-class docutils literal"><span class="pre">Cache</span></tt></a><a class="headerlink" href="#id199" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.sfm.Cache">
<em class="property">class </em><tt class="descclassname">dipy.reconst.sfm.</tt><tt class="descname">Cache</tt><a class="headerlink" href="#dipy.reconst.sfm.Cache" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></a></p>
<p>Cache values based on a key object (such as a sphere or gradient table).</p>
<p class="rubric">Notes</p>
<p>This class is meant to be used as a mix-in:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MyModel</span><span class="p">(</span><span class="n">Model</span><span class="p">,</span> <span class="n">Cache</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">MyModelFit</span><span class="p">(</span><span class="n">Fit</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>Inside a method on the fit, typical usage would be:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">odf</span><span class="p">(</span><span class="n">sphere</span><span class="p">):</span>
    <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">cache_get</span><span class="p">(</span><span class="s">&#39;odf_basis_matrix&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sphere</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">M</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_basis_matrix</span><span class="p">(</span><span class="n">sphere</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">cache_set</span><span class="p">(</span><span class="s">&#39;odf_basis_matrix&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sphere</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">M</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.sfm.Cache.cache_clear" title="dipy.reconst.sfm.Cache.cache_clear"><tt class="xref py py-obj docutils literal"><span class="pre">cache_clear</span></tt></a>()</td>
<td>Clear the cache.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.sfm.Cache.cache_get" title="dipy.reconst.sfm.Cache.cache_get"><tt class="xref py py-obj docutils literal"><span class="pre">cache_get</span></tt></a>(tag,&nbsp;key[,&nbsp;default])</td>
<td>Retrieve a value from the cache.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.sfm.Cache.cache_set" title="dipy.reconst.sfm.Cache.cache_set"><tt class="xref py py-obj docutils literal"><span class="pre">cache_set</span></tt></a>(tag,&nbsp;key,&nbsp;value)</td>
<td>Store a value in the cache.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.sfm.Cache.__init__">
<tt class="descname">__init__</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.sfm.Cache.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.sfm.Cache.cache_clear">
<tt class="descname">cache_clear</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.sfm.Cache.cache_clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear the cache.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.sfm.Cache.cache_get">
<tt class="descname">cache_get</tt><big>(</big><em>tag</em>, <em>key</em>, <em>default=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.sfm.Cache.cache_get" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a value from the cache.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>tag</strong> : str</p>
<blockquote>
<div><p>Description of the cached value.</p>
</div></blockquote>
<p><strong>key</strong> : object</p>
<blockquote>
<div><p>Key object used to look up the cached value.</p>
</div></blockquote>
<p><strong>default</strong> : object</p>
<blockquote>
<div><p>Value to be returned if no cached entry is found.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>v</strong> : object</p>
<blockquote class="last">
<div><p>Value from the cache associated with <tt class="docutils literal"><span class="pre">(tag,</span> <span class="pre">key)</span></tt>.  Returns
<cite>default</cite> if no cached entry is found.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.sfm.Cache.cache_set">
<tt class="descname">cache_set</tt><big>(</big><em>tag</em>, <em>key</em>, <em>value</em><big>)</big><a class="headerlink" href="#dipy.reconst.sfm.Cache.cache_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Store a value in the cache.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>tag</strong> : str</p>
<blockquote>
<div><p>Description of the cached value.</p>
</div></blockquote>
<p><strong>key</strong> : object</p>
<blockquote>
<div><p>Key object used to look up the cached value.</p>
</div></blockquote>
<p><strong>value</strong> : object</p>
<blockquote class="last">
<div><p>Value stored in the cache for each unique combination
of <tt class="docutils literal"><span class="pre">(tag,</span> <span class="pre">key)</span></tt>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">compute_expensive_matrix</span><span class="p">(</span><span class="n">parameters</span><span class="p">):</span>
<span class="gp">... </span>    <span class="c"># Imagine the following computation is very expensive</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Cache</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">parameters</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X1</span> <span class="o">=</span> <span class="n">compute_expensive_matrix</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">cache_set</span><span class="p">(</span><span class="s">&#39;expensive_matrix&#39;</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">X1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X2</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">cache_get</span><span class="p">(</span><span class="s">&#39;expensive_matrix&#39;</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">X1</span> <span class="ow">is</span> <span class="n">X2</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="exponentialisotropicfit">
<h3><a class="reference internal" href="#dipy.reconst.sfm.ExponentialIsotropicFit" title="dipy.reconst.sfm.ExponentialIsotropicFit"><tt class="xref py py-class docutils literal"><span class="pre">ExponentialIsotropicFit</span></tt></a><a class="headerlink" href="#exponentialisotropicfit" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.sfm.ExponentialIsotropicFit">
<em class="property">class </em><tt class="descclassname">dipy.reconst.sfm.</tt><tt class="descname">ExponentialIsotropicFit</tt><big>(</big><em>model</em>, <em>params</em><big>)</big><a class="headerlink" href="#dipy.reconst.sfm.ExponentialIsotropicFit" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.sfm.IsotropicFit" title="dipy.reconst.sfm.IsotropicFit"><tt class="xref py py-class docutils literal"><span class="pre">dipy.reconst.sfm.IsotropicFit</span></tt></a></p>
<p>A fit to the ExponentialIsotropicModel object, based on data.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.sfm.ExponentialIsotropicFit.predict" title="dipy.reconst.sfm.ExponentialIsotropicFit.predict"><tt class="xref py py-obj docutils literal"><span class="pre">predict</span></tt></a>([gtab])</td>
<td>Predict the isotropic signal, based on a gradient table.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.sfm.ExponentialIsotropicFit.__init__">
<tt class="descname">__init__</tt><big>(</big><em>model</em>, <em>params</em><big>)</big><a class="headerlink" href="#dipy.reconst.sfm.ExponentialIsotropicFit.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize an IsotropicFit object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>model</strong> : IsotropicModel class instance</p>
<p><strong>params</strong> : ndarray</p>
<blockquote>
<div><p>The mean isotropic model parameters (the mean diffusion-weighted
signal in each voxel).</p>
</div></blockquote>
<p><strong>n_vox</strong> : int</p>
<blockquote class="last">
<div><p>The number of voxels for which the fit was done.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.sfm.ExponentialIsotropicFit.predict">
<tt class="descname">predict</tt><big>(</big><em>gtab=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.sfm.ExponentialIsotropicFit.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict the isotropic signal, based on a gradient table. In this case,
the prediction will be for an exponential decay with the mean
diffusivity derived from the data that was fit.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>gtab</strong> : a GradientTable class instance (optional)</p>
<blockquote class="last">
<div><p>Defaults to use the gtab from the IsotropicModel from which this
fit was derived.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="exponentialisotropicmodel">
<h3><a class="reference internal" href="#dipy.reconst.sfm.ExponentialIsotropicModel" title="dipy.reconst.sfm.ExponentialIsotropicModel"><tt class="xref py py-class docutils literal"><span class="pre">ExponentialIsotropicModel</span></tt></a><a class="headerlink" href="#exponentialisotropicmodel" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.sfm.ExponentialIsotropicModel">
<em class="property">class </em><tt class="descclassname">dipy.reconst.sfm.</tt><tt class="descname">ExponentialIsotropicModel</tt><big>(</big><em>gtab</em><big>)</big><a class="headerlink" href="#dipy.reconst.sfm.ExponentialIsotropicModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.sfm.IsotropicModel" title="dipy.reconst.sfm.IsotropicModel"><tt class="xref py py-class docutils literal"><span class="pre">dipy.reconst.sfm.IsotropicModel</span></tt></a></p>
<p>Representing the isotropic signal as a fit to an exponential decay function
with b-values</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.sfm.ExponentialIsotropicModel.fit" title="dipy.reconst.sfm.ExponentialIsotropicModel.fit"><tt class="xref py py-obj docutils literal"><span class="pre">fit</span></tt></a>(data)</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.sfm.ExponentialIsotropicModel.__init__">
<tt class="descname">__init__</tt><big>(</big><em>gtab</em><big>)</big><a class="headerlink" href="#dipy.reconst.sfm.ExponentialIsotropicModel.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize an IsotropicModel</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>gtab</strong> : a GradientTable class instance</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.sfm.ExponentialIsotropicModel.fit">
<tt class="descname">fit</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#dipy.reconst.sfm.ExponentialIsotropicModel.fit" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> : ndarray</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>ExponentialIsotropicFit class instance.</strong> :</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="isotropicfit">
<h3><a class="reference internal" href="#dipy.reconst.sfm.IsotropicFit" title="dipy.reconst.sfm.IsotropicFit"><tt class="xref py py-class docutils literal"><span class="pre">IsotropicFit</span></tt></a><a class="headerlink" href="#isotropicfit" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.sfm.IsotropicFit">
<em class="property">class </em><tt class="descclassname">dipy.reconst.sfm.</tt><tt class="descname">IsotropicFit</tt><big>(</big><em>model</em>, <em>params</em><big>)</big><a class="headerlink" href="#dipy.reconst.sfm.IsotropicFit" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstFit" title="dipy.reconst.base.ReconstFit"><tt class="xref py py-class docutils literal"><span class="pre">dipy.reconst.base.ReconstFit</span></tt></a></p>
<p>A fit object for representing the isotropic signal as the mean of the
diffusion-weighted signal</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.sfm.IsotropicFit.predict" title="dipy.reconst.sfm.IsotropicFit.predict"><tt class="xref py py-obj docutils literal"><span class="pre">predict</span></tt></a>([gtab])</td>
<td>Predict the isotropic signal, based on a gradient table.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.sfm.IsotropicFit.__init__">
<tt class="descname">__init__</tt><big>(</big><em>model</em>, <em>params</em><big>)</big><a class="headerlink" href="#dipy.reconst.sfm.IsotropicFit.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize an IsotropicFit object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>model</strong> : IsotropicModel class instance</p>
<p><strong>params</strong> : ndarray</p>
<blockquote>
<div><p>The mean isotropic model parameters (the mean diffusion-weighted
signal in each voxel).</p>
</div></blockquote>
<p><strong>n_vox</strong> : int</p>
<blockquote class="last">
<div><p>The number of voxels for which the fit was done.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.sfm.IsotropicFit.predict">
<tt class="descname">predict</tt><big>(</big><em>gtab=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.sfm.IsotropicFit.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict the isotropic signal, based on a gradient table. In this case,
the (naive!) prediction will be the mean of the diffusion-weighted
signal in the voxels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>gtab</strong> : a GradientTable class instance (optional)</p>
<blockquote class="last">
<div><p>Defaults to use the gtab from the IsotropicModel from which this
fit was derived.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="isotropicmodel">
<h3><a class="reference internal" href="#dipy.reconst.sfm.IsotropicModel" title="dipy.reconst.sfm.IsotropicModel"><tt class="xref py py-class docutils literal"><span class="pre">IsotropicModel</span></tt></a><a class="headerlink" href="#isotropicmodel" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.sfm.IsotropicModel">
<em class="property">class </em><tt class="descclassname">dipy.reconst.sfm.</tt><tt class="descname">IsotropicModel</tt><big>(</big><em>gtab</em><big>)</big><a class="headerlink" href="#dipy.reconst.sfm.IsotropicModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><tt class="xref py py-class docutils literal"><span class="pre">dipy.reconst.base.ReconstModel</span></tt></a></p>
<p>A base-class for the representation of isotropic signals.</p>
<p>The default behavior, suitable for single b-value data is to calculate the
mean in each voxel as an estimate of the signal that does not depend on
direction.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.sfm.IsotropicModel.fit" title="dipy.reconst.sfm.IsotropicModel.fit"><tt class="xref py py-obj docutils literal"><span class="pre">fit</span></tt></a>(data)</td>
<td>Fit an IsotropicModel.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.sfm.IsotropicModel.__init__">
<tt class="descname">__init__</tt><big>(</big><em>gtab</em><big>)</big><a class="headerlink" href="#dipy.reconst.sfm.IsotropicModel.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize an IsotropicModel</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>gtab</strong> : a GradientTable class instance</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.sfm.IsotropicModel.fit">
<tt class="descname">fit</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#dipy.reconst.sfm.IsotropicModel.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit an IsotropicModel. This boils down to finding the mean
diffusion-weighted signal in each voxel</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> : ndarray</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>IsotropicFit class instance.</strong> :</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id200">
<h3><a class="reference internal" href="#dipy.reconst.sfm.ReconstFit" title="dipy.reconst.sfm.ReconstFit"><tt class="xref py py-class docutils literal"><span class="pre">ReconstFit</span></tt></a><a class="headerlink" href="#id200" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.sfm.ReconstFit">
<em class="property">class </em><tt class="descclassname">dipy.reconst.sfm.</tt><tt class="descname">ReconstFit</tt><big>(</big><em>model</em>, <em>data</em><big>)</big><a class="headerlink" href="#dipy.reconst.sfm.ReconstFit" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></a></p>
<p>Abstract class which holds the fit result of ReconstModel</p>
<p>For example that could be holding FA or GFA etc.</p>
<dl class="method">
<dt id="dipy.reconst.sfm.ReconstFit.__init__">
<tt class="descname">__init__</tt><big>(</big><em>model</em>, <em>data</em><big>)</big><a class="headerlink" href="#dipy.reconst.sfm.ReconstFit.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="id201">
<h3><a class="reference internal" href="#dipy.reconst.sfm.ReconstModel" title="dipy.reconst.sfm.ReconstModel"><tt class="xref py py-class docutils literal"><span class="pre">ReconstModel</span></tt></a><a class="headerlink" href="#id201" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.sfm.ReconstModel">
<em class="property">class </em><tt class="descclassname">dipy.reconst.sfm.</tt><tt class="descname">ReconstModel</tt><big>(</big><em>gtab</em><big>)</big><a class="headerlink" href="#dipy.reconst.sfm.ReconstModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></a></p>
<p>Abstract class for signal reconstruction models</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.sfm.ReconstModel.fit" title="dipy.reconst.sfm.ReconstModel.fit"><tt class="xref py py-obj docutils literal"><span class="pre">fit</span></tt></a>(data[,&nbsp;mask])</td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.sfm.ReconstModel.__init__">
<tt class="descname">__init__</tt><big>(</big><em>gtab</em><big>)</big><a class="headerlink" href="#dipy.reconst.sfm.ReconstModel.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialization of the abstract class for signal reconstruction models</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>gtab</strong> : GradientTable class instance</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.sfm.ReconstModel.fit">
<tt class="descname">fit</tt><big>(</big><em>data</em>, <em>mask=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#dipy.reconst.sfm.ReconstModel.fit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="sparsefasciclefit">
<h3><a class="reference internal" href="#dipy.reconst.sfm.SparseFascicleFit" title="dipy.reconst.sfm.SparseFascicleFit"><tt class="xref py py-class docutils literal"><span class="pre">SparseFascicleFit</span></tt></a><a class="headerlink" href="#sparsefasciclefit" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.sfm.SparseFascicleFit">
<em class="property">class </em><tt class="descclassname">dipy.reconst.sfm.</tt><tt class="descname">SparseFascicleFit</tt><big>(</big><em>model</em>, <em>beta</em>, <em>S0</em>, <em>iso</em><big>)</big><a class="headerlink" href="#dipy.reconst.sfm.SparseFascicleFit" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstFit" title="dipy.reconst.base.ReconstFit"><tt class="xref py py-class docutils literal"><span class="pre">dipy.reconst.base.ReconstFit</span></tt></a></p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.sfm.SparseFascicleFit.odf" title="dipy.reconst.sfm.SparseFascicleFit.odf"><tt class="xref py py-obj docutils literal"><span class="pre">odf</span></tt></a>(sphere)</td>
<td>The orientation distribution function of the SFM</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.sfm.SparseFascicleFit.predict" title="dipy.reconst.sfm.SparseFascicleFit.predict"><tt class="xref py py-obj docutils literal"><span class="pre">predict</span></tt></a>([gtab,&nbsp;response,&nbsp;S0])</td>
<td>Predict the signal based on the SFM parameters</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.sfm.SparseFascicleFit.__init__">
<tt class="descname">__init__</tt><big>(</big><em>model</em>, <em>beta</em>, <em>S0</em>, <em>iso</em><big>)</big><a class="headerlink" href="#dipy.reconst.sfm.SparseFascicleFit.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initalize a SparseFascicleFit class instance</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>model</strong> : a SparseFascicleModel object.</p>
<p><strong>beta</strong> : ndarray</p>
<blockquote>
<div><p>The parameters of fit to data.</p>
</div></blockquote>
<p><strong>S0</strong> : ndarray</p>
<blockquote>
<div><p>The mean non-diffusion-weighted signal.</p>
</div></blockquote>
<p><strong>iso</strong> : IsotropicFit class instance</p>
<blockquote class="last">
<div><p>A representation of the isotropic signal, together with parameters
of the isotropic signal in each voxel, that is capable of
deriving/predicting an isotropic signal, based on a gradient-table.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.sfm.SparseFascicleFit.odf">
<tt class="descname">odf</tt><big>(</big><em>sphere</em><big>)</big><a class="headerlink" href="#dipy.reconst.sfm.SparseFascicleFit.odf" title="Permalink to this definition">¶</a></dt>
<dd><p>The orientation distribution function of the SFM</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sphere</strong> : Sphere</p>
<blockquote>
<div><p>The points in which the ODF is evaluated</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>odf</strong> :  ndarray of shape (x, y, z, sphere.vertices.shape[0])</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.sfm.SparseFascicleFit.predict">
<tt class="descname">predict</tt><big>(</big><em>gtab=None</em>, <em>response=None</em>, <em>S0=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.sfm.SparseFascicleFit.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict the signal based on the SFM parameters</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>gtab</strong> : GradientTable, optional</p>
<blockquote>
<div><p>The bvecs/bvals to predict the signal on. Default: the gtab from
the model object.</p>
</div></blockquote>
<p><strong>response</strong> : list of 3 elements, optional</p>
<blockquote>
<div><p>The eigenvalues of a tensor which will serve as a kernel
function. Default: the response of the model object. Default to use
<cite>model.response</cite>.</p>
</div></blockquote>
<p><strong>S0</strong> : float or array, optional</p>
<blockquote>
<div><p>The non-diffusion-weighted signal. Default: use the S0 of the data</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>pred_sig</strong> : ndarray</p>
<blockquote class="last">
<div><p>The signal predicted in each voxel/direction</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="sparsefasciclemodel">
<h3><a class="reference internal" href="#dipy.reconst.sfm.SparseFascicleModel" title="dipy.reconst.sfm.SparseFascicleModel"><tt class="xref py py-class docutils literal"><span class="pre">SparseFascicleModel</span></tt></a><a class="headerlink" href="#sparsefasciclemodel" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.sfm.SparseFascicleModel">
<em class="property">class </em><tt class="descclassname">dipy.reconst.sfm.</tt><tt class="descname">SparseFascicleModel</tt><big>(</big><em>gtab, sphere=None, response=[0.0015, 0.0005, 0.0005], solver='ElasticNet', l1_ratio=0.5, alpha=0.001, isotropic=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.sfm.SparseFascicleModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><tt class="xref py py-class docutils literal"><span class="pre">dipy.reconst.base.ReconstModel</span></tt></a>, <a class="reference internal" href="#dipy.reconst.cache.Cache" title="dipy.reconst.cache.Cache"><tt class="xref py py-class docutils literal"><span class="pre">dipy.reconst.cache.Cache</span></tt></a></p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">cache_clear</span></tt>()</td>
<td>Clear the cache.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">cache_get</span></tt>(tag,&nbsp;key[,&nbsp;default])</td>
<td>Retrieve a value from the cache.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">cache_set</span></tt>(tag,&nbsp;key,&nbsp;value)</td>
<td>Store a value in the cache.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.sfm.SparseFascicleModel.design_matrix" title="dipy.reconst.sfm.SparseFascicleModel.design_matrix"><tt class="xref py py-obj docutils literal"><span class="pre">design_matrix</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.sfm.SparseFascicleModel.fit" title="dipy.reconst.sfm.SparseFascicleModel.fit"><tt class="xref py py-obj docutils literal"><span class="pre">fit</span></tt></a>(data[,&nbsp;mask])</td>
<td>Fit the SparseFascicleModel object to data</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.sfm.SparseFascicleModel.__init__">
<tt class="descname">__init__</tt><big>(</big><em>gtab, sphere=None, response=[0.0015, 0.0005, 0.0005], solver='ElasticNet', l1_ratio=0.5, alpha=0.001, isotropic=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.sfm.SparseFascicleModel.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a Sparse Fascicle Model</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>gtab</strong> : GradientTable class instance</p>
<p><strong>sphere</strong> : Sphere class instance, optional</p>
<blockquote>
<div><p>A sphere on which coefficients will be estimated. Default:</p>
</div></blockquote>
<p><strong>symmetric sphere with 362 points (from :mod:`dipy.data`).</strong> :</p>
<p><strong>response</strong> : (3,) array-like, optional</p>
<blockquote>
<div><p>The eigenvalues of a canonical tensor to be used as the response
function of single-fascicle signals.
Default:[0.0015, 0.0005, 0.0005]</p>
</div></blockquote>
<p><strong>solver</strong> : string, dipy.core.optimize.SKLearnLinearSolver object, or sklearn.linear_model.base.LinearModel object, optional.</p>
<blockquote>
<div><p>This will determine the algorithm used to solve the set of linear
equations underlying this model. If it is a string it needs to be
one of the following: {&#8216;ElasticNet&#8217;, &#8216;NNLS&#8217;}. Otherwise, it can be
an object that inherits from <cite>dipy.optimize.SKLearnLinearSolver</cite>.
Default: &#8216;ElasticNet&#8217;.</p>
</div></blockquote>
<p><strong>l1_ratio</strong> : float, optional</p>
<blockquote>
<div><p>Sets the balance betwee L1 and L2 regularization in ElasticNet
<a class="reference internal" href="#zou2005" id="id202">[Zou2005]</a>. Default: 0.5</p>
</div></blockquote>
<p><strong>alpha</strong> : float, optional</p>
<blockquote>
<div><p>Sets the balance between least-squares error and L1/L2
regularization in ElasticNet <a class="reference internal" href="#zou2005" id="id203">[Zou2005]</a>. Default: 0.001</p>
</div></blockquote>
<p><strong>isotropic</strong> : IsotropicModel class instance</p>
<blockquote class="last">
<div><p>This is a class that implements the function that calculates the
value of the isotropic signal. This is a value of the signal that is
independent of direction, and therefore removed from both sides of
the SFM equation. The default is an instance of IsotropicModel, but
other functions can be inherited from IsotropicModel to implement
other fits to the aspects of the data that depend on b-value, but
not on direction.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This is an implementation of the SFM, described in <a class="reference internal" href="#rokem2014" id="id204">[Rokem2014]</a>.</p>
<table class="docutils citation" frame="void" id="rokem2014" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Rokem2014]</td><td><em>(<a class="fn-backref" href="#id204">1</a>, <a class="fn-backref" href="#id208">2</a>)</em> Ariel Rokem, Jason D. Yeatman, Franco Pestilli, Kendrick
N. Kay, Aviv Mezer, Stefan van der Walt, Brian A. Wandell
(2014). Evaluating the accuracy of diffusion MRI models in white
matter. <a class="reference external" href="http://arxiv.org/abs/1411.0721">http://arxiv.org/abs/1411.0721</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="zou2005" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Zou2005]</td><td><em>(<a class="fn-backref" href="#id202">1</a>, <a class="fn-backref" href="#id203">2</a>)</em> Zou H, Hastie T (2005). Regularization and variable
selection via the elastic net. J R Stat Soc B:301-320</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="dipy.reconst.sfm.SparseFascicleModel.design_matrix">
<em class="property">static </em><tt class="descname">design_matrix</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.sfm.SparseFascicleModel.design_matrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.reconst.sfm.SparseFascicleModel.fit">
<tt class="descname">fit</tt><big>(</big><em>data</em>, <em>mask=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.sfm.SparseFascicleModel.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit the SparseFascicleModel object to data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : array</p>
<blockquote>
<div><p>The measured signal.</p>
</div></blockquote>
<p><strong>mask</strong> : array, optional</p>
<blockquote>
<div><p>A boolean array used to mark the coordinates in the data that
should be analyzed. Has the shape <cite>data.shape[:-1]</cite>. Default: None,
which implies that all points should be analyzed.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>SparseFascicleFit object</strong> :</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id205">
<h3>auto_attr<a class="headerlink" href="#id205" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.sfm.auto_attr">
<tt class="descclassname">dipy.reconst.sfm.</tt><tt class="descname">auto_attr</tt><big>(</big><em>func</em><big>)</big><a class="headerlink" href="#dipy.reconst.sfm.auto_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator to create OneTimeProperty attributes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>func</strong> : method</p>
<blockquote class="last">
<div><p>The method that will be called the first time to compute a value.
Afterwards, the method&#8217;s name will be a standard attribute holding the
value of this computation.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MagicProp</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nd">@auto_attr</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">a</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">99</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">MagicProp</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s">&#39;a&#39;</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">__dict__</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">a</span>
<span class="go">99</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s">&#39;a&#39;</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">__dict__</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="nanmean">
<h3>nanmean<a class="headerlink" href="#nanmean" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.sfm.nanmean">
<tt class="descclassname">dipy.reconst.sfm.</tt><tt class="descname">nanmean</tt><big>(</big><em>a</em>, <em>axis=None</em>, <em>dtype=None</em>, <em>out=None</em>, <em>keepdims=False</em><big>)</big><a class="headerlink" href="#dipy.reconst.sfm.nanmean" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the arithmetic mean along the specified axis, ignoring NaNs.</p>
<p>Returns the average of the array elements.  The average is taken over
the flattened array by default, otherwise over the specified axis.
<cite>float64</cite> intermediate and return values are used for integer inputs.</p>
<p>For all-NaN slices, NaN is returned and a <cite>RuntimeWarning</cite> is raised.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.8.0.</span></p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a</strong> : array_like</p>
<blockquote>
<div><p>Array containing numbers whose mean is desired. If <cite>a</cite> is not an
array, a conversion is attempted.</p>
</div></blockquote>
<p><strong>axis</strong> : int, optional</p>
<blockquote>
<div><p>Axis along which the means are computed. The default is to compute
the mean of the flattened array.</p>
</div></blockquote>
<p><strong>dtype</strong> : data-type, optional</p>
<blockquote>
<div><p>Type to use in computing the mean.  For integer inputs, the default
is <cite>float64</cite>; for inexact inputs, it is the same as the input
dtype.</p>
</div></blockquote>
<p><strong>out</strong> : ndarray, optional</p>
<blockquote>
<div><p>Alternate output array in which to place the result.  The default
is <tt class="docutils literal"><span class="pre">None</span></tt>; if provided, it must have the same shape as the
expected output, but the type will be cast if necessary.  See
<cite>doc.ufuncs</cite> for details.</p>
</div></blockquote>
<p><strong>keepdims</strong> : bool, optional</p>
<blockquote>
<div><p>If this is set to True, the axes which are reduced are left in the
result as dimensions with size one. With this option, the result
will broadcast correctly against the original <cite>arr</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>m</strong> : ndarray, see dtype parameter above</p>
<blockquote class="last">
<div><p>If <cite>out=None</cite>, returns a new array containing the mean values,
otherwise a reference to the output array is returned. Nan is
returned for slices that contain only NaNs.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="docutils">
<dt><tt class="xref py py-obj docutils literal"><span class="pre">average</span></tt></dt>
<dd>Weighted average</dd>
<dt><tt class="xref py py-obj docutils literal"><span class="pre">mean</span></tt></dt>
<dd>Arithmetic mean taken while not ignoring NaNs</dd>
</dl>
<p class="last"><tt class="xref py py-obj docutils literal"><span class="pre">var</span></tt>, <tt class="xref py py-obj docutils literal"><span class="pre">nanvar</span></tt></p>
</div>
<p class="rubric">Notes</p>
<p>The arithmetic mean is the sum of the non-NaN elements along the axis
divided by the number of non-NaN elements.</p>
<p>Note that for floating-point input, the mean is computed using the same
precision the input has.  Depending on the input data, this can cause
the results to be inaccurate, especially for <cite>float32</cite>.  Specifying a
higher-precision accumulator using the <cite>dtype</cite> keyword can alleviate
this issue.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">2.6666666666666665</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ 2.,  4.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([ 1.,  3.5])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="optional-package">
<h3>optional_package<a class="headerlink" href="#optional-package" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.sfm.optional_package">
<tt class="descclassname">dipy.reconst.sfm.</tt><tt class="descname">optional_package</tt><big>(</big><em>name</em>, <em>trip_msg=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.sfm.optional_package" title="Permalink to this definition">¶</a></dt>
<dd><p>Return package-like thing and module setup for package <cite>name</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>name</strong> : str</p>
<blockquote>
<div><p>package name</p>
</div></blockquote>
<p><strong>trip_msg</strong> : None or str</p>
<blockquote>
<div><p>message to give when someone tries to use the return package, but we
could not import it, and have returned a TripWire object instead.
Default message if None.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>pkg_like</strong> : module or <tt class="docutils literal"><span class="pre">TripWire</span></tt> instance</p>
<blockquote>
<div><p>If we can import the package, return it.  Otherwise return an object
raising an error when accessed</p>
</div></blockquote>
<p><strong>have_pkg</strong> : bool</p>
<blockquote>
<div><p>True if import for package was successful, false otherwise</p>
</div></blockquote>
<p><strong>module_setup</strong> : function</p>
<blockquote class="last">
<div><p>callable usually set as <tt class="docutils literal"><span class="pre">setup_module</span></tt> in calling namespace, to allow
skipping tests.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="sfm-design-matrix">
<h3>sfm_design_matrix<a class="headerlink" href="#sfm-design-matrix" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.sfm.sfm_design_matrix">
<tt class="descclassname">dipy.reconst.sfm.</tt><tt class="descname">sfm_design_matrix</tt><big>(</big><em>gtab</em>, <em>sphere</em>, <em>response</em>, <em>mode='signal'</em><big>)</big><a class="headerlink" href="#dipy.reconst.sfm.sfm_design_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct the SFM design matrix</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>gtab</strong> : GradientTable or Sphere</p>
<blockquote>
<div><p>Sets the rows of the matrix, if the mode is &#8216;signal&#8217;, this should be a
GradientTable. If mode is &#8216;odf&#8217; this should be a Sphere</p>
</div></blockquote>
<p><strong>sphere</strong> : Sphere</p>
<blockquote>
<div><p>Sets the columns of the matrix</p>
</div></blockquote>
<p><strong>response</strong> : list of 3 elements</p>
<blockquote>
<div><p>The eigenvalues of a tensor which will serve as a kernel
function.</p>
</div></blockquote>
<p><strong>mode</strong> : str {&#8216;signal&#8217; | &#8216;odf&#8217;}, optional</p>
<blockquote>
<div><p>Choose the (default) &#8216;signal&#8217; for a design matrix containing predicted
signal in the measurements defined by the gradient table for putative
fascicles oriented along the vertices of the sphere. Otherwise, choose
&#8216;odf&#8217; for an odf convolution matrix, with values of the odf calculated
from a tensor with the provided response eigenvalues, evaluated at the
b-vectors in the gradient table, for the tensors with prinicipal
diffusion directions along the vertices of the sphere.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>mat</strong> : ndarray</p>
<blockquote class="last">
<div><p>A design matrix that can be used for one of the following operations:
when the &#8216;signal&#8217; mode is used, each column contains the putative
signal in each of the bvectors of the <cite>gtab</cite> if a fascicle is oriented
in the direction encoded by the sphere vertex corresponding to this
column. This is used for deconvolution with a measured DWI signal. If
the &#8216;odf&#8217; mode is chosen, each column instead contains the values of
the tensor ODF for a tensor with a principal diffusion direction
corresponding to this vertex. This is used to generate odfs from the
fits of the SFM for the purpose of tracking.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<table class="docutils citation" frame="void" id="id206" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Rokem2014a]</td><td>Ariel Rokem, Jason D. Yeatman, Franco Pestilli, Kendrick
N. Kay, Aviv Mezer, Stefan van der Walt, Brian A. Wandell
(2014). Evaluating the accuracy of diffusion MRI models in white
matter. <a class="reference external" href="http://arxiv.org/abs/1411.0721">http://arxiv.org/abs/1411.0721</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="id207" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Rokem2014b]</td><td>Ariel Rokem, Kimberly L. Chan, Jason D. Yeatman, Franco
Pestilli,  Brian A. Wandell (2014). Evaluating the accuracy of diffusion
models at multiple b-values with cross-validation. ISMRM 2014.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="behrens2007" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id209">[Behrens2007]</a></td><td>Behrens TEJ, Berg HJ, Jbabdi S, Rushworth MFS, Woolrich MW
(2007): Probabilistic diffusion tractography with multiple fibre
orientations: What can we gain? Neuroimage 34:144-55.</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dipy.data</span> <span class="kn">as</span> <span class="nn">dpd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">,</span> <span class="n">gtab</span> <span class="o">=</span> <span class="n">dpd</span><span class="o">.</span><span class="n">dsi_voxels</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere</span> <span class="o">=</span> <span class="n">dpd</span><span class="o">.</span><span class="n">get_sphere</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.reconst.sfm</span> <span class="kn">import</span> <span class="n">sfm_design_matrix</span>
</pre></div>
</div>
<p>A canonical tensor approximating corpus-callosum voxels <a class="reference internal" href="#rokem2014" id="id208">[Rokem2014]</a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">tensor_matrix</span> <span class="o">=</span> <span class="n">sfm_design_matrix</span><span class="p">(</span><span class="n">gtab</span><span class="p">,</span> <span class="n">sphere</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.0015</span><span class="p">,</span> <span class="mf">0.0005</span><span class="p">,</span> <span class="mf">0.0005</span><span class="p">])</span>
</pre></div>
</div>
<p>A &#8216;stick&#8217; function (<a class="reference internal" href="#behrens2007" id="id209">[Behrens2007]</a>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">stick_matrix</span> <span class="o">=</span> <span class="n">sfm_design_matrix</span><span class="p">(</span><span class="n">gtab</span><span class="p">,</span> <span class="n">sphere</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.001</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="id210">
<h3><a class="reference internal" href="#dipy.reconst.shm.Cache" title="dipy.reconst.shm.Cache"><tt class="xref py py-class docutils literal"><span class="pre">Cache</span></tt></a><a class="headerlink" href="#id210" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.shm.Cache">
<em class="property">class </em><tt class="descclassname">dipy.reconst.shm.</tt><tt class="descname">Cache</tt><a class="headerlink" href="#dipy.reconst.shm.Cache" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></a></p>
<p>Cache values based on a key object (such as a sphere or gradient table).</p>
<p class="rubric">Notes</p>
<p>This class is meant to be used as a mix-in:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MyModel</span><span class="p">(</span><span class="n">Model</span><span class="p">,</span> <span class="n">Cache</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">MyModelFit</span><span class="p">(</span><span class="n">Fit</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>Inside a method on the fit, typical usage would be:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">odf</span><span class="p">(</span><span class="n">sphere</span><span class="p">):</span>
    <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">cache_get</span><span class="p">(</span><span class="s">&#39;odf_basis_matrix&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sphere</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">M</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_basis_matrix</span><span class="p">(</span><span class="n">sphere</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">cache_set</span><span class="p">(</span><span class="s">&#39;odf_basis_matrix&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sphere</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">M</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.Cache.cache_clear" title="dipy.reconst.shm.Cache.cache_clear"><tt class="xref py py-obj docutils literal"><span class="pre">cache_clear</span></tt></a>()</td>
<td>Clear the cache.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.Cache.cache_get" title="dipy.reconst.shm.Cache.cache_get"><tt class="xref py py-obj docutils literal"><span class="pre">cache_get</span></tt></a>(tag,&nbsp;key[,&nbsp;default])</td>
<td>Retrieve a value from the cache.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.Cache.cache_set" title="dipy.reconst.shm.Cache.cache_set"><tt class="xref py py-obj docutils literal"><span class="pre">cache_set</span></tt></a>(tag,&nbsp;key,&nbsp;value)</td>
<td>Store a value in the cache.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.shm.Cache.__init__">
<tt class="descname">__init__</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.shm.Cache.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.shm.Cache.cache_clear">
<tt class="descname">cache_clear</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.shm.Cache.cache_clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear the cache.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.shm.Cache.cache_get">
<tt class="descname">cache_get</tt><big>(</big><em>tag</em>, <em>key</em>, <em>default=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.Cache.cache_get" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a value from the cache.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>tag</strong> : str</p>
<blockquote>
<div><p>Description of the cached value.</p>
</div></blockquote>
<p><strong>key</strong> : object</p>
<blockquote>
<div><p>Key object used to look up the cached value.</p>
</div></blockquote>
<p><strong>default</strong> : object</p>
<blockquote>
<div><p>Value to be returned if no cached entry is found.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>v</strong> : object</p>
<blockquote class="last">
<div><p>Value from the cache associated with <tt class="docutils literal"><span class="pre">(tag,</span> <span class="pre">key)</span></tt>.  Returns
<cite>default</cite> if no cached entry is found.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.shm.Cache.cache_set">
<tt class="descname">cache_set</tt><big>(</big><em>tag</em>, <em>key</em>, <em>value</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.Cache.cache_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Store a value in the cache.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>tag</strong> : str</p>
<blockquote>
<div><p>Description of the cached value.</p>
</div></blockquote>
<p><strong>key</strong> : object</p>
<blockquote>
<div><p>Key object used to look up the cached value.</p>
</div></blockquote>
<p><strong>value</strong> : object</p>
<blockquote class="last">
<div><p>Value stored in the cache for each unique combination
of <tt class="docutils literal"><span class="pre">(tag,</span> <span class="pre">key)</span></tt>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">compute_expensive_matrix</span><span class="p">(</span><span class="n">parameters</span><span class="p">):</span>
<span class="gp">... </span>    <span class="c"># Imagine the following computation is very expensive</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Cache</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">parameters</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X1</span> <span class="o">=</span> <span class="n">compute_expensive_matrix</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">cache_set</span><span class="p">(</span><span class="s">&#39;expensive_matrix&#39;</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">X1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X2</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">cache_get</span><span class="p">(</span><span class="s">&#39;expensive_matrix&#39;</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">X1</span> <span class="ow">is</span> <span class="n">X2</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="csaodfmodel">
<h3><a class="reference internal" href="#dipy.reconst.shm.CsaOdfModel" title="dipy.reconst.shm.CsaOdfModel"><tt class="xref py py-class docutils literal"><span class="pre">CsaOdfModel</span></tt></a><a class="headerlink" href="#csaodfmodel" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.shm.CsaOdfModel">
<em class="property">class </em><tt class="descclassname">dipy.reconst.shm.</tt><tt class="descname">CsaOdfModel</tt><big>(</big><em>gtab</em>, <em>sh_order</em>, <em>smooth=0.006</em>, <em>min_signal=1.0</em>, <em>assume_normed=False</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.CsaOdfModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.shm.QballBaseModel" title="dipy.reconst.shm.QballBaseModel"><tt class="xref py py-class docutils literal"><span class="pre">dipy.reconst.shm.QballBaseModel</span></tt></a></p>
<p>Implementation of Constant Solid Angle reconstruction method.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r132" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id211">[R132]</a></td><td>Aganj, I., et. al. 2009. ODF Reconstruction in Q-Ball Imaging With
Solid Angle Consideration.</td></tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">cache_clear</span></tt>()</td>
<td>Clear the cache.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">cache_get</span></tt>(tag,&nbsp;key[,&nbsp;default])</td>
<td>Retrieve a value from the cache.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">cache_set</span></tt>(tag,&nbsp;key,&nbsp;value)</td>
<td>Store a value in the cache.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">fit</span></tt>(data[,&nbsp;mask])</td>
<td>Fits the model to diffusion data and returns the model fit</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">sampling_matrix</span></tt>(sphere)</td>
<td>The matrix needed to sample ODFs from coefficients of the model.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.shm.CsaOdfModel.__init__">
<tt class="descname">__init__</tt><big>(</big><em>gtab</em>, <em>sh_order</em>, <em>smooth=0.006</em>, <em>min_signal=1.0</em>, <em>assume_normed=False</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.CsaOdfModel.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a model that can be used to fit or sample diffusion data</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#dipy.reconst.shm.normalize_data" title="dipy.reconst.shm.normalize_data"><tt class="xref py py-obj docutils literal"><span class="pre">normalize_data</span></tt></a></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.shm.CsaOdfModel.max">
<tt class="descname">max</tt><em class="property"> = 0.999</em><a class="headerlink" href="#dipy.reconst.shm.CsaOdfModel.max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.shm.CsaOdfModel.min">
<tt class="descname">min</tt><em class="property"> = 0.001</em><a class="headerlink" href="#dipy.reconst.shm.CsaOdfModel.min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="looseversion">
<h3><a class="reference internal" href="#dipy.reconst.shm.LooseVersion" title="dipy.reconst.shm.LooseVersion"><tt class="xref py py-class docutils literal"><span class="pre">LooseVersion</span></tt></a><a class="headerlink" href="#looseversion" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.shm.LooseVersion">
<em class="property">class </em><tt class="descclassname">dipy.reconst.shm.</tt><tt class="descname">LooseVersion</tt><big>(</big><em>vstring=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.LooseVersion" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">distutils.version.Version</span></tt></p>
<p>Version numbering for anarchists and software realists.
Implements the standard interface for version number classes as
described above.  A version number consists of a series of numbers,
separated by either periods or strings of letters.  When comparing
version numbers, the numeric components will be compared
numerically, and the alphabetic components lexically.  The following
are all valid version numbers, in no particular order:</p>
<blockquote>
<div>1.5.1
1.5.2b2
161
3.10a
8.02
3.4j
1996.07.12
3.2.pl0
3.1.1.6
2g6
11g
0.960923
2.2beta29
1.13++
5.5.kw
2.0b1pl0</div></blockquote>
<p>In fact, there is no such thing as an invalid version number under
this scheme; the rules for comparison are simple and predictable,
but may not always give the results you want (for some definition
of &#8220;want&#8221;).</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.LooseVersion.parse" title="dipy.reconst.shm.LooseVersion.parse"><tt class="xref py py-obj docutils literal"><span class="pre">parse</span></tt></a>(vstring)</td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.shm.LooseVersion.__init__">
<tt class="descname">__init__</tt><big>(</big><em>vstring=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.LooseVersion.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.shm.LooseVersion.component_re">
<tt class="descname">component_re</tt><em class="property"> = &lt;_sre.SRE_Pattern object at 0x2abac2103138&gt;</em><a class="headerlink" href="#dipy.reconst.shm.LooseVersion.component_re" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.reconst.shm.LooseVersion.parse">
<tt class="descname">parse</tt><big>(</big><em>vstring</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.LooseVersion.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="id212">
<h3><a class="reference internal" href="#dipy.reconst.shm.OdfFit" title="dipy.reconst.shm.OdfFit"><tt class="xref py py-class docutils literal"><span class="pre">OdfFit</span></tt></a><a class="headerlink" href="#id212" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.shm.OdfFit">
<em class="property">class </em><tt class="descclassname">dipy.reconst.shm.</tt><tt class="descname">OdfFit</tt><big>(</big><em>model</em>, <em>data</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.OdfFit" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstFit" title="dipy.reconst.base.ReconstFit"><tt class="xref py py-class docutils literal"><span class="pre">dipy.reconst.base.ReconstFit</span></tt></a></p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.OdfFit.odf" title="dipy.reconst.shm.OdfFit.odf"><tt class="xref py py-obj docutils literal"><span class="pre">odf</span></tt></a>(sphere)</td>
<td>To be implemented but specific odf models</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.shm.OdfFit.__init__">
<tt class="descname">__init__</tt><big>(</big><em>model</em>, <em>data</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.OdfFit.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.reconst.shm.OdfFit.odf">
<tt class="descname">odf</tt><big>(</big><em>sphere</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.OdfFit.odf" title="Permalink to this definition">¶</a></dt>
<dd><p>To be implemented but specific odf models</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id213">
<h3><a class="reference internal" href="#dipy.reconst.shm.OdfModel" title="dipy.reconst.shm.OdfModel"><tt class="xref py py-class docutils literal"><span class="pre">OdfModel</span></tt></a><a class="headerlink" href="#id213" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.shm.OdfModel">
<em class="property">class </em><tt class="descclassname">dipy.reconst.shm.</tt><tt class="descname">OdfModel</tt><big>(</big><em>gtab</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.OdfModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><tt class="xref py py-class docutils literal"><span class="pre">dipy.reconst.base.ReconstModel</span></tt></a></p>
<p>An abstract class to be sub-classed by specific odf models</p>
<p>All odf models should provide a fit method which may take data as it&#8217;s
first and only argument.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.OdfModel.fit" title="dipy.reconst.shm.OdfModel.fit"><tt class="xref py py-obj docutils literal"><span class="pre">fit</span></tt></a>(data)</td>
<td>To be implemented by specific odf models</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.shm.OdfModel.__init__">
<tt class="descname">__init__</tt><big>(</big><em>gtab</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.OdfModel.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.reconst.shm.OdfModel.fit">
<tt class="descname">fit</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.OdfModel.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>To be implemented by specific odf models</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="opdtmodel">
<h3><a class="reference internal" href="#dipy.reconst.shm.OpdtModel" title="dipy.reconst.shm.OpdtModel"><tt class="xref py py-class docutils literal"><span class="pre">OpdtModel</span></tt></a><a class="headerlink" href="#opdtmodel" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.shm.OpdtModel">
<em class="property">class </em><tt class="descclassname">dipy.reconst.shm.</tt><tt class="descname">OpdtModel</tt><big>(</big><em>gtab</em>, <em>sh_order</em>, <em>smooth=0.006</em>, <em>min_signal=1.0</em>, <em>assume_normed=False</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.OpdtModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.shm.QballBaseModel" title="dipy.reconst.shm.QballBaseModel"><tt class="xref py py-class docutils literal"><span class="pre">dipy.reconst.shm.QballBaseModel</span></tt></a></p>
<p>Implementation of Orientation Probability Density Transform
reconstruction method.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r133" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id214">[R133]</a></td><td>Tristan-Vega, A., et. al. 2010. A new methodology for estimation of
fiber populations in white matter of the brain with Funk-Radon
transform.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r134" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id215">[R134]</a></td><td>Tristan-Vega, A., et. al. 2009. Estimation of fiber orientation
probability density functions in high angular resolution diffusion
imaging.</td></tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">cache_clear</span></tt>()</td>
<td>Clear the cache.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">cache_get</span></tt>(tag,&nbsp;key[,&nbsp;default])</td>
<td>Retrieve a value from the cache.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">cache_set</span></tt>(tag,&nbsp;key,&nbsp;value)</td>
<td>Store a value in the cache.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">fit</span></tt>(data[,&nbsp;mask])</td>
<td>Fits the model to diffusion data and returns the model fit</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">sampling_matrix</span></tt>(sphere)</td>
<td>The matrix needed to sample ODFs from coefficients of the model.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.shm.OpdtModel.__init__">
<tt class="descname">__init__</tt><big>(</big><em>gtab</em>, <em>sh_order</em>, <em>smooth=0.006</em>, <em>min_signal=1.0</em>, <em>assume_normed=False</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.OpdtModel.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a model that can be used to fit or sample diffusion data</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#dipy.reconst.shm.normalize_data" title="dipy.reconst.shm.normalize_data"><tt class="xref py py-obj docutils literal"><span class="pre">normalize_data</span></tt></a></p>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="qballbasemodel">
<h3><a class="reference internal" href="#dipy.reconst.shm.QballBaseModel" title="dipy.reconst.shm.QballBaseModel"><tt class="xref py py-class docutils literal"><span class="pre">QballBaseModel</span></tt></a><a class="headerlink" href="#qballbasemodel" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.shm.QballBaseModel">
<em class="property">class </em><tt class="descclassname">dipy.reconst.shm.</tt><tt class="descname">QballBaseModel</tt><big>(</big><em>gtab</em>, <em>sh_order</em>, <em>smooth=0.006</em>, <em>min_signal=1.0</em>, <em>assume_normed=False</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.QballBaseModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.shm.SphHarmModel" title="dipy.reconst.shm.SphHarmModel"><tt class="xref py py-class docutils literal"><span class="pre">dipy.reconst.shm.SphHarmModel</span></tt></a></p>
<p>To be subclassed by Qball type models.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">cache_clear</span></tt>()</td>
<td>Clear the cache.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">cache_get</span></tt>(tag,&nbsp;key[,&nbsp;default])</td>
<td>Retrieve a value from the cache.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">cache_set</span></tt>(tag,&nbsp;key,&nbsp;value)</td>
<td>Store a value in the cache.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.QballBaseModel.fit" title="dipy.reconst.shm.QballBaseModel.fit"><tt class="xref py py-obj docutils literal"><span class="pre">fit</span></tt></a>(data[,&nbsp;mask])</td>
<td>Fits the model to diffusion data and returns the model fit</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">sampling_matrix</span></tt>(sphere)</td>
<td>The matrix needed to sample ODFs from coefficients of the model.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.shm.QballBaseModel.__init__">
<tt class="descname">__init__</tt><big>(</big><em>gtab</em>, <em>sh_order</em>, <em>smooth=0.006</em>, <em>min_signal=1.0</em>, <em>assume_normed=False</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.QballBaseModel.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a model that can be used to fit or sample diffusion data</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#dipy.reconst.shm.normalize_data" title="dipy.reconst.shm.normalize_data"><tt class="xref py py-obj docutils literal"><span class="pre">normalize_data</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.shm.QballBaseModel.fit">
<tt class="descname">fit</tt><big>(</big><em>data</em>, <em>mask=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.QballBaseModel.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fits the model to diffusion data and returns the model fit</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="qballmodel">
<h3><a class="reference internal" href="#dipy.reconst.shm.QballModel" title="dipy.reconst.shm.QballModel"><tt class="xref py py-class docutils literal"><span class="pre">QballModel</span></tt></a><a class="headerlink" href="#qballmodel" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.shm.QballModel">
<em class="property">class </em><tt class="descclassname">dipy.reconst.shm.</tt><tt class="descname">QballModel</tt><big>(</big><em>gtab</em>, <em>sh_order</em>, <em>smooth=0.006</em>, <em>min_signal=1.0</em>, <em>assume_normed=False</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.QballModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.shm.QballBaseModel" title="dipy.reconst.shm.QballBaseModel"><tt class="xref py py-class docutils literal"><span class="pre">dipy.reconst.shm.QballBaseModel</span></tt></a></p>
<p>Implementation of regularized Qball reconstruction method.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r135" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id216">[R135]</a></td><td>Descoteaux, M., et. al. 2007. Regularized, fast, and robust
analytical Q-ball imaging.</td></tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">cache_clear</span></tt>()</td>
<td>Clear the cache.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">cache_get</span></tt>(tag,&nbsp;key[,&nbsp;default])</td>
<td>Retrieve a value from the cache.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">cache_set</span></tt>(tag,&nbsp;key,&nbsp;value)</td>
<td>Store a value in the cache.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">fit</span></tt>(data[,&nbsp;mask])</td>
<td>Fits the model to diffusion data and returns the model fit</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">sampling_matrix</span></tt>(sphere)</td>
<td>The matrix needed to sample ODFs from coefficients of the model.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.shm.QballModel.__init__">
<tt class="descname">__init__</tt><big>(</big><em>gtab</em>, <em>sh_order</em>, <em>smooth=0.006</em>, <em>min_signal=1.0</em>, <em>assume_normed=False</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.QballModel.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a model that can be used to fit or sample diffusion data</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#dipy.reconst.shm.normalize_data" title="dipy.reconst.shm.normalize_data"><tt class="xref py py-obj docutils literal"><span class="pre">normalize_data</span></tt></a></p>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="residualbootstrapwrapper">
<h3><a class="reference internal" href="#dipy.reconst.shm.ResidualBootstrapWrapper" title="dipy.reconst.shm.ResidualBootstrapWrapper"><tt class="xref py py-class docutils literal"><span class="pre">ResidualBootstrapWrapper</span></tt></a><a class="headerlink" href="#residualbootstrapwrapper" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.shm.ResidualBootstrapWrapper">
<em class="property">class </em><tt class="descclassname">dipy.reconst.shm.</tt><tt class="descname">ResidualBootstrapWrapper</tt><big>(</big><em>signal_object</em>, <em>B</em>, <em>where_dwi</em>, <em>min_signal=1.0</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.ResidualBootstrapWrapper" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></a></p>
<p>Returns a residual bootstrap sample of the signal_object when indexed</p>
<p>Wraps a signal_object, this signal object can be an interpolator. When
indexed, the the wrapper indexes the signal_object to get the signal.
There wrapper than samples the residual boostrap distribution of signal and
returns that sample.</p>
<dl class="method">
<dt id="dipy.reconst.shm.ResidualBootstrapWrapper.__init__">
<tt class="descname">__init__</tt><big>(</big><em>signal_object</em>, <em>B</em>, <em>where_dwi</em>, <em>min_signal=1.0</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.ResidualBootstrapWrapper.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds a ResidualBootstrapWapper</p>
<p>Given some linear model described by B, the design matrix, and a
signal_object, returns an object which can sample the residual
bootstrap distribution of the signal. We assume that the signals are
normalized so we clip the bootsrap samples to be between <cite>min_signal</cite>
and 1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>signal_object</strong> : some object that can be indexed</p>
<blockquote>
<div><p>This object should return diffusion weighted signals when indexed.</p>
</div></blockquote>
<p><strong>B</strong> : ndarray, ndim=2</p>
<blockquote>
<div><p>The design matrix of the spherical harmonics model used to fit the
data. This is the model that will be used to compute the residuals
and sample the residual bootstrap distribution</p>
</div></blockquote>
<p><strong>where_dwi :</strong> :</p>
<blockquote>
<div><p>indexing object to find diffusion weighted signals from signal</p>
</div></blockquote>
<p><strong>min_signal</strong> : float</p>
<blockquote class="last">
<div><p>The lowest allowable signal.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id217">
<h3><a class="reference internal" href="#dipy.reconst.shm.SphHarmFit" title="dipy.reconst.shm.SphHarmFit"><tt class="xref py py-class docutils literal"><span class="pre">SphHarmFit</span></tt></a><a class="headerlink" href="#id217" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.shm.SphHarmFit">
<em class="property">class </em><tt class="descclassname">dipy.reconst.shm.</tt><tt class="descname">SphHarmFit</tt><big>(</big><em>model</em>, <em>shm_coef</em>, <em>mask</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.SphHarmFit" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.odf.OdfFit" title="dipy.reconst.odf.OdfFit"><tt class="xref py py-class docutils literal"><span class="pre">dipy.reconst.odf.OdfFit</span></tt></a></p>
<p>Diffusion data fit to a spherical harmonic model</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.SphHarmFit.gfa" title="dipy.reconst.shm.SphHarmFit.gfa"><tt class="xref py py-obj docutils literal"><span class="pre">gfa</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.SphHarmFit.odf" title="dipy.reconst.shm.SphHarmFit.odf"><tt class="xref py py-obj docutils literal"><span class="pre">odf</span></tt></a>(sphere)</td>
<td>Samples the odf function on the points of a sphere</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.SphHarmFit.predict" title="dipy.reconst.shm.SphHarmFit.predict"><tt class="xref py py-obj docutils literal"><span class="pre">predict</span></tt></a>([gtab,&nbsp;S0])</td>
<td>Predict the diffusion signal from the model coefficients.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.shm.SphHarmFit.__init__">
<tt class="descname">__init__</tt><big>(</big><em>model</em>, <em>shm_coef</em>, <em>mask</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.SphHarmFit.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="dipy.reconst.shm.SphHarmFit.gfa">
<em class="property">static </em><tt class="descname">gfa</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.shm.SphHarmFit.gfa" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.reconst.shm.SphHarmFit.odf">
<tt class="descname">odf</tt><big>(</big><em>sphere</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.SphHarmFit.odf" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples the odf function on the points of a sphere</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sphere</strong> : Sphere</p>
<blockquote>
<div><p>The points on which to sample the odf.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>values</strong> : ndarray</p>
<blockquote class="last">
<div><p>The value of the odf on each point of <cite>sphere</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.shm.SphHarmFit.predict">
<tt class="descname">predict</tt><big>(</big><em>gtab=None</em>, <em>S0=1.0</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.SphHarmFit.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict the diffusion signal from the model coefficients.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>gtab</strong> : a GradientTable class instance</p>
<blockquote>
<div><p>The directions and bvalues on which prediction is desired</p>
</div></blockquote>
<p><strong>S0</strong> : float array</p>
<blockquote class="last">
<div><p>The mean non-diffusion-weighted signal in each voxel.
Default: 1.0 in all voxels</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.shm.SphHarmFit.shape">
<tt class="descname">shape</tt><a class="headerlink" href="#dipy.reconst.shm.SphHarmFit.shape" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.shm.SphHarmFit.shm_coeff">
<tt class="descname">shm_coeff</tt><a class="headerlink" href="#dipy.reconst.shm.SphHarmFit.shm_coeff" title="Permalink to this definition">¶</a></dt>
<dd><p>The spherical harmonic coefficients of the odf</p>
<p>Make this a property for now, if there is a usecase for modifying
the coefficients we can add a setter or expose the coefficients more
directly</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id218">
<h3><a class="reference internal" href="#dipy.reconst.shm.SphHarmModel" title="dipy.reconst.shm.SphHarmModel"><tt class="xref py py-class docutils literal"><span class="pre">SphHarmModel</span></tt></a><a class="headerlink" href="#id218" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.shm.SphHarmModel">
<em class="property">class </em><tt class="descclassname">dipy.reconst.shm.</tt><tt class="descname">SphHarmModel</tt><big>(</big><em>gtab</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.SphHarmModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.odf.OdfModel" title="dipy.reconst.odf.OdfModel"><tt class="xref py py-class docutils literal"><span class="pre">dipy.reconst.odf.OdfModel</span></tt></a>, <a class="reference internal" href="#dipy.reconst.cache.Cache" title="dipy.reconst.cache.Cache"><tt class="xref py py-class docutils literal"><span class="pre">dipy.reconst.cache.Cache</span></tt></a></p>
<p>To be subclassed by all models that return a SphHarmFit when fit.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">cache_clear</span></tt>()</td>
<td>Clear the cache.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">cache_get</span></tt>(tag,&nbsp;key[,&nbsp;default])</td>
<td>Retrieve a value from the cache.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">cache_set</span></tt>(tag,&nbsp;key,&nbsp;value)</td>
<td>Store a value in the cache.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">fit</span></tt>(data)</td>
<td>To be implemented by specific odf models</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.SphHarmModel.sampling_matrix" title="dipy.reconst.shm.SphHarmModel.sampling_matrix"><tt class="xref py py-obj docutils literal"><span class="pre">sampling_matrix</span></tt></a>(sphere)</td>
<td>The matrix needed to sample ODFs from coefficients of the model.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.shm.SphHarmModel.__init__">
<tt class="descname">__init__</tt><big>(</big><em>gtab</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.SphHarmModel.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.reconst.shm.SphHarmModel.sampling_matrix">
<tt class="descname">sampling_matrix</tt><big>(</big><em>sphere</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.SphHarmModel.sampling_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>The matrix needed to sample ODFs from coefficients of the model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sphere</strong> : Sphere</p>
<blockquote>
<div><p>Points used to sample ODF.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>sampling_matrix</strong> : array</p>
<blockquote class="last">
<div><p>The size of the matrix will be (N, M) where N is the number of
vertices on sphere and M is the number of coefficients needed by
the model.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id219">
<h3><a class="reference internal" href="#dipy.reconst.shm.Sphere" title="dipy.reconst.shm.Sphere"><tt class="xref py py-class docutils literal"><span class="pre">Sphere</span></tt></a><a class="headerlink" href="#id219" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.shm.Sphere">
<em class="property">class </em><tt class="descclassname">dipy.reconst.shm.</tt><tt class="descname">Sphere</tt><big>(</big><em>x=None</em>, <em>y=None</em>, <em>z=None</em>, <em>theta=None</em>, <em>phi=None</em>, <em>xyz=None</em>, <em>faces=None</em>, <em>edges=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.Sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></a></p>
<p>Points on the unit sphere.</p>
<p>The sphere can be constructed using one of three conventions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Sphere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="n">Sphere</span><span class="p">(</span><span class="n">xyz</span><span class="o">=</span><span class="n">xyz</span><span class="p">)</span>
<span class="n">Sphere</span><span class="p">(</span><span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="o">=</span><span class="n">phi</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x, y, z</strong> : 1-D array_like</p>
<blockquote>
<div><p>Vertices as x-y-z coordinates.</p>
</div></blockquote>
<p><strong>theta, phi</strong> : 1-D array_like</p>
<blockquote>
<div><p>Vertices as spherical coordinates.  Theta and phi are the inclination
and azimuth angles respectively.</p>
</div></blockquote>
<p><strong>xyz</strong> : (N, 3) ndarray</p>
<blockquote>
<div><p>Vertices as x-y-z coordinates.</p>
</div></blockquote>
<p><strong>faces</strong> : (N, 3) ndarray</p>
<blockquote>
<div><p>Indices into vertices that form triangular faces.  If unspecified,
the faces are computed using a Delaunay triangulation.</p>
</div></blockquote>
<p><strong>edges</strong> : (N, 2) ndarray</p>
<blockquote class="last">
<div><p>Edges between vertices.  If unspecified, the edges are
derived from the faces.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.Sphere.edges" title="dipy.reconst.shm.Sphere.edges"><tt class="xref py py-obj docutils literal"><span class="pre">edges</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.Sphere.faces" title="dipy.reconst.shm.Sphere.faces"><tt class="xref py py-obj docutils literal"><span class="pre">faces</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.Sphere.find_closest" title="dipy.reconst.shm.Sphere.find_closest"><tt class="xref py py-obj docutils literal"><span class="pre">find_closest</span></tt></a>(xyz)</td>
<td>Find the index of the vertex in the Sphere closest to the input vector</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.Sphere.subdivide" title="dipy.reconst.shm.Sphere.subdivide"><tt class="xref py py-obj docutils literal"><span class="pre">subdivide</span></tt></a>([n])</td>
<td>Subdivides each face of the sphere into four new faces.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.Sphere.vertices" title="dipy.reconst.shm.Sphere.vertices"><tt class="xref py py-obj docutils literal"><span class="pre">vertices</span></tt></a>()</td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.shm.Sphere.__init__">
<tt class="descname">__init__</tt><big>(</big><em>x=None</em>, <em>y=None</em>, <em>z=None</em>, <em>theta=None</em>, <em>phi=None</em>, <em>xyz=None</em>, <em>faces=None</em>, <em>edges=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.Sphere.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="dipy.reconst.shm.Sphere.edges">
<em class="property">static </em><tt class="descname">edges</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.shm.Sphere.edges" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="dipy.reconst.shm.Sphere.faces">
<em class="property">static </em><tt class="descname">faces</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.shm.Sphere.faces" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.reconst.shm.Sphere.find_closest">
<tt class="descname">find_closest</tt><big>(</big><em>xyz</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.Sphere.find_closest" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the index of the vertex in the Sphere closest to the input vector</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>xyz</strong> : array-like, 3 elements</p>
<blockquote class="last">
<div><p>A unit vector</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.shm.Sphere.subdivide">
<tt class="descname">subdivide</tt><big>(</big><em>n=1</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.Sphere.subdivide" title="Permalink to this definition">¶</a></dt>
<dd><p>Subdivides each face of the sphere into four new faces.</p>
<p>New vertices are created at a, b, and c. Then each face [x, y, z] is
divided into faces [x, a, c], [y, a, b], [z, b, c], and [a, b, c].</p>
<div class="highlight-python"><div class="highlight"><pre>   y
   /               /               a/____
/\    /            /  \  /             /____\/____          x      c     z
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>n</strong> : int, optional</p>
<blockquote>
<div><p>The number of subdivisions to preform.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>new_sphere</strong> : Sphere</p>
<blockquote class="last">
<div><p>The subdivided sphere.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="dipy.reconst.shm.Sphere.vertices">
<em class="property">static </em><tt class="descname">vertices</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.shm.Sphere.vertices" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.shm.Sphere.x">
<tt class="descname">x</tt><a class="headerlink" href="#dipy.reconst.shm.Sphere.x" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.shm.Sphere.y">
<tt class="descname">y</tt><a class="headerlink" href="#dipy.reconst.shm.Sphere.y" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.shm.Sphere.z">
<tt class="descname">z</tt><a class="headerlink" href="#dipy.reconst.shm.Sphere.z" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="all-tensor-evecs">
<h3>all_tensor_evecs<a class="headerlink" href="#all-tensor-evecs" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.all_tensor_evecs">
<tt class="descclassname">dipy.reconst.shm.</tt><tt class="descname">all_tensor_evecs</tt><big>(</big><em>e0</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.all_tensor_evecs" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the principle tensor axis, return the array of all
eigenvectors (or, the rotation matrix that orientates the tensor).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>e0</strong> : (3,) ndarray</p>
<blockquote>
<div><p>Principle tensor axis.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>evecs</strong> : (3,3) ndarray</p>
<blockquote class="last">
<div><p>Tensor eigenvectors.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id220">
<h3>auto_attr<a class="headerlink" href="#id220" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.auto_attr">
<tt class="descclassname">dipy.reconst.shm.</tt><tt class="descname">auto_attr</tt><big>(</big><em>func</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.auto_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator to create OneTimeProperty attributes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>func</strong> : method</p>
<blockquote class="last">
<div><p>The method that will be called the first time to compute a value.
Afterwards, the method&#8217;s name will be a standard attribute holding the
value of this computation.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MagicProp</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nd">@auto_attr</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">a</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">99</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">MagicProp</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s">&#39;a&#39;</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">__dict__</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">a</span>
<span class="go">99</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s">&#39;a&#39;</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">__dict__</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="bootstrap-data-array">
<h3>bootstrap_data_array<a class="headerlink" href="#bootstrap-data-array" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.bootstrap_data_array">
<tt class="descclassname">dipy.reconst.shm.</tt><tt class="descname">bootstrap_data_array</tt><big>(</big><em>data</em>, <em>H</em>, <em>R</em>, <em>permute=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.bootstrap_data_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the Residual Bootstraps to the data given H and R</p>
<p>data must be normalized, ie 0 &lt; data &lt;= 1</p>
<p>This function, and the bootstrap_data_voxel function, calculate
residual-bootsrap samples given a Hat matrix and a Residual matrix. These
samples can be used for non-parametric statistics or for bootstrap
probabilistic tractography:</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r136" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id221">[R136]</a></td><td>J. I. Berman, et al., &#8220;Probabilistic streamline q-ball tractography
using the residual bootstrap&#8221; 2008.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r137" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id222">[R137]</a></td><td>HA Haroon, et al., &#8220;Using the model-based residual bootstrap to
quantify uncertainty in fiber orientations from Q-ball analysis&#8221;
2009.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r138" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id223">[R138]</a></td><td>B. Jeurissen, et al., &#8220;Probabilistic Fiber Tracking Using the
Residual Bootstrap with Constrained Spherical Deconvolution&#8221; 2011.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="bootstrap-data-voxel">
<h3>bootstrap_data_voxel<a class="headerlink" href="#bootstrap-data-voxel" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.bootstrap_data_voxel">
<tt class="descclassname">dipy.reconst.shm.</tt><tt class="descname">bootstrap_data_voxel</tt><big>(</big><em>data</em>, <em>H</em>, <em>R</em>, <em>permute=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.bootstrap_data_voxel" title="Permalink to this definition">¶</a></dt>
<dd><p>Like bootstrap_data_array but faster when for a single voxel</p>
<p>data must be 1d and normalized</p>
</dd></dl>

</div>
<div class="section" id="id224">
<h3>cart2sphere<a class="headerlink" href="#id224" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.cart2sphere">
<tt class="descclassname">dipy.reconst.shm.</tt><tt class="descname">cart2sphere</tt><big>(</big><em>x</em>, <em>y</em>, <em>z</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.cart2sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Return angles for Cartesian 3D coordinates <cite>x</cite>, <cite>y</cite>, and <cite>z</cite></p>
<p>See doc for <tt class="docutils literal"><span class="pre">sphere2cart</span></tt> for angle conventions and derivation
of the formulae.</p>
<p><span class="math">0\le\theta\mathrm{(theta)}\le\pi</span> and <span class="math">-\pi\le\phi\mathrm{(phi)}\le\pi</span></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x</strong> : array_like</p>
<blockquote>
<div><p>x coordinate in Cartesian space</p>
</div></blockquote>
<p><strong>y</strong> : array_like</p>
<blockquote>
<div><p>y coordinate in Cartesian space</p>
</div></blockquote>
<p><strong>z</strong> : array_like</p>
<blockquote>
<div><p>z coordinate</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>r</strong> : array</p>
<blockquote>
<div><p>radius</p>
</div></blockquote>
<p><strong>theta</strong> : array</p>
<blockquote>
<div><p>inclination (polar) angle</p>
</div></blockquote>
<p><strong>phi</strong> : array</p>
<blockquote class="last">
<div><p>azimuth angle</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="concatenate">
<h3>concatenate<a class="headerlink" href="#concatenate" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.concatenate">
<tt class="descclassname">dipy.reconst.shm.</tt><tt class="descname">concatenate</tt><big>(</big><em>(a1</em>, <em>a2</em>, <em>...)</em>, <em>axis=0</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.concatenate" title="Permalink to this definition">¶</a></dt>
<dd><p>Join a sequence of arrays together.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a1, a2, ...</strong> : sequence of array_like</p>
<blockquote>
<div><p>The arrays must have the same shape, except in the dimension
corresponding to <cite>axis</cite> (the first, by default).</p>
</div></blockquote>
<p><strong>axis</strong> : int, optional</p>
<blockquote>
<div><p>The axis along which the arrays will be joined.  Default is 0.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>res</strong> : ndarray</p>
<blockquote class="last">
<div><p>The concatenated array.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><tt class="xref py py-obj docutils literal"><span class="pre">ma.concatenate</span></tt></dt>
<dd>Concatenate function that preserves input masks.</dd>
<dt><tt class="xref py py-obj docutils literal"><span class="pre">array_split</span></tt></dt>
<dd>Split an array into multiple sub-arrays of equal or near-equal size.</dd>
<dt><tt class="xref py py-obj docutils literal"><span class="pre">split</span></tt></dt>
<dd>Split array into a list of multiple sub-arrays of equal size.</dd>
<dt><tt class="xref py py-obj docutils literal"><span class="pre">hsplit</span></tt></dt>
<dd>Split array into multiple sub-arrays horizontally (column wise)</dd>
<dt><tt class="xref py py-obj docutils literal"><span class="pre">vsplit</span></tt></dt>
<dd>Split array into multiple sub-arrays vertically (row wise)</dd>
<dt><tt class="xref py py-obj docutils literal"><span class="pre">dsplit</span></tt></dt>
<dd>Split array into multiple sub-arrays along the 3rd axis (depth).</dd>
<dt><tt class="xref py py-obj docutils literal"><span class="pre">hstack</span></tt></dt>
<dd>Stack arrays in sequence horizontally (column wise)</dd>
<dt><tt class="xref py py-obj docutils literal"><span class="pre">vstack</span></tt></dt>
<dd>Stack arrays in sequence vertically (row wise)</dd>
<dt><tt class="xref py py-obj docutils literal"><span class="pre">dstack</span></tt></dt>
<dd>Stack arrays in sequence depth wise (along third dimension)</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>When one or more of the arrays to be concatenated is a MaskedArray,
this function will return a MaskedArray object instead of an ndarray,
but the input masks are <em>not</em> preserved. In cases where a MaskedArray
is expected as input, use the ma.concatenate function from the masked
array module instead.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4],</span>
<span class="go">       [5, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[1, 2, 5],</span>
<span class="go">       [3, 4, 6]])</span>
</pre></div>
</div>
<p>This function will not preserve masking of MaskedArray inputs.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">masked_array(data = [0 -- 2],</span>
<span class="go">             mask = [False  True False],</span>
<span class="go">       fill_value = 999999)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([2, 3, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>
<span class="go">masked_array(data = [0 1 2 2 3 4],</span>
<span class="go">             mask = False,</span>
<span class="go">       fill_value = 999999)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>
<span class="go">masked_array(data = [0 -- 2 2 3 4],</span>
<span class="go">             mask = [False  True False False False False],</span>
<span class="go">       fill_value = 999999)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="diag">
<h3>diag<a class="headerlink" href="#diag" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.diag">
<tt class="descclassname">dipy.reconst.shm.</tt><tt class="descname">diag</tt><big>(</big><em>v</em>, <em>k=0</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.diag" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract a diagonal or construct a diagonal array.</p>
<p>See the more detailed documentation for <tt class="docutils literal"><span class="pre">numpy.diagonal</span></tt> if you use this
function to extract a diagonal and wish to write to the resulting array;
whether it returns a copy or a view depends on what version of numpy you
are using.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>v</strong> : array_like</p>
<blockquote>
<div><p>If <cite>v</cite> is a 2-D array, return a copy of its <cite>k</cite>-th diagonal.
If <cite>v</cite> is a 1-D array, return a 2-D array with <cite>v</cite> on the <cite>k</cite>-th
diagonal.</p>
</div></blockquote>
<p><strong>k</strong> : int, optional</p>
<blockquote>
<div><p>Diagonal in question. The default is 0. Use <cite>k&gt;0</cite> for diagonals
above the main diagonal, and <cite>k&lt;0</cite> for diagonals below the main
diagonal.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> : ndarray</p>
<blockquote class="last">
<div><p>The extracted diagonal or constructed diagonal array.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><tt class="xref py py-obj docutils literal"><span class="pre">diagonal</span></tt></dt>
<dd>Return specified diagonals.</dd>
<dt><tt class="xref py py-obj docutils literal"><span class="pre">diagflat</span></tt></dt>
<dd>Create a 2-D array with the flattened input as a diagonal.</dd>
<dt><a class="reference external" href="http://docs.python.org/library/trace.html#module-trace" title="(in Python v2.7)"><tt class="xref py py-obj docutils literal"><span class="pre">trace</span></tt></a></dt>
<dd>Sum along diagonals.</dd>
<dt><tt class="xref py py-obj docutils literal"><span class="pre">triu</span></tt></dt>
<dd>Upper triangle of an array.</dd>
<dt><tt class="xref py py-obj docutils literal"><span class="pre">tril</span></tt></dt>
<dd>Lower triange of an array.</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5],</span>
<span class="go">       [6, 7, 8]])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([0, 4, 8])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([1, 5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([3, 7])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">array([[0, 0, 0],</span>
<span class="go">       [0, 4, 0],</span>
<span class="go">       [0, 0, 8]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="diff">
<h3>diff<a class="headerlink" href="#diff" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.diff">
<tt class="descclassname">dipy.reconst.shm.</tt><tt class="descname">diff</tt><big>(</big><em>a</em>, <em>n=1</em>, <em>axis=-1</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.diff" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the n-th order discrete difference along given axis.</p>
<p>The first order difference is given by <tt class="docutils literal"><span class="pre">out[n]</span> <span class="pre">=</span> <span class="pre">a[n+1]</span> <span class="pre">-</span> <span class="pre">a[n]</span></tt> along
the given axis, higher order differences are calculated by using <cite>diff</cite>
recursively.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a</strong> : array_like</p>
<blockquote>
<div><p>Input array</p>
</div></blockquote>
<p><strong>n</strong> : int, optional</p>
<blockquote>
<div><p>The number of times values are differenced.</p>
</div></blockquote>
<p><strong>axis</strong> : int, optional</p>
<blockquote>
<div><p>The axis along which the difference is taken, default is the last axis.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>diff</strong> : ndarray</p>
<blockquote class="last">
<div><p>The <cite>n</cite> order differences. The shape of the output is the same as <cite>a</cite>
except along <cite>axis</cite> where the dimension is smaller by <cite>n</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-obj docutils literal"><span class="pre">gradient</span></tt>, <tt class="xref py py-obj docutils literal"><span class="pre">ediff1d</span></tt>, <tt class="xref py py-obj docutils literal"><span class="pre">cumsum</span></tt></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([ 1,  2,  3, -7])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">array([  1,   1, -10])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([[2, 3, 4],</span>
<span class="go">       [5, 1, 2]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[-1,  2,  0, -2]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="dot">
<h3>dot<a class="headerlink" href="#dot" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.dot">
<tt class="descclassname">dipy.reconst.shm.</tt><tt class="descname">dot</tt><big>(</big><em>a</em>, <em>b</em>, <em>out=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Dot product of two arrays.</p>
<p>For 2-D arrays it is equivalent to matrix multiplication, and for 1-D
arrays to inner product of vectors (without complex conjugation). For
N dimensions it is a sum product over the last axis of <cite>a</cite> and
the second-to-last of <cite>b</cite>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="n">k</span><span class="p">,:,</span><span class="n">m</span><span class="p">])</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a</strong> : array_like</p>
<blockquote>
<div><p>First argument.</p>
</div></blockquote>
<p><strong>b</strong> : array_like</p>
<blockquote>
<div><p>Second argument.</p>
</div></blockquote>
<p><strong>out</strong> : ndarray, optional</p>
<blockquote>
<div><p>Output argument. This must have the exact kind that would be returned
if it was not used. In particular, it must have the right type, must be
C-contiguous, and its dtype must be the dtype that would be returned
for <cite>dot(a,b)</cite>. This is a performance feature. Therefore, if these
conditions are not met, an exception is raised, instead of attempting
to be flexible.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : ndarray</p>
<blockquote>
<div><p>Returns the dot product of <cite>a</cite> and <cite>b</cite>.  If <cite>a</cite> and <cite>b</cite> are both
scalars or both 1-D arrays then a scalar is returned; otherwise
an array is returned.
If <cite>out</cite> is given, then it is returned.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>ValueError</strong> :</p>
<blockquote class="last">
<div><p>If the last dimension of <cite>a</cite> is not the same size as
the second-to-last dimension of <cite>b</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><tt class="xref py py-obj docutils literal"><span class="pre">vdot</span></tt></dt>
<dd>Complex-conjugating dot product.</dd>
<dt><tt class="xref py py-obj docutils literal"><span class="pre">tensordot</span></tt></dt>
<dd>Sum products over arbitrary axes.</dd>
<dt><tt class="xref py py-obj docutils literal"><span class="pre">einsum</span></tt></dt>
<dd>Einstein summation convention.</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">12</span>
</pre></div>
</div>
<p>Neither argument is complex-conjugated:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">([</span><span class="mi">2j</span><span class="p">,</span> <span class="mi">3j</span><span class="p">],</span> <span class="p">[</span><span class="mi">2j</span><span class="p">,</span> <span class="mi">3j</span><span class="p">])</span>
<span class="go">(-13+0j)</span>
</pre></div>
</div>
<p>For 2-D arrays it&#8217;s the matrix product:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([[4, 1],</span>
<span class="go">       [2, 2]])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="mi">4</span><span class="o">*</span><span class="mi">5</span><span class="o">*</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="mi">4</span><span class="o">*</span><span class="mi">5</span><span class="o">*</span><span class="mi">6</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="go">499128</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,:]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,:,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">499128</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="empty">
<h3>empty<a class="headerlink" href="#empty" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.empty">
<tt class="descclassname">dipy.reconst.shm.</tt><tt class="descname">empty</tt><big>(</big><em>shape</em>, <em>dtype=float</em>, <em>order='C'</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new array of given shape and type, without initializing entries.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>shape</strong> : int or tuple of int</p>
<blockquote>
<div><p>Shape of the empty array</p>
</div></blockquote>
<p><strong>dtype</strong> : data-type, optional</p>
<blockquote>
<div><p>Desired output data-type.</p>
</div></blockquote>
<p><strong>order</strong> : {&#8216;C&#8217;, &#8216;F&#8217;}, optional</p>
<blockquote class="last">
<div><p>Whether to store multi-dimensional data in C (row-major) or
Fortran (column-major) order in memory.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-obj docutils literal"><span class="pre">empty_like</span></tt>, <tt class="xref py py-obj docutils literal"><span class="pre">zeros</span></tt>, <tt class="xref py py-obj docutils literal"><span class="pre">ones</span></tt></p>
</div>
<p class="rubric">Notes</p>
<p><cite>empty</cite>, unlike <cite>zeros</cite>, does not set the array values to zero,
and may therefore be marginally faster.  On the other hand, it requires
the user to manually set all the values in the array, and should be
used with caution.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">array([[ -9.74499359e+001,   6.69583040e-309],</span>
<span class="go">       [  2.13182611e-314,   3.06959433e-309]])         #random</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([[-1073741821, -1067949133],</span>
<span class="go">       [  496041986,    19249760]])                     #random</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="eye">
<h3>eye<a class="headerlink" href="#eye" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.eye">
<tt class="descclassname">dipy.reconst.shm.</tt><tt class="descname">eye</tt><big>(</big><em>N</em>, <em>M=None</em>, <em>k=0</em>, <em>dtype=&lt;type 'float'&gt;</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.eye" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 2-D array with ones on the diagonal and zeros elsewhere.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Number of rows in the output.</p>
</div></blockquote>
<p><strong>M</strong> : int, optional</p>
<blockquote>
<div><p>Number of columns in the output. If None, defaults to <cite>N</cite>.</p>
</div></blockquote>
<p><strong>k</strong> : int, optional</p>
<blockquote>
<div><p>Index of the diagonal: 0 (the default) refers to the main diagonal,
a positive value refers to an upper diagonal, and a negative value
to a lower diagonal.</p>
</div></blockquote>
<p><strong>dtype</strong> : data-type, optional</p>
<blockquote>
<div><p>Data-type of the returned array.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>I</strong> : ndarray of shape (N,M)</p>
<blockquote class="last">
<div><p>An array where all elements are equal to zero, except for the <cite>k</cite>-th
diagonal, whose values are equal to one.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><tt class="xref py py-obj docutils literal"><span class="pre">identity</span></tt></dt>
<dd>(almost) equivalent function</dd>
<dt><a class="reference internal" href="#dipy.reconst.shm.diag" title="dipy.reconst.shm.diag"><tt class="xref py py-obj docutils literal"><span class="pre">diag</span></tt></a></dt>
<dd>diagonal 2-D array from a 1-D array specified by the user.</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([[1, 0],</span>
<span class="go">       [0, 1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[ 0.,  1.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.],</span>
<span class="go">       [ 0.,  0.,  0.]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="id225">
<h3>forward_sdeconv_mat<a class="headerlink" href="#id225" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.forward_sdeconv_mat">
<tt class="descclassname">dipy.reconst.shm.</tt><tt class="descname">forward_sdeconv_mat</tt><big>(</big><em>r_rh</em>, <em>n</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.forward_sdeconv_mat" title="Permalink to this definition">¶</a></dt>
<dd><p>Build forward spherical deconvolution matrix</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>r_rh</strong> : ndarray</p>
<blockquote>
<div><p>Rotational harmonics coefficients for the single fiber response
function. Each element <cite>rh[i]</cite> is associated with spherical harmonics
of degree <cite>2*i</cite>.</p>
</div></blockquote>
<p><strong>n</strong> : ndarray</p>
<blockquote>
<div><p>The degree of spherical harmonic function associated with each row of
the deconvolution matrix. Only even degrees are allowed</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>R</strong> : ndarray (N, N)</p>
<blockquote class="last">
<div><p>Deconvolution matrix with shape (N, N)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="gen-dirac">
<h3>gen_dirac<a class="headerlink" href="#gen-dirac" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.gen_dirac">
<tt class="descclassname">dipy.reconst.shm.</tt><tt class="descname">gen_dirac</tt><big>(</big><em>m</em>, <em>n</em>, <em>theta</em>, <em>phi</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.gen_dirac" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate Dirac delta function orientated in (theta, phi) on the sphere</p>
<p>The spherical harmonics (SH) representation of this Dirac is returned as
coefficients to spherical harmonic functions produced by
<cite>shm.real_sph_harm</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>m</strong> : ndarray (N,)</p>
<blockquote>
<div><p>The order of the spherical harmonic function associated with each
coefficient.</p>
</div></blockquote>
<p><strong>n</strong> : ndarray (N,)</p>
<blockquote>
<div><p>The degree of the spherical harmonic function associated with each
coefficient.</p>
</div></blockquote>
<p><strong>theta</strong> : float [0, 2*pi]</p>
<blockquote>
<div><p>The azimuthal (longitudinal) coordinate.</p>
</div></blockquote>
<p><strong>phi</strong> : float [0, pi]</p>
<blockquote>
<div><p>The polar (colatitudinal) coordinate.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dirac</strong> : ndarray</p>
<blockquote class="last">
<div><p>SH coefficients representing the Dirac function. The shape of this is
<cite>(m + 2) * (m + 1) / 2</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-obj docutils literal"><span class="pre">shm.real_sph_harm</span></tt>, <tt class="xref py py-obj docutils literal"><span class="pre">shm.real_sym_sh_basis</span></tt></p>
</div>
</dd></dl>

</div>
<div class="section" id="hat">
<h3>hat<a class="headerlink" href="#hat" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.hat">
<tt class="descclassname">dipy.reconst.shm.</tt><tt class="descname">hat</tt><big>(</big><em>B</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.hat" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the hat matrix for the design matrix B</p>
</dd></dl>

</div>
<div class="section" id="id226">
<h3>lazy_index<a class="headerlink" href="#id226" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.lazy_index">
<tt class="descclassname">dipy.reconst.shm.</tt><tt class="descname">lazy_index</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.lazy_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Produces a lazy index</p>
<p>Returns a slice that can be used for indexing an array, if no slice can be
made index is returned as is.</p>
</dd></dl>

</div>
<div class="section" id="lcr-matrix">
<h3>lcr_matrix<a class="headerlink" href="#lcr-matrix" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.lcr_matrix">
<tt class="descclassname">dipy.reconst.shm.</tt><tt class="descname">lcr_matrix</tt><big>(</big><em>H</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.lcr_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a matrix for computing leveraged, centered residuals from data</p>
<p>if r = (d-Hd), the leveraged centered residuals are lcr = (r/l)-mean(r/l)
ruturns the matrix R, such lcr = Rd</p>
</dd></dl>

</div>
<div class="section" id="id227">
<h3>lpn<a class="headerlink" href="#id227" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.lpn">
<tt class="descclassname">dipy.reconst.shm.</tt><tt class="descname">lpn</tt><big>(</big><em>n</em>, <em>z</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.lpn" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute sequence of Legendre functions of the first kind (polynomials),
Pn(z) and derivatives for all degrees from 0 to n (inclusive).</p>
<p>See also special.legendre  for polynomial class.</p>
</dd></dl>

</div>
<div class="section" id="normalize-data">
<h3>normalize_data<a class="headerlink" href="#normalize-data" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.normalize_data">
<tt class="descclassname">dipy.reconst.shm.</tt><tt class="descname">normalize_data</tt><big>(</big><em>data</em>, <em>where_b0</em>, <em>min_signal=1.0</em>, <em>out=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.normalize_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalizes the data with respect to the mean b0</p>
</dd></dl>

</div>
<div class="section" id="order-from-ncoef">
<h3>order_from_ncoef<a class="headerlink" href="#order-from-ncoef" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.order_from_ncoef">
<tt class="descclassname">dipy.reconst.shm.</tt><tt class="descname">order_from_ncoef</tt><big>(</big><em>ncoef</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.order_from_ncoef" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a number n of coefficients, calculate back the sh_order</p>
</dd></dl>

</div>
<div class="section" id="pinv">
<h3>pinv<a class="headerlink" href="#pinv" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.pinv">
<tt class="descclassname">dipy.reconst.shm.</tt><tt class="descname">pinv</tt><big>(</big><em>a</em>, <em>rcond=1e-15</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.pinv" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the (Moore-Penrose) pseudo-inverse of a matrix.</p>
<p>Calculate the generalized inverse of a matrix using its
singular-value decomposition (SVD) and including all
<em>large</em> singular values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a</strong> : (M, N) array_like</p>
<blockquote>
<div><p>Matrix to be pseudo-inverted.</p>
</div></blockquote>
<p><strong>rcond</strong> : float</p>
<blockquote>
<div><p>Cutoff for small singular values.
Singular values smaller (in modulus) than
<cite>rcond</cite> * largest_singular_value (again, in modulus)
are set to zero.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>B</strong> : (N, M) ndarray</p>
<blockquote>
<div><p>The pseudo-inverse of <cite>a</cite>. If <cite>a</cite> is a <cite>matrix</cite> instance, then so
is <cite>B</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>LinAlgError</strong> :</p>
<blockquote class="last">
<div><p>If the SVD computation does not converge.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The pseudo-inverse of a matrix A, denoted <span class="math">A^+</span>, is
defined as: &#8220;the matrix that &#8216;solves&#8217; [the least-squares problem]
<span class="math">Ax = b</span>,&#8221; i.e., if <span class="math">\bar{x}</span> is said solution, then
<span class="math">A^+</span> is that matrix such that <span class="math">\bar{x} = A^+b</span>.</p>
<p>It can be shown that if <span class="math">Q_1 \Sigma Q_2^T = A</span> is the singular
value decomposition of A, then
<span class="math">A^+ = Q_2 \Sigma^+ Q_1^T</span>, where <span class="math">Q_{1,2}</span> are
orthogonal matrices, <span class="math">\Sigma</span> is a diagonal matrix consisting
of A&#8217;s so-called singular values, (followed, typically, by
zeros), and then <span class="math">\Sigma^+</span> is simply the diagonal matrix
consisting of the reciprocals of A&#8217;s singular values
(again, followed by zeros). <a class="reference internal" href="#r139" id="id228">[R139]</a></p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r139" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R139]</td><td><em>(<a class="fn-backref" href="#id228">1</a>, <a class="fn-backref" href="#id229">2</a>)</em> G. Strang, <em>Linear Algebra and Its Applications</em>, 2nd Ed., Orlando,
FL, Academic Press, Inc., 1980, pp. 139-142.</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>The following example checks that <tt class="docutils literal"><span class="pre">a</span> <span class="pre">*</span> <span class="pre">a+</span> <span class="pre">*</span> <span class="pre">a</span> <span class="pre">==</span> <span class="pre">a</span></tt> and
<tt class="docutils literal"><span class="pre">a+</span> <span class="pre">*</span> <span class="pre">a</span> <span class="pre">*</span> <span class="pre">a+</span> <span class="pre">==</span> <span class="pre">a+</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">a</span><span class="p">)))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">B</span><span class="p">)))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="randint">
<h3>randint<a class="headerlink" href="#randint" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.randint">
<tt class="descclassname">dipy.reconst.shm.</tt><tt class="descname">randint</tt><big>(</big><em>low</em>, <em>high=None</em>, <em>size=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.randint" title="Permalink to this definition">¶</a></dt>
<dd><p>Return random integers from <cite>low</cite> (inclusive) to <cite>high</cite> (exclusive).</p>
<p>Return random integers from the &#8220;discrete uniform&#8221; distribution in the
&#8220;half-open&#8221; interval [<cite>low</cite>, <cite>high</cite>). If <cite>high</cite> is None (the default),
then results are from [0, <cite>low</cite>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>low</strong> : int</p>
<blockquote>
<div><p>Lowest (signed) integer to be drawn from the distribution (unless
<tt class="docutils literal"><span class="pre">high=None</span></tt>, in which case this parameter is the <em>highest</em> such
integer).</p>
</div></blockquote>
<p><strong>high</strong> : int, optional</p>
<blockquote>
<div><p>If provided, one above the largest (signed) integer to be drawn
from the distribution (see above for behavior if <tt class="docutils literal"><span class="pre">high=None</span></tt>).</p>
</div></blockquote>
<p><strong>size</strong> : int or tuple of ints, optional</p>
<blockquote>
<div><p>Output shape. Default is None, in which case a single int is
returned.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> : int or ndarray of ints</p>
<blockquote class="last">
<div><p><cite>size</cite>-shaped array of random integers from the appropriate
distribution, or a single such random int if <cite>size</cite> not provided.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><tt class="xref py py-obj docutils literal"><span class="pre">random.random_integers</span></tt></dt>
<dd>similar to <cite>randint</cite>, only for the closed interval [<cite>low</cite>, <cite>high</cite>], and 1 is the lowest value if <cite>high</cite> is omitted. In particular, this other one is the one to use to generate uniformly distributed discrete non-integers.</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="go">array([1, 0, 0, 0, 1, 1, 0, 0, 1, 0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="go">array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])</span>
</pre></div>
</div>
<p>Generate a 2 x 4 array of ints between 0 and 4, inclusive:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="go">array([[4, 0, 2, 1],</span>
<span class="go">       [3, 2, 2, 0]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="id230">
<h3>real_sph_harm<a class="headerlink" href="#id230" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.real_sph_harm">
<tt class="descclassname">dipy.reconst.shm.</tt><tt class="descname">real_sph_harm</tt><big>(</big><em>m</em>, <em>n</em>, <em>theta</em>, <em>phi</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.real_sph_harm" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute real spherical harmonics.</p>
<p>Where the real harmonic <span class="math">Y^m_n</span> is defined to be:</p>
<blockquote>
<div>Real(<span class="math">Y^m_n</span>) * sqrt(2) if m &gt; 0
<span class="math">Y^m_n</span>                 if m == 0
Imag(<span class="math">Y^m_n</span>) * sqrt(2) if m &lt; 0</div></blockquote>
<p>This may take scalar or array arguments. The inputs will be broadcasted
against each other.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>m</strong> : int <tt class="docutils literal"><span class="pre">|m|</span> <span class="pre">&lt;=</span> <span class="pre">n</span></tt></p>
<blockquote>
<div><p>The order of the harmonic.</p>
</div></blockquote>
<p><strong>n</strong> : int <tt class="docutils literal"><span class="pre">&gt;=</span> <span class="pre">0</span></tt></p>
<blockquote>
<div><p>The degree of the harmonic.</p>
</div></blockquote>
<p><strong>theta</strong> : float [0, 2*pi]</p>
<blockquote>
<div><p>The azimuthal (longitudinal) coordinate.</p>
</div></blockquote>
<p><strong>phi</strong> : float [0, pi]</p>
<blockquote>
<div><p>The polar (colatitudinal) coordinate.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>y_mn</strong> : real float</p>
<blockquote class="last">
<div><p>The real harmonic <span class="math">Y^m_n</span> sampled at <cite>theta</cite> and <cite>phi</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-obj docutils literal"><span class="pre">scipy.special.sph_harm</span></tt></p>
</div>
</dd></dl>

</div>
<div class="section" id="id231">
<h3>real_sym_sh_basis<a class="headerlink" href="#id231" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.real_sym_sh_basis">
<tt class="descclassname">dipy.reconst.shm.</tt><tt class="descname">real_sym_sh_basis</tt><big>(</big><em>sh_order</em>, <em>theta</em>, <em>phi</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.real_sym_sh_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples a real symmetric spherical harmonic basis at point on the sphere</p>
<p>Samples the basis functions up to order <cite>sh_order</cite> at points on the sphere
given by <cite>theta</cite> and <cite>phi</cite>. The basis functions are defined here the same
way as in fibernavigator <a class="reference internal" href="#r140" id="id232">[R140]</a> where the real harmonic <span class="math">Y^m_n</span> is defined to
be:</p>
<blockquote>
<div>Imag(<span class="math">Y^m_n</span>) * sqrt(2)     if m &gt; 0
<span class="math">Y^m_n</span>                     if m == 0
Real(<span class="math">Y^|m|_n</span>) * sqrt(2)   if m &lt; 0</div></blockquote>
<p>This may take scalar or array arguments. The inputs will be broadcasted
against each other.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sh_order</strong> : int</p>
<blockquote>
<div><p>even int &gt; 0, max spherical harmonic degree</p>
</div></blockquote>
<p><strong>theta</strong> : float [0, 2*pi]</p>
<blockquote>
<div><p>The azimuthal (longitudinal) coordinate.</p>
</div></blockquote>
<p><strong>phi</strong> : float [0, pi]</p>
<blockquote>
<div><p>The polar (colatitudinal) coordinate.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>y_mn</strong> : real float</p>
<blockquote>
<div><p>The real harmonic <span class="math">Y^m_n</span> sampled at <cite>theta</cite> and <cite>phi</cite></p>
</div></blockquote>
<p><strong>m</strong> : array</p>
<blockquote>
<div><p>The order of the harmonics.</p>
</div></blockquote>
<p><strong>n</strong> : array</p>
<blockquote class="last">
<div><p>The degree of the harmonics.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r140" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R140]</td><td><em>(<a class="fn-backref" href="#id232">1</a>, <a class="fn-backref" href="#id233">2</a>)</em> <a class="reference external" href="http://code.google.com/p/fibernavigator/">http://code.google.com/p/fibernavigator/</a></td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="real-sym-sh-mrtrix">
<h3>real_sym_sh_mrtrix<a class="headerlink" href="#real-sym-sh-mrtrix" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.real_sym_sh_mrtrix">
<tt class="descclassname">dipy.reconst.shm.</tt><tt class="descname">real_sym_sh_mrtrix</tt><big>(</big><em>sh_order</em>, <em>theta</em>, <em>phi</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.real_sym_sh_mrtrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute real spherical harmonics as in mrtrix, where the real harmonic
<span class="math">Y^m_n</span> is defined to be:</p>
<div class="highlight-python"><div class="highlight"><pre>Real(:math:`Y^m_n`)       if m &gt; 0
:math:`Y^m_n`             if m == 0
Imag(:math:`Y^|m|_n`)     if m &lt; 0
</pre></div>
</div>
<p>This may take scalar or array arguments. The inputs will be broadcasted
against each other.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sh_order</strong> : int</p>
<blockquote>
<div><p>The maximum degree or the spherical harmonic basis.</p>
</div></blockquote>
<p><strong>theta</strong> : float [0, pi]</p>
<blockquote>
<div><p>The polar (colatitudinal) coordinate.</p>
</div></blockquote>
<p><strong>phi</strong> : float [0, 2*pi]</p>
<blockquote>
<div><p>The azimuthal (longitudinal) coordinate.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>y_mn</strong> : real float</p>
<blockquote>
<div><p>The real harmonic <span class="math">Y^m_n</span> sampled at <cite>theta</cite> and <cite>phi</cite> as
implemented in mrtrix.  Warning: the basis is Tournier et al
2004 and 2007 is slightly different.</p>
</div></blockquote>
<p><strong>m</strong> : array</p>
<blockquote>
<div><p>The order of the harmonics.</p>
</div></blockquote>
<p><strong>n</strong> : array</p>
<blockquote class="last">
<div><p>The degree of the harmonics.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="sf-to-sh">
<h3>sf_to_sh<a class="headerlink" href="#sf-to-sh" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.sf_to_sh">
<tt class="descclassname">dipy.reconst.shm.</tt><tt class="descname">sf_to_sh</tt><big>(</big><em>sf</em>, <em>sphere</em>, <em>sh_order=4</em>, <em>basis_type=None</em>, <em>smooth=0.0</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.sf_to_sh" title="Permalink to this definition">¶</a></dt>
<dd><p>Spherical function to spherical harmonics (SH).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sf</strong> : ndarray</p>
<blockquote>
<div><p>Values of a function on the given <cite>sphere</cite>.</p>
</div></blockquote>
<p><strong>sphere</strong> : Sphere</p>
<blockquote>
<div><p>The points on which the sf is defined.</p>
</div></blockquote>
<p><strong>sh_order</strong> : int, optional</p>
<blockquote>
<div><p>Maximum SH order in the SH fit.  For <cite>sh_order</cite>, there will be
<tt class="docutils literal"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">*</span> <span class="pre">(sh_order_2)</span> <span class="pre">/</span> <span class="pre">2</span></tt> SH coefficients (default 4).</p>
</div></blockquote>
<p><strong>basis_type</strong> : {None, &#8216;mrtrix&#8217;, &#8216;fibernav&#8217;}</p>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">None</span></tt> for the default dipy basis,
<tt class="docutils literal"><span class="pre">mrtrix</span></tt> for the MRtrix basis, and
<tt class="docutils literal"><span class="pre">fibernav</span></tt> for the FiberNavigator basis
(default <tt class="docutils literal"><span class="pre">None</span></tt>).</p>
</div></blockquote>
<p><strong>smooth</strong> : float, optional</p>
<blockquote>
<div><p>Lambda-regularization in the SH fit (default 0.0).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>sh</strong> : ndarray</p>
<blockquote class="last">
<div><p>SH coefficients representing the input function.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id234">
<h3>sh_to_rh<a class="headerlink" href="#id234" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.sh_to_rh">
<tt class="descclassname">dipy.reconst.shm.</tt><tt class="descname">sh_to_rh</tt><big>(</big><em>r_sh</em>, <em>m</em>, <em>n</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.sh_to_rh" title="Permalink to this definition">¶</a></dt>
<dd><p>Spherical harmonics (SH) to rotational harmonics (RH)</p>
<p>Calculate the rotational harmonic decomposition up to
harmonic order <cite>m</cite>, degree <cite>n</cite> for an axially and antipodally
symmetric function. Note that all <tt class="docutils literal"><span class="pre">m</span> <span class="pre">!=</span> <span class="pre">0</span></tt> coefficients
will be ignored as axial symmetry is assumed. Hence, there
will be <tt class="docutils literal"><span class="pre">(sh_order/2</span> <span class="pre">+</span> <span class="pre">1)</span></tt> non-zero coefficients.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>r_sh</strong> : ndarray (N,)</p>
<blockquote>
<div><p>ndarray of SH coefficients for the single fiber response function.
These coefficients must correspond to the real spherical harmonic
functions produced by <cite>shm.real_sph_harm</cite>.</p>
</div></blockquote>
<p><strong>m</strong> : ndarray (N,)</p>
<blockquote>
<div><p>The order of the spherical harmonic function associated with each
coefficient.</p>
</div></blockquote>
<p><strong>n</strong> : ndarray (N,)</p>
<blockquote>
<div><p>The degree of the spherical harmonic function associated with each
coefficient.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>r_rh</strong> : ndarray (<tt class="docutils literal"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)*(sh_order</span> <span class="pre">+</span> <span class="pre">2)/2</span></tt>,)</p>
<blockquote class="last">
<div><p>Rotational harmonics coefficients representing the input <cite>r_sh</cite></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-obj docutils literal"><span class="pre">shm.real_sph_harm</span></tt>, <tt class="xref py py-obj docutils literal"><span class="pre">shm.real_sym_sh_basis</span></tt></p>
</div>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r141" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id235">[R141]</a></td><td>Tournier, J.D., et al. NeuroImage 2007. Robust determination of the
fibre orientation distribution in diffusion MRI: Non-negativity
constrained super-resolved spherical deconvolution</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="sh-to-sf">
<h3>sh_to_sf<a class="headerlink" href="#sh-to-sf" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.sh_to_sf">
<tt class="descclassname">dipy.reconst.shm.</tt><tt class="descname">sh_to_sf</tt><big>(</big><em>sh</em>, <em>sphere</em>, <em>sh_order</em>, <em>basis_type=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.sh_to_sf" title="Permalink to this definition">¶</a></dt>
<dd><p>Spherical harmonics (SH) to spherical function (SF).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sh</strong> : ndarray</p>
<blockquote>
<div><p>SH coefficients representing a spherical function.</p>
</div></blockquote>
<p><strong>sphere</strong> : Sphere</p>
<blockquote>
<div><p>The points on which to sample the spherical function.</p>
</div></blockquote>
<p><strong>sh_order</strong> : int, optional</p>
<blockquote>
<div><p>Maximum SH order in the SH fit.  For <cite>sh_order</cite>, there will be
<tt class="docutils literal"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">*</span> <span class="pre">(sh_order_2)</span> <span class="pre">/</span> <span class="pre">2</span></tt> SH coefficients (default 4).</p>
</div></blockquote>
<p><strong>basis_type</strong> : {None, &#8216;mrtrix&#8217;, &#8216;fibernav&#8217;}</p>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">None</span></tt> for the default dipy basis,
<tt class="docutils literal"><span class="pre">mrtrix</span></tt> for the MRtrix basis, and
<tt class="docutils literal"><span class="pre">fibernav</span></tt> for the FiberNavigator basis
(default <tt class="docutils literal"><span class="pre">None</span></tt>).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>sf</strong> : ndarray</p>
<blockquote class="last">
<div><p>Spherical function values on the <cite>sphere</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id236">
<h3>sh_to_sf_matrix<a class="headerlink" href="#id236" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.sh_to_sf_matrix">
<tt class="descclassname">dipy.reconst.shm.</tt><tt class="descname">sh_to_sf_matrix</tt><big>(</big><em>sphere</em>, <em>sh_order</em>, <em>basis_type=None</em>, <em>return_inv=True</em>, <em>smooth=0</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.sh_to_sf_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Matrix that transforms Spherical harmonics (SH) to spherical
function (SF).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sphere</strong> : Sphere</p>
<blockquote>
<div><p>The points on which to sample the spherical function.</p>
</div></blockquote>
<p><strong>sh_order</strong> : int, optional</p>
<blockquote>
<div><p>Maximum SH order in the SH fit.  For <cite>sh_order</cite>, there will be
<tt class="docutils literal"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">*</span> <span class="pre">(sh_order_2)</span> <span class="pre">/</span> <span class="pre">2</span></tt> SH coefficients (default 4).</p>
</div></blockquote>
<p><strong>basis_type</strong> : {None, &#8216;mrtrix&#8217;, &#8216;fibernav&#8217;}</p>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">None</span></tt> for the default dipy basis,
<tt class="docutils literal"><span class="pre">mrtrix</span></tt> for the MRtrix basis, and
<tt class="docutils literal"><span class="pre">fibernav</span></tt> for the FiberNavigator basis
(default <tt class="docutils literal"><span class="pre">None</span></tt>).</p>
</div></blockquote>
<p><strong>return_inv</strong> : bool</p>
<blockquote>
<div><p>If True then the inverse of the matrix is also returned</p>
</div></blockquote>
<p><strong>smooth</strong> : float, optional</p>
<blockquote>
<div><p>Lambda-regularization in the SH fit (default 0.0).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>B</strong> : ndarray</p>
<blockquote>
<div><p>Matrix that transforms spherical harmonics to spherical function
<tt class="docutils literal"><span class="pre">sf</span> <span class="pre">=</span> <span class="pre">np.dot(sh,</span> <span class="pre">B)</span></tt>.</p>
</div></blockquote>
<p><strong>invB</strong> : ndarray</p>
<blockquote class="last">
<div><p>Inverse of B.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id237">
<h3>single_tensor<a class="headerlink" href="#id237" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.single_tensor">
<tt class="descclassname">dipy.reconst.shm.</tt><tt class="descname">single_tensor</tt><big>(</big><em>gtab</em>, <em>S0=1</em>, <em>evals=None</em>, <em>evecs=None</em>, <em>snr=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.single_tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulated Q-space signal with a single tensor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>gtab</strong> : GradientTable</p>
<blockquote>
<div><p>Measurement directions.</p>
</div></blockquote>
<p><strong>S0</strong> : double,</p>
<blockquote>
<div><p>Strength of signal in the presence of no diffusion gradient (also
called the <tt class="docutils literal"><span class="pre">b=0</span></tt> value).</p>
</div></blockquote>
<p><strong>evals</strong> : (3,) ndarray</p>
<blockquote>
<div><p>Eigenvalues of the diffusion tensor.  By default, values typical for
prolate white matter are used.</p>
</div></blockquote>
<p><strong>evecs</strong> : (3, 3) ndarray</p>
<blockquote>
<div><p>Eigenvectors of the tensor.  You can also think of this as a rotation
matrix that transforms the direction of the tensor. The eigenvectors
needs to be column wise.</p>
</div></blockquote>
<p><strong>snr</strong> : float</p>
<blockquote>
<div><p>Signal to noise ratio, assuming Rician noise.  None implies no noise.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>S</strong> : (N,) ndarray</p>
<blockquote class="last">
<div><p>Simulated signal: <tt class="docutils literal"><span class="pre">S(q,</span> <span class="pre">tau)</span> <span class="pre">=</span> <span class="pre">S_0</span> <span class="pre">e^(-b</span> <span class="pre">g^T</span> <span class="pre">R</span> <span class="pre">D</span> <span class="pre">R.T</span> <span class="pre">g)</span></tt>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r142" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id238">[R142]</a></td><td>M. Descoteaux, &#8220;High Angular Resolution Diffusion MRI: from Local
Estimation to Segmentation and Tractography&#8221;, PhD thesis,
University of Nice-Sophia Antipolis, p. 42, 2008.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r143" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id239">[R143]</a></td><td>E. Stejskal and J. Tanner, &#8220;Spin diffusion measurements: spin echos
in the presence of a time-dependent field gradient&#8221;, Journal of
Chemical Physics, nr. 42, pp. 288&#8211;292, 1965.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="smooth-pinv">
<h3>smooth_pinv<a class="headerlink" href="#smooth-pinv" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.smooth_pinv">
<tt class="descclassname">dipy.reconst.shm.</tt><tt class="descname">smooth_pinv</tt><big>(</big><em>B</em>, <em>L</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.smooth_pinv" title="Permalink to this definition">¶</a></dt>
<dd><p>Regularized psudo-inverse</p>
<p>Computes a regularized least square inverse of B</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>B</strong> : array_like (n, m)</p>
<blockquote>
<div><p>Matrix to be inverted</p>
</div></blockquote>
<p><strong>L</strong> : array_like (n,)</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>inv</strong> : ndarray (m, n)</p>
<blockquote class="last">
<div><p>regularized least square inverse of B</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>In the literature this inverse is often written <span class="math">(B^{T}B+L^{2})^{-1}B^{T}</span>.
However here this inverse is implemented using the psudo-inverse because it
is more numerically stable than the direct implementation of the matrix
product.</p>
</dd></dl>

</div>
<div class="section" id="id240">
<h3>sph_harm_ind_list<a class="headerlink" href="#id240" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.sph_harm_ind_list">
<tt class="descclassname">dipy.reconst.shm.</tt><tt class="descname">sph_harm_ind_list</tt><big>(</big><em>sh_order</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.sph_harm_ind_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the degree (n) and order (m) of all the symmetric spherical
harmonics of degree less then or equal to <cite>sh_order</cite>. The results, <cite>m_list</cite>
and <cite>n_list</cite> are kx1 arrays, where k depends on sh_order. They can be
passed to <a class="reference internal" href="#dipy.reconst.shm.real_sph_harm" title="dipy.reconst.shm.real_sph_harm"><tt class="xref py py-func docutils literal"><span class="pre">real_sph_harm()</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sh_order</strong> : int</p>
<blockquote>
<div><p>even int &gt; 0, max degree to return</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>m_list</strong> : array</p>
<blockquote>
<div><p>orders of even spherical harmonics</p>
</div></blockquote>
<p><strong>n_list</strong> : array</p>
<blockquote class="last">
<div><p>degrees of even spherical harmonics</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#dipy.reconst.shm.real_sph_harm" title="dipy.reconst.shm.real_sph_harm"><tt class="xref py py-obj docutils literal"><span class="pre">real_sph_harm</span></tt></a></p>
</div>
</dd></dl>

</div>
<div class="section" id="spherical-harmonics">
<h3>spherical_harmonics<a class="headerlink" href="#spherical-harmonics" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.spherical_harmonics">
<tt class="descclassname">dipy.reconst.shm.</tt><tt class="descname">spherical_harmonics</tt><big>(</big><em>m</em>, <em>n</em>, <em>theta</em>, <em>phi</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.spherical_harmonics" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute spherical harmonics</p>
<p>This may take scalar or array arguments. The inputs will be broadcasted
against each other.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>m</strong> : int <tt class="docutils literal"><span class="pre">|m|</span> <span class="pre">&lt;=</span> <span class="pre">n</span></tt></p>
<blockquote>
<div><p>The order of the harmonic.</p>
</div></blockquote>
<p><strong>n</strong> : int <tt class="docutils literal"><span class="pre">&gt;=</span> <span class="pre">0</span></tt></p>
<blockquote>
<div><p>The degree of the harmonic.</p>
</div></blockquote>
<p><strong>theta</strong> : float [0, 2*pi]</p>
<blockquote>
<div><p>The azimuthal (longitudinal) coordinate.</p>
</div></blockquote>
<p><strong>phi</strong> : float [0, pi]</p>
<blockquote>
<div><p>The polar (colatitudinal) coordinate.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>y_mn</strong> : complex float</p>
<blockquote class="last">
<div><p>The harmonic <span class="math">Y^m_n</span> sampled at <cite>theta</cite> and <cite>phi</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This is a faster implementation of scipy.special.sph_harm for
scipy version &lt; 0.15.0.</p>
</dd></dl>

</div>
<div class="section" id="svd">
<h3>svd<a class="headerlink" href="#svd" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.svd">
<tt class="descclassname">dipy.reconst.shm.</tt><tt class="descname">svd</tt><big>(</big><em>a</em>, <em>full_matrices=1</em>, <em>compute_uv=1</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.svd" title="Permalink to this definition">¶</a></dt>
<dd><p>Singular Value Decomposition.</p>
<p>Factors the matrix <cite>a</cite> as <tt class="docutils literal"><span class="pre">u</span> <span class="pre">*</span> <span class="pre">np.diag(s)</span> <span class="pre">*</span> <span class="pre">v</span></tt>, where <cite>u</cite> and <cite>v</cite>
are unitary and <cite>s</cite> is a 1-d array of <cite>a</cite>&#8216;s singular values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a</strong> : (..., M, N) array_like</p>
<blockquote>
<div><p>A real or complex matrix of shape (<cite>M</cite>, <cite>N</cite>) .</p>
</div></blockquote>
<p><strong>full_matrices</strong> : bool, optional</p>
<blockquote>
<div><p>If True (default), <cite>u</cite> and <cite>v</cite> have the shapes (<cite>M</cite>, <cite>M</cite>) and
(<cite>N</cite>, <cite>N</cite>), respectively.  Otherwise, the shapes are (<cite>M</cite>, <cite>K</cite>)
and (<cite>K</cite>, <cite>N</cite>), respectively, where <cite>K</cite> = min(<cite>M</cite>, <cite>N</cite>).</p>
</div></blockquote>
<p><strong>compute_uv</strong> : bool, optional</p>
<blockquote>
<div><p>Whether or not to compute <cite>u</cite> and <cite>v</cite> in addition to <cite>s</cite>.  True
by default.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>u</strong> : { (..., M, M), (..., M, K) } array</p>
<blockquote>
<div><p>Unitary matrices. The actual shape depends on the value of
<tt class="docutils literal"><span class="pre">full_matrices</span></tt>. Only returned when <tt class="docutils literal"><span class="pre">compute_uv</span></tt> is True.</p>
</div></blockquote>
<p><strong>s</strong> : (..., K) array</p>
<blockquote>
<div><p>The singular values for every matrix, sorted in descending order.</p>
</div></blockquote>
<p><strong>v</strong> : { (..., N, N), (..., K, N) } array</p>
<blockquote>
<div><p>Unitary matrices. The actual shape depends on the value of
<tt class="docutils literal"><span class="pre">full_matrices</span></tt>. Only returned when <tt class="docutils literal"><span class="pre">compute_uv</span></tt> is True.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>LinAlgError</strong> :</p>
<blockquote class="last">
<div><p>If SVD computation does not converge.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Broadcasting rules apply, see the <cite>numpy.linalg</cite> documentation for
details.</p>
<p>The decomposition is performed using LAPACK routine _gesdd</p>
<p>The SVD is commonly written as <tt class="docutils literal"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">U</span> <span class="pre">S</span> <span class="pre">V.H</span></tt>.  The <cite>v</cite> returned
by this function is <tt class="docutils literal"><span class="pre">V.H</span></tt> and <tt class="docutils literal"><span class="pre">u</span> <span class="pre">=</span> <span class="pre">U</span></tt>.</p>
<p>If <tt class="docutils literal"><span class="pre">U</span></tt> is a unitary matrix, it means that it
satisfies <tt class="docutils literal"><span class="pre">U.H</span> <span class="pre">=</span> <span class="pre">inv(U)</span></tt>.</p>
<p>The rows of <cite>v</cite> are the eigenvectors of <tt class="docutils literal"><span class="pre">a.H</span> <span class="pre">a</span></tt>. The columns
of <cite>u</cite> are the eigenvectors of <tt class="docutils literal"><span class="pre">a</span> <span class="pre">a.H</span></tt>.  For row <tt class="docutils literal"><span class="pre">i</span></tt> in
<cite>v</cite> and column <tt class="docutils literal"><span class="pre">i</span></tt> in <cite>u</cite>, the corresponding eigenvalue is
<tt class="docutils literal"><span class="pre">s[i]**2</span></tt>.</p>
<p>If <cite>a</cite> is a <cite>matrix</cite> object (as opposed to an <cite>ndarray</cite>), then so
are all the return values.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
</pre></div>
</div>
<p>Reconstruction based on full SVD:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">U</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">U</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">shape</span>
<span class="go">((9, 9), (6, 6), (6,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">9</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="p">[:</span><span class="mi">6</span><span class="p">,</span> <span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">V</span><span class="p">)))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Reconstruction based on reduced SVD:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">U</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">U</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">shape</span>
<span class="go">((9, 6), (6, 6), (6,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">V</span><span class="p">)))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="unique">
<h3>unique<a class="headerlink" href="#unique" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.unique">
<tt class="descclassname">dipy.reconst.shm.</tt><tt class="descname">unique</tt><big>(</big><em>ar</em>, <em>return_index=False</em>, <em>return_inverse=False</em><big>)</big><a class="headerlink" href="#dipy.reconst.shm.unique" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the unique elements of an array.</p>
<p>Returns the sorted unique elements of an array. There are two optional
outputs in addition to the unique elements: the indices of the input array
that give the unique values, and the indices of the unique array that
reconstruct the input array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ar</strong> : array_like</p>
<blockquote>
<div><p>Input array. This will be flattened if it is not already 1-D.</p>
</div></blockquote>
<p><strong>return_index</strong> : bool, optional</p>
<blockquote>
<div><p>If True, also return the indices of <cite>ar</cite> that result in the unique
array.</p>
</div></blockquote>
<p><strong>return_inverse</strong> : bool, optional</p>
<blockquote>
<div><p>If True, also return the indices of the unique array that can be used
to reconstruct <cite>ar</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>unique</strong> : ndarray</p>
<blockquote>
<div><p>The sorted unique values.</p>
</div></blockquote>
<p><strong>unique_indices</strong> : ndarray, optional</p>
<blockquote>
<div><p>The indices of the first occurrences of the unique values in the
(flattened) original array. Only provided if <cite>return_index</cite> is True.</p>
</div></blockquote>
<p><strong>unique_inverse</strong> : ndarray, optional</p>
<blockquote class="last">
<div><p>The indices to reconstruct the (flattened) original array from the
unique array. Only provided if <cite>return_inverse</cite> is True.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><tt class="xref py py-obj docutils literal"><span class="pre">numpy.lib.arraysetops</span></tt></dt>
<dd>Module with a number of other functions for performing set operations on arrays.</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">array([1, 2, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([1, 2, 3])</span>
</pre></div>
</div>
<p>Return the indices of the original array that give the unique values:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span>
<span class="go">array([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;],</span>
<span class="go">       dtype=&#39;|S1&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span>
<span class="go">array([0, 1, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
<span class="go">array([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;],</span>
<span class="go">       dtype=&#39;|S1&#39;)</span>
</pre></div>
</div>
<p>Reconstruct the input array from the unique values:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span>
<span class="go">array([1, 2, 3, 4, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span>
<span class="go">array([0, 1, 4, 3, 1, 2, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
<span class="go">array([1, 2, 6, 4, 2, 3, 2])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="id241">
<h3><a class="reference internal" href="#dipy.reconst.shore.Cache" title="dipy.reconst.shore.Cache"><tt class="xref py py-class docutils literal"><span class="pre">Cache</span></tt></a><a class="headerlink" href="#id241" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.shore.Cache">
<em class="property">class </em><tt class="descclassname">dipy.reconst.shore.</tt><tt class="descname">Cache</tt><a class="headerlink" href="#dipy.reconst.shore.Cache" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></a></p>
<p>Cache values based on a key object (such as a sphere or gradient table).</p>
<p class="rubric">Notes</p>
<p>This class is meant to be used as a mix-in:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MyModel</span><span class="p">(</span><span class="n">Model</span><span class="p">,</span> <span class="n">Cache</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">MyModelFit</span><span class="p">(</span><span class="n">Fit</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>Inside a method on the fit, typical usage would be:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">odf</span><span class="p">(</span><span class="n">sphere</span><span class="p">):</span>
    <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">cache_get</span><span class="p">(</span><span class="s">&#39;odf_basis_matrix&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sphere</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">M</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_basis_matrix</span><span class="p">(</span><span class="n">sphere</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">cache_set</span><span class="p">(</span><span class="s">&#39;odf_basis_matrix&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sphere</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">M</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shore.Cache.cache_clear" title="dipy.reconst.shore.Cache.cache_clear"><tt class="xref py py-obj docutils literal"><span class="pre">cache_clear</span></tt></a>()</td>
<td>Clear the cache.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shore.Cache.cache_get" title="dipy.reconst.shore.Cache.cache_get"><tt class="xref py py-obj docutils literal"><span class="pre">cache_get</span></tt></a>(tag,&nbsp;key[,&nbsp;default])</td>
<td>Retrieve a value from the cache.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shore.Cache.cache_set" title="dipy.reconst.shore.Cache.cache_set"><tt class="xref py py-obj docutils literal"><span class="pre">cache_set</span></tt></a>(tag,&nbsp;key,&nbsp;value)</td>
<td>Store a value in the cache.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.shore.Cache.__init__">
<tt class="descname">__init__</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.shore.Cache.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.shore.Cache.cache_clear">
<tt class="descname">cache_clear</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.shore.Cache.cache_clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear the cache.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.shore.Cache.cache_get">
<tt class="descname">cache_get</tt><big>(</big><em>tag</em>, <em>key</em>, <em>default=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.shore.Cache.cache_get" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a value from the cache.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>tag</strong> : str</p>
<blockquote>
<div><p>Description of the cached value.</p>
</div></blockquote>
<p><strong>key</strong> : object</p>
<blockquote>
<div><p>Key object used to look up the cached value.</p>
</div></blockquote>
<p><strong>default</strong> : object</p>
<blockquote>
<div><p>Value to be returned if no cached entry is found.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>v</strong> : object</p>
<blockquote class="last">
<div><p>Value from the cache associated with <tt class="docutils literal"><span class="pre">(tag,</span> <span class="pre">key)</span></tt>.  Returns
<cite>default</cite> if no cached entry is found.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.shore.Cache.cache_set">
<tt class="descname">cache_set</tt><big>(</big><em>tag</em>, <em>key</em>, <em>value</em><big>)</big><a class="headerlink" href="#dipy.reconst.shore.Cache.cache_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Store a value in the cache.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>tag</strong> : str</p>
<blockquote>
<div><p>Description of the cached value.</p>
</div></blockquote>
<p><strong>key</strong> : object</p>
<blockquote>
<div><p>Key object used to look up the cached value.</p>
</div></blockquote>
<p><strong>value</strong> : object</p>
<blockquote class="last">
<div><p>Value stored in the cache for each unique combination
of <tt class="docutils literal"><span class="pre">(tag,</span> <span class="pre">key)</span></tt>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">compute_expensive_matrix</span><span class="p">(</span><span class="n">parameters</span><span class="p">):</span>
<span class="gp">... </span>    <span class="c"># Imagine the following computation is very expensive</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Cache</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">parameters</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X1</span> <span class="o">=</span> <span class="n">compute_expensive_matrix</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">cache_set</span><span class="p">(</span><span class="s">&#39;expensive_matrix&#39;</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">X1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X2</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">cache_get</span><span class="p">(</span><span class="s">&#39;expensive_matrix&#39;</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">X1</span> <span class="ow">is</span> <span class="n">X2</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="shorefit">
<h3><a class="reference internal" href="#dipy.reconst.shore.ShoreFit" title="dipy.reconst.shore.ShoreFit"><tt class="xref py py-class docutils literal"><span class="pre">ShoreFit</span></tt></a><a class="headerlink" href="#shorefit" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.shore.ShoreFit">
<em class="property">class </em><tt class="descclassname">dipy.reconst.shore.</tt><tt class="descname">ShoreFit</tt><big>(</big><em>model</em>, <em>shore_coef</em><big>)</big><a class="headerlink" href="#dipy.reconst.shore.ShoreFit" title="Permalink to this definition">¶</a></dt>
<dd><p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shore.ShoreFit.fitted_signal" title="dipy.reconst.shore.ShoreFit.fitted_signal"><tt class="xref py py-obj docutils literal"><span class="pre">fitted_signal</span></tt></a>()</td>
<td>The fitted signal.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shore.ShoreFit.msd" title="dipy.reconst.shore.ShoreFit.msd"><tt class="xref py py-obj docutils literal"><span class="pre">msd</span></tt></a>()</td>
<td>Calculates the analytical mean squared displacement (MSD) [R147]</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shore.ShoreFit.odf" title="dipy.reconst.shore.ShoreFit.odf"><tt class="xref py py-obj docutils literal"><span class="pre">odf</span></tt></a>(sphere)</td>
<td>Calculates the ODF for a given discrete sphere.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shore.ShoreFit.odf_sh" title="dipy.reconst.shore.ShoreFit.odf_sh"><tt class="xref py py-obj docutils literal"><span class="pre">odf_sh</span></tt></a>()</td>
<td>Calculates the real analytical ODF in terms of Spherical Harmonics.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shore.ShoreFit.pdf" title="dipy.reconst.shore.ShoreFit.pdf"><tt class="xref py py-obj docutils literal"><span class="pre">pdf</span></tt></a>(r_points)</td>
<td>Diffusion propagator on a given set of real points.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shore.ShoreFit.pdf_grid" title="dipy.reconst.shore.ShoreFit.pdf_grid"><tt class="xref py py-obj docutils literal"><span class="pre">pdf_grid</span></tt></a>(gridsize,&nbsp;radius_max)</td>
<td>Applies the analytical FFT on <span class="math">S</span> to generate the diffusion propagator.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shore.ShoreFit.rtop_pdf" title="dipy.reconst.shore.ShoreFit.rtop_pdf"><tt class="xref py py-obj docutils literal"><span class="pre">rtop_pdf</span></tt></a>()</td>
<td>Calculates the analytical return to origin probability (RTOP) from the pdf [R148].</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shore.ShoreFit.rtop_signal" title="dipy.reconst.shore.ShoreFit.rtop_signal"><tt class="xref py py-obj docutils literal"><span class="pre">rtop_signal</span></tt></a>()</td>
<td>Calculates the analytical return to origin probability (RTOP) from the signal [R149].</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.shore.ShoreFit.__init__">
<tt class="descname">__init__</tt><big>(</big><em>model</em>, <em>shore_coef</em><big>)</big><a class="headerlink" href="#dipy.reconst.shore.ShoreFit.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates diffusion properties for a single voxel</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>model</strong> : object,</p>
<blockquote>
<div><p>AnalyticalModel</p>
</div></blockquote>
<p><strong>shore_coef</strong> : 1d ndarray,</p>
<blockquote class="last">
<div><p>shore coefficients</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.shore.ShoreFit.fitted_signal">
<tt class="descname">fitted_signal</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.shore.ShoreFit.fitted_signal" title="Permalink to this definition">¶</a></dt>
<dd><p>The fitted signal.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.shore.ShoreFit.msd">
<tt class="descname">msd</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.shore.ShoreFit.msd" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the analytical mean squared displacement (MSD) <a class="reference internal" href="#r144" id="id245">[R144]</a></p>
<dl class="docutils">
<dt>..math::</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">nowrap:</th><td class="field-body"><dl class="first docutils">
<dt>begin{equation}</dt>
<dd><p class="first last">MSD:{DSI}=int_{-infty}^{infty}int_{-infty}^{infty}int_{-infty}^{infty} P(hat{mathbf{r}}) cdot hat{mathbf{r}}^{2} dr_x dr_y dr_z</p>
</dd>
</dl>
<p class="last">end{equation}</p>
</td>
</tr>
</tbody>
</table>
</dd>
</dl>
<p>where <span class="math">\hat{\mathbf{r}}</span> is a point in the 3D propagator space (see Wu et. al <a class="reference internal" href="#r144" id="id246">[R144]</a>).</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r144" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R144]</td><td><em>(<a class="fn-backref" href="#id245">1</a>, <a class="fn-backref" href="#id246">2</a>, <a class="fn-backref" href="#id247">3</a>)</em> Wu Y. et. al, &#8220;Hybrid diffusion imaging&#8221;, NeuroImage, vol 36,</td></tr>
</tbody>
</table>
<ol class="loweralpha simple" start="16">
<li>617-629, 2007.</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.shore.ShoreFit.odf">
<tt class="descname">odf</tt><big>(</big><em>sphere</em><big>)</big><a class="headerlink" href="#dipy.reconst.shore.ShoreFit.odf" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the ODF for a given discrete sphere.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.shore.ShoreFit.odf_sh">
<tt class="descname">odf_sh</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.shore.ShoreFit.odf_sh" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the real analytical ODF in terms of Spherical Harmonics.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.shore.ShoreFit.pdf">
<tt class="descname">pdf</tt><big>(</big><em>r_points</em><big>)</big><a class="headerlink" href="#dipy.reconst.shore.ShoreFit.pdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Diffusion propagator on a given set of real points.
if the array r_points is non writeable, then intermediate
results are cached for faster recalculation</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.shore.ShoreFit.pdf_grid">
<tt class="descname">pdf_grid</tt><big>(</big><em>gridsize</em>, <em>radius_max</em><big>)</big><a class="headerlink" href="#dipy.reconst.shore.ShoreFit.pdf_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the analytical FFT on <span class="math">S</span> to generate the diffusion
propagator. This is calculated on a discrete 3D grid in order to
obtain an EAP similar to that which is obtained with DSI.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>gridsize</strong> : unsigned int</p>
<blockquote>
<div><p>dimension of the propagator grid</p>
</div></blockquote>
<p><strong>radius_max</strong> : float</p>
<blockquote>
<div><p>maximal radius in which to compute the propagator</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>eap</strong> : ndarray</p>
<blockquote class="last">
<div><p>the ensemble average propagator in the 3D grid</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.shore.ShoreFit.rtop_pdf">
<tt class="descname">rtop_pdf</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.shore.ShoreFit.rtop_pdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the analytical return to origin probability (RTOP)
from the pdf <a class="reference internal" href="#r145" id="id248">[R145]</a>.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r145" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R145]</td><td><em>(<a class="fn-backref" href="#id248">1</a>, <a class="fn-backref" href="#id249">2</a>)</em> Ozarslan E. et. al, &#8220;Mean apparent propagator (MAP) MRI: A novel</td></tr>
</tbody>
</table>
<p>diffusion imaging method for mapping tissue microstructure&#8221;,
NeuroImage, 2013.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.shore.ShoreFit.rtop_signal">
<tt class="descname">rtop_signal</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.shore.ShoreFit.rtop_signal" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the analytical return to origin probability (RTOP)
from the signal <a class="reference internal" href="#r146" id="id250">[R146]</a>.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r146" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R146]</td><td><em>(<a class="fn-backref" href="#id250">1</a>, <a class="fn-backref" href="#id251">2</a>)</em> Ozarslan E. et. al, &#8220;Mean apparent propagator (MAP) MRI: A novel</td></tr>
</tbody>
</table>
<p>diffusion imaging method for mapping tissue microstructure&#8221;,
NeuroImage, 2013.</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.shore.ShoreFit.shore_coeff">
<tt class="descname">shore_coeff</tt><a class="headerlink" href="#dipy.reconst.shore.ShoreFit.shore_coeff" title="Permalink to this definition">¶</a></dt>
<dd><p>The SHORE coefficients</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="shoremodel">
<h3><a class="reference internal" href="#dipy.reconst.shore.ShoreModel" title="dipy.reconst.shore.ShoreModel"><tt class="xref py py-class docutils literal"><span class="pre">ShoreModel</span></tt></a><a class="headerlink" href="#shoremodel" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.reconst.shore.ShoreModel">
<em class="property">class </em><tt class="descclassname">dipy.reconst.shore.</tt><tt class="descname">ShoreModel</tt><big>(</big><em>gtab</em>, <em>radial_order=6</em>, <em>zeta=700</em>, <em>lambdaN=1e-08</em>, <em>lambdaL=1e-08</em>, <em>tau=0.025330295910584444</em>, <em>constrain_e0=False</em>, <em>positive_constraint=False</em>, <em>pos_grid=11</em>, <em>pos_radius=0.02</em><big>)</big><a class="headerlink" href="#dipy.reconst.shore.ShoreModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.cache.Cache" title="dipy.reconst.cache.Cache"><tt class="xref py py-class docutils literal"><span class="pre">dipy.reconst.cache.Cache</span></tt></a></p>
<p>Simple Harmonic Oscillator based Reconstruction and Estimation
(SHORE) <a class="reference internal" href="#r150" id="id252">[R150]</a> of the diffusion signal.</p>
<p>The main idea is to model the diffusion signal as a linear combination of
continuous functions <span class="math">\phi_i</span>,</p>
<dl class="docutils">
<dt>..math::</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">nowrap:</th><td class="field-body"><dl class="first docutils">
<dt>begin{equation}</dt>
<dd><p class="first last">S(mathbf{q})= sum_{i=0}^I  c_{i} phi_{i}(mathbf{q}).</p>
</dd>
</dl>
<p class="last">end{equation}</p>
</td>
</tr>
</tbody>
</table>
</dd>
</dl>
<p>where <span class="math">\mathbf{q}</span> is the wavector which corresponds to different gradient
directions. Numerous continuous functions <span class="math">\phi_i</span> can be used to model
<span class="math">S</span>. Some are presented in [2,3,4]_.</p>
<p>From the <span class="math">c_i</span> coefficients, there exist analytical formulae to estimate
the ODF, the return to the origin porbability (RTOP), the mean square
displacement (MSD), amongst others <a class="reference internal" href="#r154" id="id253">[R154]</a>.</p>
<p class="rubric">Notes</p>
<p>The implementation of SHORE depends on CVXOPT (<a class="reference external" href="http://cvxopt.org/">http://cvxopt.org/</a>). This
software is licensed under the GPL (see:
<a class="reference external" href="http://cvxopt.org/copyright.html).and">http://cvxopt.org/copyright.html).and</a> you may be subject to this license
when using SHORE.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r150" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R150]</td><td><em>(<a class="fn-backref" href="#id252">1</a>, <a class="fn-backref" href="#id254">2</a>)</em> Ozarslan E. et. al, &#8220;Simple harmonic oscillator based reconstruction
and estimation for one-dimensional q-space magnetic resonance
1D-SHORE)&#8221;, eapoc Intl Soc Mag Reson Med, vol. 16, p. 35., 2008.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r151" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id255">[R151]</a></td><td>Merlet S. et. al, &#8220;Continuous diffusion signal, EAP and ODF
estimation via Compressive Sensing in diffusion MRI&#8221;, Medical
Image Analysis, 2013.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r152" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id256">[R152]</a></td><td>Rathi Y. et. al, &#8220;Sparse multi-shell diffusion imaging&#8221;, MICCAI,
2011.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r153" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id257">[R153]</a></td><td>Cheng J. et. al, &#8220;Theoretical Analysis and eapactical Insights on
EAP Estimation via a Unified HARDI Framework&#8221;, MICCAI workshop on
Computational Diffusion MRI, 2011.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r154" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R154]</td><td><em>(<a class="fn-backref" href="#id253">1</a>, <a class="fn-backref" href="#id258">2</a>)</em> Ozarslan E. et. al, &#8220;Mean apparent propagator (MAP) MRI: A novel
diffusion imaging method for mapping tissue microstructure&#8221;,
NeuroImage, 2013.</td></tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">cache_clear</span></tt>()</td>
<td>Clear the cache.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">cache_get</span></tt>(tag,&nbsp;key[,&nbsp;default])</td>
<td>Retrieve a value from the cache.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">cache_set</span></tt>(tag,&nbsp;key,&nbsp;value)</td>
<td>Store a value in the cache.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shore.ShoreModel.fit" title="dipy.reconst.shore.ShoreModel.fit"><tt class="xref py py-obj docutils literal"><span class="pre">fit</span></tt></a>(data[,&nbsp;mask])</td>
<td>Fit method for every voxel in data</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.shore.ShoreModel.__init__">
<tt class="descname">__init__</tt><big>(</big><em>gtab</em>, <em>radial_order=6</em>, <em>zeta=700</em>, <em>lambdaN=1e-08</em>, <em>lambdaL=1e-08</em>, <em>tau=0.025330295910584444</em>, <em>constrain_e0=False</em>, <em>positive_constraint=False</em>, <em>pos_grid=11</em>, <em>pos_radius=0.02</em><big>)</big><a class="headerlink" href="#dipy.reconst.shore.ShoreModel.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Analytical and continuous modeling of the diffusion signal with
respect to the SHORE basis [1,2]_.
This implementation is a modification of SHORE presented in <a class="reference internal" href="#r155" id="id259">[R155]</a>.
The modification was made to obtain the same ordering of the basis
presented in [2,3]_.</p>
<p>The main idea is to model the diffusion signal as a linear
combination of continuous functions <span class="math">\phi_i</span>,</p>
<dl class="docutils">
<dt>..math::</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">nowrap:</th><td class="field-body"><dl class="first docutils">
<dt>begin{equation}</dt>
<dd><p class="first last">S(mathbf{q})= sum_{i=0}^I  c_{i} phi_{i}(mathbf{q}).</p>
</dd>
</dl>
<p class="last">end{equation}</p>
</td>
</tr>
</tbody>
</table>
</dd>
</dl>
<p>where <span class="math">\mathbf{q}</span> is the wavector which corresponds to different
gradient directions.</p>
<p>From the <span class="math">c_i</span> coefficients, there exists an analytical formula to
estimate the ODF.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>gtab</strong> : GradientTable,</p>
<blockquote>
<div><p>gradient directions and bvalues container class</p>
</div></blockquote>
<p><strong>radial_order</strong> : unsigned int,</p>
<blockquote>
<div><p>an even integer that represent the order of the basis</p>
</div></blockquote>
<p><strong>zeta</strong> : unsigned int,</p>
<blockquote>
<div><p>scale factor</p>
</div></blockquote>
<p><strong>lambdaN</strong> : float,</p>
<blockquote>
<div><p>radial regularisation constant</p>
</div></blockquote>
<p><strong>lambdaL</strong> : float,</p>
<blockquote>
<div><p>angular regularisation constant</p>
</div></blockquote>
<p><strong>tau</strong> : float,</p>
<blockquote>
<div><p>diffusion time. By default the value that makes q equal to the
square root of the b-value.</p>
</div></blockquote>
<p><strong>constrain_e0</strong> : bool,</p>
<blockquote>
<div><p>Constrain the optimization such that E(0) = 1.</p>
</div></blockquote>
<p><strong>positive_constraint</strong> : bool,</p>
<blockquote>
<div><p>Constrain the propagator to be positive.</p>
</div></blockquote>
<p><strong>pos_grid</strong> : int,</p>
<blockquote>
<div><p>Grid that define the points of the EAP in which we want to enforce
positivity.</p>
</div></blockquote>
<p><strong>pos_radius</strong> : float,</p>
<blockquote class="last">
<div><p>Radius of the grid of the EAP in which enforce positivity in
millimeters. By default 20e-03 mm.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r155" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R155]</td><td><em>(<a class="fn-backref" href="#id259">1</a>, <a class="fn-backref" href="#id260">2</a>)</em> Merlet S. et al., &#8220;Continuous diffusion signal, EAP and</td></tr>
</tbody>
</table>
<p>ODF estimation via Compressive Sensing in diffusion MRI&#8221;, Medical
Image Analysis, 2013.</p>
<table class="docutils citation" frame="void" id="r156" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id261">[R156]</a></td><td>Cheng J. et al., &#8220;Theoretical Analysis and eapactical Insights</td></tr>
</tbody>
</table>
<p>on EAP Estimation via a Unified HARDI Framework&#8221;, MICCAI workshop on
Computational Diffusion MRI, 2011.</p>
<table class="docutils citation" frame="void" id="r157" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id262">[R157]</a></td><td>Ozarslan E. et al., &#8220;Mean apparent propagator (MAP) MRI: A novel
diffusion imaging method for mapping tissue microstructure&#8221;,
NeuroImage, 2013.</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>In this example, where the data, gradient table and sphere tessellation
used for reconstruction are provided, we model the diffusion signal
with respect to the SHORE basis and compute the real and analytical
ODF.</p>
<p>from dipy.data import get_data,get_sphere
sphere = get_sphere(&#8216;symmetric724&#8217;)
fimg, fbvals, fbvecs = get_data(&#8216;ISBI_testing_2shells_table&#8217;)
bvals, bvecs = read_bvals_bvecs(fbvals, fbvecs)
gtab = gradient_table(bvals, bvecs)
from dipy.sims.voxel import SticksAndBall
data, golden_directions = SticksAndBall(gtab, d=0.0015,</p>
<blockquote>
<div>S0=1, angles=[(0, 0), (90, 0)],
fractions=[50, 50], snr=None)</div></blockquote>
<p>from dipy.reconst.canal import ShoreModel
radial_order = 4
zeta = 700
asm = ShoreModel(gtab, radial_order=radial_order, zeta=zeta,</p>
<blockquote>
<div>lambdaN=1e-8, lambdaL=1e-8)</div></blockquote>
<p>asmfit = asm.fit(data)
odf= asmfit.odf(sphere)</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.shore.ShoreModel.fit">
<tt class="descname">fit</tt><big>(</big><em>data</em>, <em>mask=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.shore.ShoreModel.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id263">
<h3>cart2sphere<a class="headerlink" href="#id263" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shore.cart2sphere">
<tt class="descclassname">dipy.reconst.shore.</tt><tt class="descname">cart2sphere</tt><big>(</big><em>x</em>, <em>y</em>, <em>z</em><big>)</big><a class="headerlink" href="#dipy.reconst.shore.cart2sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Return angles for Cartesian 3D coordinates <cite>x</cite>, <cite>y</cite>, and <cite>z</cite></p>
<p>See doc for <tt class="docutils literal"><span class="pre">sphere2cart</span></tt> for angle conventions and derivation
of the formulae.</p>
<p><span class="math">0\le\theta\mathrm{(theta)}\le\pi</span> and <span class="math">-\pi\le\phi\mathrm{(phi)}\le\pi</span></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x</strong> : array_like</p>
<blockquote>
<div><p>x coordinate in Cartesian space</p>
</div></blockquote>
<p><strong>y</strong> : array_like</p>
<blockquote>
<div><p>y coordinate in Cartesian space</p>
</div></blockquote>
<p><strong>z</strong> : array_like</p>
<blockquote>
<div><p>z coordinate</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>r</strong> : array</p>
<blockquote>
<div><p>radius</p>
</div></blockquote>
<p><strong>theta</strong> : array</p>
<blockquote>
<div><p>inclination (polar) angle</p>
</div></blockquote>
<p><strong>phi</strong> : array</p>
<blockquote class="last">
<div><p>azimuth angle</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="create-rspace">
<h3>create_rspace<a class="headerlink" href="#create-rspace" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shore.create_rspace">
<tt class="descclassname">dipy.reconst.shore.</tt><tt class="descname">create_rspace</tt><big>(</big><em>gridsize</em>, <em>radius_max</em><big>)</big><a class="headerlink" href="#dipy.reconst.shore.create_rspace" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Create the real space table, that contains the points in which</dt>
<dd>to compute the pdf.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>gridsize</strong> : unsigned int</p>
<blockquote>
<div><p>dimension of the propagator grid</p>
</div></blockquote>
<p><strong>radius_max</strong> : float</p>
<blockquote>
<div><p>maximal radius in which compute the propagator</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>vecs</strong> : array, shape (N,3)</p>
<blockquote>
<div><p>positions of the pdf points in a 3D matrix</p>
</div></blockquote>
<p><strong>tab</strong> : array, shape (N,3)</p>
<blockquote class="last">
<div><p>real space points in which calculates the pdf</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="factorial">
<h3>factorial<a class="headerlink" href="#factorial" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shore.factorial">
<tt class="descclassname">dipy.reconst.shore.</tt><tt class="descname">factorial</tt><big>(</big><em>x</em><big>)</big> &rarr; Integral<a class="headerlink" href="#dipy.reconst.shore.factorial" title="Permalink to this definition">¶</a></dt>
<dd><p>Find x!. Raise a ValueError if x is negative or non-integral.</p>
</dd></dl>

</div>
<div class="section" id="genlaguerre">
<h3>genlaguerre<a class="headerlink" href="#genlaguerre" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shore.genlaguerre">
<tt class="descclassname">dipy.reconst.shore.</tt><tt class="descname">genlaguerre</tt><big>(</big><em>n</em>, <em>alpha</em>, <em>monic=0</em><big>)</big><a class="headerlink" href="#dipy.reconst.shore.genlaguerre" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the nth order generalized (associated) Laguerre polynomial,
L^(alpha)_n(x), orthogonal over [0,inf) with weighting function
exp(-x) x**alpha with alpha &gt; -1</p>
</dd></dl>

</div>
<div class="section" id="l-shore">
<h3>l_shore<a class="headerlink" href="#l-shore" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shore.l_shore">
<tt class="descclassname">dipy.reconst.shore.</tt><tt class="descname">l_shore</tt><big>(</big><em>radial_order</em><big>)</big><a class="headerlink" href="#dipy.reconst.shore.l_shore" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the angular regularisation matrix for SHORE basis</p>
</dd></dl>

</div>
<div class="section" id="id264">
<h3>multi_voxel_fit<a class="headerlink" href="#id264" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shore.multi_voxel_fit">
<tt class="descclassname">dipy.reconst.shore.</tt><tt class="descname">multi_voxel_fit</tt><big>(</big><em>single_voxel_fit</em><big>)</big><a class="headerlink" href="#dipy.reconst.shore.multi_voxel_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Method decorator to turn a single voxel model fit
definition into a multi voxel model fit definition</p>
</dd></dl>

</div>
<div class="section" id="n-shore">
<h3>n_shore<a class="headerlink" href="#n-shore" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shore.n_shore">
<tt class="descclassname">dipy.reconst.shore.</tt><tt class="descname">n_shore</tt><big>(</big><em>radial_order</em><big>)</big><a class="headerlink" href="#dipy.reconst.shore.n_shore" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the angular regularisation matrix for SHORE basis</p>
</dd></dl>

</div>
<div class="section" id="id265">
<h3>optional_package<a class="headerlink" href="#id265" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shore.optional_package">
<tt class="descclassname">dipy.reconst.shore.</tt><tt class="descname">optional_package</tt><big>(</big><em>name</em>, <em>trip_msg=None</em><big>)</big><a class="headerlink" href="#dipy.reconst.shore.optional_package" title="Permalink to this definition">¶</a></dt>
<dd><p>Return package-like thing and module setup for package <cite>name</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>name</strong> : str</p>
<blockquote>
<div><p>package name</p>
</div></blockquote>
<p><strong>trip_msg</strong> : None or str</p>
<blockquote>
<div><p>message to give when someone tries to use the return package, but we
could not import it, and have returned a TripWire object instead.
Default message if None.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>pkg_like</strong> : module or <tt class="docutils literal"><span class="pre">TripWire</span></tt> instance</p>
<blockquote>
<div><p>If we can import the package, return it.  Otherwise return an object
raising an error when accessed</p>
</div></blockquote>
<p><strong>have_pkg</strong> : bool</p>
<blockquote>
<div><p>True if import for package was successful, false otherwise</p>
</div></blockquote>
<p><strong>module_setup</strong> : function</p>
<blockquote class="last">
<div><p>callable usually set as <tt class="docutils literal"><span class="pre">setup_module</span></tt> in calling namespace, to allow
skipping tests.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id266">
<h3>real_sph_harm<a class="headerlink" href="#id266" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shore.real_sph_harm">
<tt class="descclassname">dipy.reconst.shore.</tt><tt class="descname">real_sph_harm</tt><big>(</big><em>m</em>, <em>n</em>, <em>theta</em>, <em>phi</em><big>)</big><a class="headerlink" href="#dipy.reconst.shore.real_sph_harm" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute real spherical harmonics.</p>
<p>Where the real harmonic <span class="math">Y^m_n</span> is defined to be:</p>
<blockquote>
<div>Real(<span class="math">Y^m_n</span>) * sqrt(2) if m &gt; 0
<span class="math">Y^m_n</span>                 if m == 0
Imag(<span class="math">Y^m_n</span>) * sqrt(2) if m &lt; 0</div></blockquote>
<p>This may take scalar or array arguments. The inputs will be broadcasted
against each other.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>m</strong> : int <tt class="docutils literal"><span class="pre">|m|</span> <span class="pre">&lt;=</span> <span class="pre">n</span></tt></p>
<blockquote>
<div><p>The order of the harmonic.</p>
</div></blockquote>
<p><strong>n</strong> : int <tt class="docutils literal"><span class="pre">&gt;=</span> <span class="pre">0</span></tt></p>
<blockquote>
<div><p>The degree of the harmonic.</p>
</div></blockquote>
<p><strong>theta</strong> : float [0, 2*pi]</p>
<blockquote>
<div><p>The azimuthal (longitudinal) coordinate.</p>
</div></blockquote>
<p><strong>phi</strong> : float [0, pi]</p>
<blockquote>
<div><p>The polar (colatitudinal) coordinate.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>y_mn</strong> : real float</p>
<blockquote class="last">
<div><p>The real harmonic <span class="math">Y^m_n</span> sampled at <cite>theta</cite> and <cite>phi</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-obj docutils literal"><span class="pre">scipy.special.sph_harm</span></tt></p>
</div>
</dd></dl>

</div>
<div class="section" id="shore-indices">
<h3>shore_indices<a class="headerlink" href="#shore-indices" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shore.shore_indices">
<tt class="descclassname">dipy.reconst.shore.</tt><tt class="descname">shore_indices</tt><big>(</big><em>radial_order</em>, <em>index</em><big>)</big><a class="headerlink" href="#dipy.reconst.shore.shore_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the basis order and the index, return the shore indices n, l, m
for modified Merlet&#8217;s 3D-SHORE
..math:</p>
<div class="highlight-python"><div class="highlight"><pre>:nowrap:
    \begin{equation}
        \textbf{E}(q\textbf{u})=\sum_{l=0, even}^{N_{max}}
                                \sum_{n=l}^{(N_{max}+l)/2}
                                \sum_{m=-l}^l c_{nlm}
                                \phi_{nlm}(q\textbf{u})
    \end{equation}
</pre></div>
</div>
<p>where <span class="math">\phi_{nlm}</span> is
..math:</p>
<div class="highlight-python"><div class="highlight"><pre>:nowrap:
    \begin{equation}
        \phi_{nlm}^{SHORE}(q\textbf{u})=\Biggl[\dfrac{2(n-l)!}
            {\zeta^{3/2} \Gamma(n+3/2)} \Biggr]^{1/2}
            \Biggl(\dfrac{q^2}{\zeta}\Biggr)^{l/2}
            exp\Biggl(\dfrac{-q^2}{2\zeta}\Biggr)
            L^{l+1/2}_{n-l} \Biggl(\dfrac{q^2}{\zeta}\Biggr)
            Y_l^m(\textbf{u}).
    \end{equation}
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>radial_order</strong> : unsigned int</p>
<blockquote>
<div><p>an even integer that represent the maximal order of the basis</p>
</div></blockquote>
<p><strong>index</strong> : unsigned int</p>
<blockquote>
<div><p>index of the coefficients, start from 0</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>n</strong> :  unsigned int</p>
<blockquote>
<div><p>the index n of the modified shore basis</p>
</div></blockquote>
<p><strong>l</strong> :  unsigned int</p>
<blockquote>
<div><p>the index l of the modified shore basis</p>
</div></blockquote>
<p><strong>m</strong> :  unsigned int</p>
<blockquote class="last">
<div><p>the index m of the modified shore basis</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="shore-matrix">
<h3>shore_matrix<a class="headerlink" href="#shore-matrix" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shore.shore_matrix">
<tt class="descclassname">dipy.reconst.shore.</tt><tt class="descname">shore_matrix</tt><big>(</big><em>radial_order</em>, <em>zeta</em>, <em>gtab</em>, <em>tau=0.025330295910584444</em><big>)</big><a class="headerlink" href="#dipy.reconst.shore.shore_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the SHORE matrix for modified Merlet&#8217;s 3D-SHORE <a class="reference internal" href="#r158" id="id267">[R158]</a></p>
<dl class="docutils">
<dt>..math::</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">nowrap:</th><td class="field-body"><dl class="first docutils">
<dt>begin{equation}</dt>
<dd><dl class="first last docutils">
<dt>textbf{E}(qtextbf{u})=sum_{l=0, even}^{N_{max}}</dt>
<dd><p class="first last">sum_{n=l}^{(N_{max}+l)/2}
sum_{m=-l}^l c_{nlm}
phi_{nlm}(qtextbf{u})</p>
</dd>
</dl>
</dd>
</dl>
<p class="last">end{equation}</p>
</td>
</tr>
</tbody>
</table>
</dd>
</dl>
<p>where <span class="math">\phi_{nlm}</span> is
..math:</p>
<div class="highlight-python"><div class="highlight"><pre>:nowrap:
    \begin{equation}
        \phi_{nlm}^{SHORE}(q\textbf{u})=\Biggl[\dfrac{2(n-l)!}
            {\zeta^{3/2} \Gamma(n+3/2)} \Biggr]^{1/2}
            \Biggl(\dfrac{q^2}{\zeta}\Biggr)^{l/2}
            exp\Biggl(\dfrac{-q^2}{2\zeta}\Biggr)
            L^{l+1/2}_{n-l} \Biggl(\dfrac{q^2}{\zeta}\Biggr)
            Y_l^m(\textbf{u}).
    \end{equation}
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>radial_order</strong> : unsigned int,</p>
<blockquote>
<div><p>an even integer that represent the order of the basis</p>
</div></blockquote>
<p><strong>zeta</strong> : unsigned int,</p>
<blockquote>
<div><p>scale factor</p>
</div></blockquote>
<p><strong>gtab</strong> : GradientTable,</p>
<blockquote>
<div><p>gradient directions and bvalues container class</p>
</div></blockquote>
<p><strong>tau</strong> : float,</p>
<blockquote class="last">
<div><p>diffusion time. By default the value that makes q=sqrt(b).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r158" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R158]</td><td><em>(<a class="fn-backref" href="#id267">1</a>, <a class="fn-backref" href="#id268">2</a>)</em> Merlet S. et. al, &#8220;Continuous diffusion signal, EAP and</td></tr>
</tbody>
</table>
<p>ODF estimation via Compressive Sensing in diffusion MRI&#8221;, Medical
Image Analysis, 2013.</p>
</dd></dl>

</div>
<div class="section" id="shore-matrix-odf">
<h3>shore_matrix_odf<a class="headerlink" href="#shore-matrix-odf" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shore.shore_matrix_odf">
<tt class="descclassname">dipy.reconst.shore.</tt><tt class="descname">shore_matrix_odf</tt><big>(</big><em>radial_order</em>, <em>zeta</em>, <em>sphere_vertices</em><big>)</big><a class="headerlink" href="#dipy.reconst.shore.shore_matrix_odf" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the SHORE ODF matrix <a class="reference internal" href="#r159" id="id269">[R159]</a>&#8220;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>radial_order</strong> : unsigned int,</p>
<blockquote>
<div><p>an even integer that represent the order of the basis</p>
</div></blockquote>
<p><strong>zeta</strong> : unsigned int,</p>
<blockquote>
<div><p>scale factor</p>
</div></blockquote>
<p><strong>sphere_vertices</strong> : array, shape (N,3)</p>
<blockquote class="last">
<div><p>vertices of the odf sphere</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r159" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R159]</td><td><em>(<a class="fn-backref" href="#id269">1</a>, <a class="fn-backref" href="#id270">2</a>)</em> Merlet S. et. al, &#8220;Continuous diffusion signal, EAP and</td></tr>
</tbody>
</table>
<p>ODF estimation via Compressive Sensing in diffusion MRI&#8221;, Medical
Image Analysis, 2013.</p>
</dd></dl>

</div>
<div class="section" id="shore-matrix-pdf">
<h3>shore_matrix_pdf<a class="headerlink" href="#shore-matrix-pdf" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shore.shore_matrix_pdf">
<tt class="descclassname">dipy.reconst.shore.</tt><tt class="descname">shore_matrix_pdf</tt><big>(</big><em>radial_order</em>, <em>zeta</em>, <em>rtab</em><big>)</big><a class="headerlink" href="#dipy.reconst.shore.shore_matrix_pdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the SHORE propagator matrix <a class="reference internal" href="#r160" id="id271">[R160]</a>&#8220;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>radial_order</strong> : unsigned int,</p>
<blockquote>
<div><p>an even integer that represent the order of the basis</p>
</div></blockquote>
<p><strong>zeta</strong> : unsigned int,</p>
<blockquote>
<div><p>scale factor</p>
</div></blockquote>
<p><strong>rtab</strong> : array, shape (N,3)</p>
<blockquote class="last">
<div><p>real space points in which calculates the pdf</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r160" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R160]</td><td><em>(<a class="fn-backref" href="#id271">1</a>, <a class="fn-backref" href="#id272">2</a>)</em> Merlet S. et. al, &#8220;Continuous diffusion signal, EAP and</td></tr>
</tbody>
</table>
<p>ODF estimation via Compressive Sensing in diffusion MRI&#8221;, Medical
Image Analysis, 2013.</p>
</dd></dl>

</div>
<div class="section" id="shore-order">
<h3>shore_order<a class="headerlink" href="#shore-order" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shore.shore_order">
<tt class="descclassname">dipy.reconst.shore.</tt><tt class="descname">shore_order</tt><big>(</big><em>n</em>, <em>l</em>, <em>m</em><big>)</big><a class="headerlink" href="#dipy.reconst.shore.shore_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the indices (n,l,m) of the basis, return the minimum order
for those indices and their index for modified Merlet&#8217;s 3D-SHORE.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>n</strong> :  unsigned int</p>
<blockquote>
<div><p>the index n of the modified shore basis</p>
</div></blockquote>
<p><strong>l</strong> :  unsigned int</p>
<blockquote>
<div><p>the index l of the modified shore basis</p>
</div></blockquote>
<p><strong>m</strong> :  unsigned int</p>
<blockquote>
<div><p>the index m of the modified shore basis</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>radial_order</strong> : unsigned int</p>
<blockquote>
<div><p>an even integer that represent the maximal order of the basis</p>
</div></blockquote>
<p><strong>index</strong> : unsigned int</p>
<blockquote class="last">
<div><p>index of the coefficient correspondig to (n,l,m), start from 0</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id273">
<h3>warn<a class="headerlink" href="#id273" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.reconst.shore.warn">
<tt class="descclassname">dipy.reconst.shore.</tt><tt class="descname">warn</tt><big>(</big><big>)</big><a class="headerlink" href="#dipy.reconst.shore.warn" title="Permalink to this definition">¶</a></dt>
<dd><p>Issue a warning, or maybe ignore it or raise an exception.</p>
</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
  <li><a href="../index.html">Home</a> |&nbsp;</li>
  <li><a href="../stateoftheart.html">Overview</a> |&nbsp;</li>
  <li><a href="../examples_index.html">Gallery</a> |&nbsp;</li>
  <li><a href="../installation.html">Download</a> |&nbsp;</li>
  <li><a href="../subscribe.html">Subscribe</a> |&nbsp;</li>
  <li><a href="../developers.html">Developers</a> |&nbsp;</li>
  <li><a href="../cite.html">Cite</a> &nbsp;</li>

          <li><a href="../documentation.html" >Documentation</a> &raquo;</li>
          <li><a href="index.html" >API Reference</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2008-2015, dipy developers &lt;nipy-devel@neuroimaging.scipy.org&gt;.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>